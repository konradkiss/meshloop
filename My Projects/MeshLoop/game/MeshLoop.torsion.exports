<exports>
<class>
<name>ActionMap</name>
<base>SimObject</base>
<method>
<name>bind</name>
<args> device, action, [modifier spec, mod...], command </args>
</method>
<method>
<name>bindCmd</name>
<args> device, action, makeCmd, breakCmd </args>
</method>
<method>
<name>bindObj</name>
<args>device, action, [modifier spec, mod...], command, object</args>
</method>
<method>
<name>getBinding</name>
<args> command </args>
</method>
<method>
<name>getCommand</name>
<args> device, action </args>
</method>
<method>
<name>getDeadZone</name>
<args> device, action </args>
</method>
<method>
<name>getScale</name>
<args> device, action </args>
</method>
<method>
<name>isInverted</name>
<args> device, action </args>
</method>
<method>
<name>pop</name>
</method>
<method>
<name>push</name>
</method>
<method>
<name>save</name>
<args> [fileName], [append] </args>
</method>
<method>
<name>unbind</name>
<args> device, action </args>
</method>
<method>
<name>unbindObj</name>
<args>device, action, object</args>
</method>
</class>
<class>
<name>ActionMapGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>ActiveActionMapSet</name>
<base>SimSet</base>
</class>
<class>
<name>AdvancedLightBinManager</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>AIClient</name>
<base>AIConnection</base>
<method>
<name>getAimLocation</name>
</method>
<method>
<name>getLocation</name>
</method>
<method>
<name>getMoveDestination</name>
</method>
<method>
<name>getTargetObject</name>
</method>
<method>
<name>missionCycleCleanup</name>
</method>
<method>
<name>move</name>
</method>
<method>
<name>moveForward</name>
</method>
<method>
<name>setAimLocation</name>
<args> x y z </args>
</method>
<method>
<name>setMoveDestination</name>
<args> x y z </args>
</method>
<method>
<name>setMoveSpeed</name>
<args> float </args>
</method>
<method>
<name>setTargetObject</name>
<args> obj </args>
</method>
<method>
<name>stop</name>
</method>
</class>
<class>
<name>AIConnection</name>
<base>GameConnection</base>
<method>
<name>getAddress</name>
</method>
<method>
<name>getFreeLook</name>
<desc>Is freelook on for the current move?</desc>
</method>
<method>
<name>getMove</name>
<args>string field</args>
<desc>Get the given field of a move.

@param field One of {'x','y','z','yaw','pitch','roll'}
@returns The requested field on the current move.</desc>
</method>
<method>
<name>getTrigger</name>
<args>int trigger</args>
<desc>Is the given trigger set?</desc>
</method>
<method>
<name>setFreeLook</name>
<args>bool isFreeLook</args>
<desc>Enable/disable freelook on the current move.</desc>
</method>
<method>
<name>setMove</name>
<args>string field, float value</args>
<desc>Set a field on the current move.

@param   field One of {'x','y','z','yaw','pitch','roll'}
@param   value Value to set field to.</desc>
</method>
<method>
<name>setTrigger</name>
<args>int trigger, bool set</args>
<desc>Set a trigger.</desc>
</method>
</class>
<class>
<name>AIPlayer</name>
<base>Player</base>
<method>
<name>clearAim</name>
<desc>Stop aiming at anything.</desc>
</method>
<method>
<name>getAimLocation</name>
<desc>Returns the point the AI is aiming at.</desc>
</method>
<method>
<name>getAimObject</name>
<desc>Gets the object the AI is targeting.</desc>
</method>
<method>
<name>getMoveDestination</name>
<desc>Returns the point the AI is set to move to.</desc>
</method>
<method>
<name>setAimLocation</name>
<args> Point3F target </args>
<desc>Tells the AI to aim at the location provided.</desc>
</method>
<method>
<name>setAimObject</name>
<args> GameBase obj, [Point3F offset] </args>
<desc>Sets the bot's target object. Optionally set an offset from target location.</desc>
</method>
<method>
<name>setMoveDestination</name>
<args>Point3F goal, bool slowDown=true</args>
<desc>Tells the AI to move to the location provided.</desc>
</method>
<method>
<name>setMoveSpeed</name>
<args> float speed </args>
<desc>Sets the move speed for an AI object.</desc>
</method>
<method>
<name>stop</name>
<desc>Stop moving.</desc>
</method>
</class>
<class>
<name>ArrayObject</name>
<base>SimObject</base>
<method>
<name>add</name>
<args>string key, string value</args>
<desc>Adds a new element to the end of an array</desc>
</method>
<method>
<name>append</name>
<args>ArrayObject target</args>
<desc>Appends the target array to the array object</desc>
</method>
<method>
<name>count</name>
<desc>Get the number of elements in the array</desc>
</method>
<method>
<name>countKey</name>
<args>string key</args>
<desc>Get the number of times a particular key is found in the array</desc>
</method>
<method>
<name>countValue</name>
<args>string value</args>
<desc>Get the number of times a particular value is found in the array</desc>
</method>
<method>
<name>crop</name>
<args>ArrayObject target</args>
<desc>Removes elements with matching keys from array</desc>
</method>
<method>
<name>duplicate</name>
<args>ArrayObject target</args>
<desc>Alters array into an exact duplicate of the target array</desc>
</method>
<method>
<name>echo</name>
<desc>Echos the array in the console</desc>
</method>
<method>
<name>empty</name>
<desc>Emptys all elements from an array</desc>
</method>
<method>
<name>erase</name>
<args>int index</args>
<desc>Removes an element at a specific position from the array</desc>
</method>
<method>
<name>getCurrent</name>
<desc>Gets the current pointer index</desc>
</method>
<method>
<name>getIndexFromKey</name>
<args>string key</args>
<desc>Search array from current position for the first matching key</desc>
</method>
<method>
<name>getIndexFromValue</name>
<args>string value</args>
<desc>Search array from current position for the first matching value</desc>
</method>
<method>
<name>getKey</name>
<args>int index</args>
<desc>Get the key of the array element at the submitted index</desc>
</method>
<method>
<name>getValue</name>
<args>int index</args>
<desc>Get the value of the array element at the submitted index</desc>
</method>
<method>
<name>insert</name>
<args>string key, string value, int index</args>
<desc>Adds a new element to a specified position in the array</desc>
</method>
<method>
<name>moveFirst</name>
<desc>Moves array pointer to start of array</desc>
</method>
<method>
<name>moveLast</name>
<desc>Moves array pointer to end of array</desc>
</method>
<method>
<name>moveNext</name>
<desc>Moves array pointer to next position (returns -1 if cannot move)</desc>
</method>
<method>
<name>movePrev</name>
<desc>Moves array pointer to prev position (returns -1 if cannot move)</desc>
</method>
<method>
<name>pop_back</name>
<desc>Removes the last element from the array</desc>
</method>
<method>
<name>pop_front</name>
<desc>Removes the first element from the array</desc>
</method>
<method>
<name>push_back</name>
<args>string key, string value</args>
<desc>Adds a new element to the end of an array</desc>
</method>
<method>
<name>push_front</name>
<args>string key, string value</args>
<desc>Adds a new element to the front of an array</desc>
</method>
<method>
<name>setCurrent</name>
<desc>Sets the current pointer index</desc>
</method>
<method>
<name>setKey</name>
<args>string key, int index</args>
<desc>Set the key at the given index</desc>
</method>
<method>
<name>setValue</name>
<args>string value, int index</args>
<desc>Set the value at the given index</desc>
</method>
<method>
<name>sort</name>
<args>bool desc</args>
<desc>Alpha sorts the array by value (default ascending sort)</desc>
</method>
<method>
<name>sorta</name>
<desc>Alpha sorts the array by value in ascending order</desc>
</method>
<method>
<name>sortd</name>
<desc>Alpha sorts the array by value in descending order</desc>
</method>
<method>
<name>sortk</name>
<args>bool desc</args>
<desc>Alpha sorts the array by key (default ascending sort)</desc>
</method>
<method>
<name>sortka</name>
<desc>Alpha sorts the array by key in ascending order</desc>
</method>
<method>
<name>sortkd</name>
<desc>Alpha sorts the array by key in descending order</desc>
</method>
<method>
<name>sortn</name>
<args>bool desc</args>
<desc>Numerically sorts the array by value (default ascending sort)</desc>
</method>
<method>
<name>sortna</name>
<desc>Numerically sorts the array by value in ascending order</desc>
</method>
<method>
<name>sortnd</name>
<desc>Numerically sorts the array by value in descending order</desc>
</method>
<method>
<name>sortnk</name>
<args>bool desc</args>
<desc>Numerically sorts the array by key (default ascending sort)</desc>
</method>
<method>
<name>sortnka</name>
<desc>Numerical sorts the array by key in ascending order</desc>
</method>
<method>
<name>sortnkd</name>
<desc>Numerical sorts the array by key in descending order</desc>
</method>
<method>
<name>uniqueKey</name>
<desc>Removes any elements that have duplicated keys (leaving the first instance)</desc>
</method>
<method>
<name>uniqueValue</name>
<desc>Removes any elements that have duplicated values (leaving the first instance)</desc>
</method>
<field>
<name>caseSensitive</name>
<desc>bool caseSensitive</desc>
</field>
</class>
<class>
<name>BanList</name>
<base>SimObject</base>
<method>
<name>add</name>
<args> int ID, TransportAddress TA, int banLength </args>
<desc>Ban a user for banLength seconds.

@param   ID       Unique ID of the player.
@param   TA       Address from which the player connected.
@param   banTime  Time at which they will be allowed back in.</desc>
</method>
<method>
<name>addAbsolute</name>
<args> int ID, TransportAddress TA, int banTime </args>
<desc>Ban a user until a given time.

@param   ID       Unique ID of the player.
@param   TA       Address from which the player connected.
@param   banTime  Time at which they will be allowed back in.</desc>
</method>
<method>
<name>export</name>
<args>string filename</args>
<desc>Dump the banlist to a file.</desc>
</method>
<method>
<name>isBanned</name>
<args> int ID, TransportAddress TA </args>
<desc>Is someone banned?

@param   ID       Unique ID of the player.
@param   TA       Address from which the player connected.</desc>
</method>
<method>
<name>removeBan</name>
<args> int ID, TransportAddress TA </args>
<desc>Unban someone.

@param   ID       Unique ID of the player.
@param   TA       Address from which the player connected.</desc>
</method>
</class>
<class>
<name>BasicClouds</name>
<base>SceneObject</base>
<field>
<name>height</name>
<desc>float height</desc>
</field>
<field>
<name>layerEnabled</name>
<desc>bool layerEnabled</desc>
</field>
<field>
<name>texDirection</name>
<desc>Point2F texDirection</desc>
</field>
<field>
<name>texOffset</name>
<desc>Point2F texOffset</desc>
</field>
<field>
<name>texScale</name>
<desc>float texScale</desc>
</field>
<field>
<name>texSpeed</name>
<desc>float texSpeed</desc>
</field>
<field>
<name>texture</name>
<desc>filename texture</desc>
</field>
</class>
<class>
<name>BehaviorSet</name>
<base>SimSet</base>
</class>
<class>
<name>CachedInterfaceExampleComponent</name>
<base>SimComponent</base>
</class>
<class>
<name>Camera</name>
<base>ShapeBase</base>
<method>
<name>autoFitRadius</name>
<args>F32 radius</args>
<desc>- Orient the camera to view the given radius.

@param radius   Selection radius to view</desc>
</method>
<method>
<name>getAngularVelocity</name>
<desc>- Get the angular velocity of the camera.

@returns A string of form "x y z".</desc>
</method>
<method>
<name>getMode</name>
<desc>- Returns the current camera control mode.</desc>
</method>
<method>
<name>getOffset</name>
<desc>- Get the offset for the camera.

@returns A string of form "x y z".</desc>
</method>
<method>
<name>getPosition</name>
<desc>- Get the position of the camera.

@returns A string of form "x y z".</desc>
</method>
<method>
<name>getRotation</name>
<desc>- Get the euler rotation of the camera.

@returns A string of form "x y z".</desc>
</method>
<method>
<name>getVelocity</name>
<desc>- Get the velocity of the camera.

@returns A string of form "x y z".</desc>
</method>
<method>
<name>isEditOrbitMode</name>
<desc>- Is the camera in edit orbit mode</desc>
</method>
<method>
<name>isRotationDamped</name>
<desc>- Is this a Newton Fly Mode camera with damped rotation?</desc>
</method>
<method>
<name>lookAt</name>
<args>point p</args>
<desc>- Point the camera at the specified location. (does not work in Orbit or Track modes)</desc>
</method>
<method>
<name>setAngularDrag</name>
<args>F32</args>
<desc>- Angular drag for Newton camera</desc>
</method>
<method>
<name>setAngularForce</name>
<args>F32</args>
<desc>- Angular force for Newton camera</desc>
</method>
<method>
<name>setAngularVelocity</name>
<args>VectorF velocity</args>
<desc>- Set the angular velocity for the camera.

@param velocity   Angular velocity in the form of: velX, velY, velZ</desc>
</method>
<method>
<name>setBrakeMultiplier</name>
<args>F32</args>
<desc>- Newton camera brake multiplier when trigger[1] is active</desc>
</method>
<method>
<name>setDrag</name>
<args>F32</args>
<desc>- Drag of Newton camera</desc>
</method>
<method>
<name>setEditOrbitMode</name>
<desc>- Set the editor camera to orbit around some point.</desc>
</method>
<method>
<name>setEditOrbitPoint</name>
<args>Point3F point</args>
<desc>- Set the editor camera's orbit point.

@param point   Orbit point in the form of: 'x y z'</desc>
</method>
<method>
<name>setFlyForce</name>
<args>F32</args>
<desc>- Force of Newton camera</desc>
</method>
<method>
<name>setFlyMode</name>
<desc>- Set the camera to be able to fly freely.</desc>
</method>
<method>
<name>setMass</name>
<args>F32</args>
<desc>- Mass of Newton camera</desc>
</method>
<method>
<name>setNewtonFlyMode</name>
<desc>- Set the camera to be able to fly freely, but with ease-in and ease-out.</desc>
</method>
<method>
<name>setOffset</name>
<args>Point3F offset</args>
<desc>- Set the offset for the camera.</desc>
</method>
<method>
<name>setOrbitMode</name>
<args>GameBase orbitObject, transform mat, float minDistance, float maxDistance, float curDistance, [bool ownClientObject = false], [Point3F offset], [bool locked = false]</args>
<desc>Set the camera to orbit around some given object.  If the object passed
is 0 or NULL, orbit around the point specified by mat.

@param   orbitObject  Object we want to orbit.
@param   mat          A set of fields: posX posY posZ rotX rotY rotZ
@param   minDistance  Minimum distance to keep from object.
@param   maxDistance  Maximum distance to keep from object.
@param   curDistance  Distance to set initially from object.
@param   ownClientObj Are we observing an object owned by us?
@param   offset       An offset to add to our position
@param   locked       Camera doesn't receive inputs from player</desc>
</method>
<method>
<name>setOrbitObject</name>
<args>GameBase orbitObject, vector rotation, float minDistance, float maxDistance, [float curDistance], [bool ownClientObject = false], [Point3F offset], [bool locked = false]</args>
<desc>Set the camera to orbit around some given object.

@param   orbitObject  Object we want to orbit.
@param   rotation     Initial camera angles in radians (x, y, z).
@param   minDistance  Minimum distance to keep from object.
@param   maxDistance  Maximum distance to keep from object.
@param   curDistance  Initial distance from object (default=maxDistance).
@param   ownClientObj Are we observing an object owned by us?
@param   offset       An offset to add to our position
@param   locked       Camera doesn't receive inputs from player</desc>
</method>
<method>
<name>setOrbitPoint</name>
<args>transform xform, float minDistance, float maxDistance, [float curDistance], [Point3F offset], [bool locked = false]</args>
<desc>Set the camera to orbit around some given point.

@param   xform        A set of fields: posX posY posZ rotX rotY rotZ
@param   minDistance  Minimum distance to keep from point.
@param   maxDistance  Maximum distance to keep from point.
@param   curDistance  Initial distance from point (default=maxDistance).
@param   offset       An offset to add to our position
@param   locked       Camera doesn't receive inputs from player</desc>
</method>
<method>
<name>setSpeedMultiplier</name>
<args>F32</args>
<desc>- Newton camera speed multiplier when trigger[0] is active</desc>
</method>
<method>
<name>setTrackObject</name>
<args>GameBase object, [Point3F offset]</args>
<desc>- Set the camera to track some given object.

@param   object       Object we want to track
@param   offset       An offset to add to our object</desc>
</method>
<method>
<name>setValidEditOrbitPoint</name>
<args>bool</args>
<desc>- Indicate if there is a valid editor camera orbit point</desc>
</method>
<method>
<name>setVelocity</name>
<args>VectorF velocity</args>
<desc>- Set the velocity for the camera.

@param velocity   Velocity in the form of: 'x y z'</desc>
</method>
<field>
<name>angularDrag</name>
<desc>Drag on camera when rotating.</desc>
</field>
<field>
<name>angularForce</name>
<desc>Force on camera when rotating.</desc>
</field>
<field>
<name>brakeMultiplier</name>
<desc>Speed multiplier when triggering the brake.</desc>
</field>
<field>
<name>controlMode</name>
<desc>The current camera control mode.</desc>
</field>
<field>
<name>drag</name>
<desc>Drag on camera when moving.</desc>
</field>
<field>
<name>force</name>
<desc>Force on camera when moving.</desc>
</field>
<field>
<name>mass</name>
<desc>Camera mass.</desc>
</field>
<field>
<name>newtonMode</name>
<desc>Apply smoothing (acceleration) to camera movements.</desc>
</field>
<field>
<name>newtonRotation</name>
<desc>Apply smoothing (acceleration) to camera rotations.</desc>
</field>
<field>
<name>speedMultiplier</name>
<desc>Speed multiplier when triggering the accelerator.</desc>
</field>
</class>
<class>
<name>CameraBookmark</name>
<base>MissionMarker</base>
</class>
<class>
<name>CameraData</name>
<base>ShapeBaseData</base>
</class>
<class>
<name>CBTest</name>
<base>SimObject</base>
<field>
<name>onCollide(Point3F pos, Point3F normal, S32 b, F32 c)</name>
<desc>Simple callback issued on collision events.</desc>
</field>
</class>
<class>
<name>ChunkFileGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>ClientConnectionGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>ClientGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>CloudLayer</name>
<base>SceneObject</base>
<field>
<name>BaseColor</name>
<desc>ColorF BaseColor</desc>
</field>
<field>
<name>coverage</name>
<desc>float coverage</desc>
</field>
<field>
<name>height</name>
<desc>float height</desc>
</field>
<field>
<name>texDirection</name>
<desc>Point2F texDirection</desc>
</field>
<field>
<name>texScale</name>
<desc>float texScale</desc>
</field>
<field>
<name>texSpeed</name>
<desc>float texSpeed</desc>
</field>
<field>
<name>texture</name>
<desc>filename texture</desc>
</field>
<field>
<name>windSpeed</name>
<desc>float windSpeed</desc>
</field>
</class>
<class>
<name>ConnectionMessageEvent</name>
</class>
<class>
<name>ConsoleLogger</name>
<base>SimObject</base>
<method>
<name>attach</name>
<desc>Attaches this object to the console and begins logging</desc>
</method>
<method>
<name>detach</name>
<desc>Detaches this object from the console and stops logging</desc>
</method>
<field>
<name>level</name>
<desc>enumval level</desc>
</field>
</class>
<class>
<name>CreatorTree</name>
<base>GuiArrayCtrl</base>
<method>
<name>addGroup</name>
<args>string group, string name, string value</args>
</method>
<method>
<name>addItem</name>
<args>Node group, string name, string value</args>
</method>
<method>
<name>clear</name>
<desc>Clear the tree.</desc>
</method>
<method>
<name>fileNameMatch</name>
<args>string world, string type, string filename</args>
</method>
<method>
<name>getName</name>
<args>Node item</args>
</method>
<method>
<name>getParent</name>
<args>Node n</args>
</method>
<method>
<name>getSelected</name>
<desc>Return a handle to the currently selected item.</desc>
</method>
<method>
<name>getValue</name>
<args>Node n</args>
</method>
<method>
<name>isGroup</name>
<args>Group g</args>
</method>
</class>
<class>
<name>CubemapData</name>
<base>SimObject</base>
<method>
<name>getFilename</name>
<desc>Get filename of CubemapData</desc>
</method>
<method>
<name>updateFaces</name>
<desc>: Update the newly assigned cubemaps faces.</desc>
</method>
<field>
<name>cubeFace</name>
<desc>filename cubeFace</desc>
</field>
<field>
<name>dynamic</name>
<desc>bool dynamic</desc>
</field>
<field>
<name>dynamicFarDist</name>
<desc>float dynamicFarDist</desc>
</field>
<field>
<name>dynamicNearDist</name>
<desc>float dynamicNearDist</desc>
</field>
<field>
<name>dynamicObjectTypeMask</name>
<desc>int dynamicObjectTypeMask</desc>
</field>
<field>
<name>DynamicSize</name>
<desc>int DynamicSize</desc>
</field>
</class>
<class>
<name>CustomMaterial</name>
<base>Material</base>
<field>
<name>fallback</name>
<desc>SimObjectPtr fallback</desc>
</field>
<field>
<name>shader</name>
<desc>String shader</desc>
</field>
<field>
<name>stateBlock</name>
<desc>SimObjectPtr stateBlock</desc>
</field>
<field>
<name>target</name>
<desc>String target</desc>
</field>
<field>
<name>texture</name>
<desc>filename texture</desc>
</field>
<field>
<name>version</name>
<desc>float version</desc>
</field>
</class>
<class>
<name>DataBlockGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>DBDeleteUndoAction</name>
<base>UndoAction</base>
</class>
<class>
<name>DbgFileView</name>
<base>GuiArrayCtrl</base>
<method>
<name>clearBreakPositions</name>
<desc>Clear all break points in the current file.</desc>
</method>
<method>
<name>findString</name>
<args>string findThis</args>
<desc>Find the specified string in the currently viewed file and scroll it into view.</desc>
</method>
<method>
<name>getCurrentLine</name>
<desc>Get the currently executing file and line, if any.

@returns A string containing the file, a tab, and then the line number. Use getField() with this.</desc>
</method>
<method>
<name>open</name>
<args>string filename</args>
<desc>Open a file for viewing.

@note This loads the file from the local system.</desc>
</method>
<method>
<name>removeBreak</name>
<args>int line</args>
<desc>Remove a breakpoint from the specified line.</desc>
</method>
<method>
<name>setBreak</name>
<args>int line</args>
<desc>Set a breakpoint at the specified line.</desc>
</method>
<method>
<name>setBreakPosition</name>
<args>int line</args>
<desc>Set a breakpoint at the specified line.</desc>
</method>
<method>
<name>setCurrentLine</name>
<args>int line, bool selected</args>
<desc>Set the current highlighted line.</desc>
</method>
</class>
<class>
<name>Debris</name>
<base>GameBase</base>
<method>
<name>init</name>
<args>Point3F position, Point3F velocity</args>
<desc>Set this piece of debris at the given position with the given velocity.</desc>
</method>
<field>
<name>lifetime</name>
<desc>float lifetime</desc>
</field>
</class>
<class>
<name>DebrisData</name>
<base>GameBaseData</base>
<field>
<name>baseRadius</name>
<desc>float baseRadius</desc>
</field>
<field>
<name>bounceVariance</name>
<desc>int bounceVariance</desc>
</field>
<field>
<name>elasticity</name>
<desc>float elasticity</desc>
</field>
<field>
<name>emitters</name>
<desc>ParticleEmitterData emitters</desc>
</field>
<field>
<name>explodeOnMaxBounce</name>
<desc>bool explodeOnMaxBounce</desc>
</field>
<field>
<name>Explosion</name>
<desc>ExplosionData Explosion</desc>
</field>
<field>
<name>fade</name>
<desc>bool fade</desc>
</field>
<field>
<name>friction</name>
<desc>float friction</desc>
</field>
<field>
<name>gravModifier</name>
<desc>float gravModifier</desc>
</field>
<field>
<name>ignoreWater</name>
<desc>bool ignoreWater</desc>
</field>
<field>
<name>lifetime</name>
<desc>float lifetime</desc>
</field>
<field>
<name>lifetimeVariance</name>
<desc>float lifetimeVariance</desc>
</field>
<field>
<name>maxSpinSpeed</name>
<desc>float maxSpinSpeed</desc>
</field>
<field>
<name>minSpinSpeed</name>
<desc>float minSpinSpeed</desc>
</field>
<field>
<name>numBounces</name>
<desc>int numBounces</desc>
</field>
<field>
<name>render2D</name>
<desc>bool render2D</desc>
</field>
<field>
<name>shapeFile</name>
<desc>filename shapeFile</desc>
</field>
<field>
<name>snapOnMaxBounce</name>
<desc>bool snapOnMaxBounce</desc>
</field>
<field>
<name>staticOnMaxBounce</name>
<desc>bool staticOnMaxBounce</desc>
</field>
<field>
<name>terminalVelocity</name>
<desc>float terminalVelocity</desc>
</field>
<field>
<name>texture</name>
<desc>string texture</desc>
</field>
<field>
<name>useRadiusMass</name>
<desc>bool useRadiusMass</desc>
</field>
<field>
<name>velocity</name>
<desc>float velocity</desc>
</field>
<field>
<name>velocityVariance</name>
<desc>float velocityVariance</desc>
</field>
</class>
<class>
<name>DebugDrawer</name>
<base>SimObject</base>
<method>
<name>drawLine</name>
<args>Point3F a, Point3F b</args>
</method>
<method>
<name>setLastTTL</name>
<args>U32 ms</args>
</method>
<method>
<name>setLastZTest</name>
<args>bool enabled</args>
</method>
<method>
<name>toggleDrawing</name>
<desc>- Enabled/disable drawing.</desc>
</method>
<method>
<name>toggleFreeze</name>
<desc>- Toggle freeze mode.</desc>
</method>
</class>
<class>
<name>DecalData</name>
<base>SimDataBlock</base>
<method>
<name>postApply</name>
</method>
<field>
<name>fadeTime</name>
<desc>int fadeTime</desc>
</field>
<field>
<name>frame</name>
<desc>int frame</desc>
</field>
<field>
<name>lifeSpan</name>
<desc>int lifeSpan</desc>
</field>
<field>
<name>Material</name>
<desc>MaterialName Material</desc>
</field>
<field>
<name>randomize</name>
<desc>bool randomize</desc>
</field>
<field>
<name>renderPriority</name>
<desc>Default renderPriority for decals of this type.</desc>
</field>
<field>
<name>screenEndRadius</name>
<desc>float screenEndRadius</desc>
</field>
<field>
<name>screenStartRadius</name>
<desc>float screenStartRadius</desc>
</field>
<field>
<name>size</name>
<desc>float size</desc>
</field>
<field>
<name>texCols</name>
<desc>int texCols</desc>
</field>
<field>
<name>texRows</name>
<desc>int texRows</desc>
</field>
<field>
<name>textureCoordCount</name>
<desc>int textureCoordCount</desc>
</field>
<field>
<name>textureCoords</name>
<desc>A RectF in uv space - eg ( topleft.x topleft.y extent.x extent.y )</desc>
</field>
</class>
<class>
<name>DecalManager</name>
<base>SceneObject</base>
</class>
<class>
<name>DecalRoad</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
</method>
<method>
<name>regenerate</name>
<desc>setRegenFlag()</desc>
</method>
<field>
<name>breakAngle</name>
<desc>Angle in degrees - DecalRoad will subdivided the spline if its curve is greater than this threshold.</desc>
</field>
<field>
<name>Material</name>
<desc>MaterialName Material</desc>
</field>
<field>
<name>Node</name>
<desc>string Node</desc>
</field>
<field>
<name>renderPriority</name>
<desc>DecalRoad(s) are rendered in descending renderPriority order</desc>
</field>
<field>
<name>textureLength</name>
<desc>float textureLength</desc>
</field>
</class>
<class>
<name>DICreateUndoAction</name>
<base>UndoAction</base>
</class>
<class>
<name>DIDeleteUndoAction</name>
<base>UndoAction</base>
</class>
<class>
<name>DynamicConsoleMethodComponent</name>
<base>SimComponent</base>
<method>
<name>callMethod</name>
<args>methodName, argi</args>
<desc>Calls script defined method
@param methodName The method's name as a string
@param argi Any arguments to pass to the method
@return No return value@note %obj.callMethod( %methodName, %arg1, %arg2, ... );</desc>
</method>
</class>
<class>
<name>EditManager</name>
<base>GuiControl</base>
<method>
<name>editorDisabled</name>
<desc>Perform the onEditorDisabled callback on all SimObjects and set gEditingMission false</desc>
</method>
<method>
<name>editorEnabled</name>
<desc>Perform the onEditorEnabled callback on all SimObjects and set gEditingMission true</desc>
</method>
<method>
<name>gotoBookmark</name>
<args>int slot</args>
</method>
<method>
<name>setBookmark</name>
<args>int slot</args>
</method>
</class>
<class>
<name>EditorIconRegistry</name>
<method>
<name>add</name>
<args> String className, String imageFile [, bool overwrite = true] </args>
</method>
<method>
<name>clear</name>
</method>
<method>
<name>findIconByClassName</name>
<args> String className </args>
<desc>Returns the file path to the icon file if found.</desc>
</method>
<method>
<name>findIconBySimObject</name>
<args> SimObject </args>
<desc>Returns the file path to the icon file if found.</desc>
</method>
<method>
<name>loadFromPath</name>
<args> String imagePath [, bool overwrite = true] </args>
</method>
</class>
<class>
<name>EditTSCtrl</name>
<base>GuiTSCtrl</base>
<method>
<name>getDisplayType</name>
</method>
<method>
<name>getGizmo</name>
</method>
<method>
<name>isMiddleMouseDown</name>
</method>
<method>
<name>renderBox</name>
<args> Point3F pos, Point3F size </args>
</method>
<method>
<name>renderCircle</name>
<args>Point3F pos, Point3F normal, float radius, int segments=NULL</args>
</method>
<method>
<name>renderLine</name>
<args>Point3F start, Point3F end, int width</args>
</method>
<method>
<name>renderSphere</name>
<args>Point3F pos, float radius, int subdivisions=NULL</args>
</method>
<method>
<name>renderTriangle</name>
<args>Point3F a, Point3F b, Point3F c</args>
</method>
<method>
<name>setDisplayType</name>
<args>int displayType</args>
</method>
<field>
<name>allowBorderMove</name>
<desc>bool allowBorderMove</desc>
</field>
<field>
<name>borderMovePixelSize</name>
<desc>int borderMovePixelSize</desc>
</field>
<field>
<name>borderMoveSpeed</name>
<desc>float borderMoveSpeed</desc>
</field>
<field>
<name>consoleCircleSegments</name>
<desc>int consoleCircleSegments</desc>
</field>
<field>
<name>consoleFillColor</name>
<desc>ColorI consoleFillColor</desc>
</field>
<field>
<name>consoleFrameColor</name>
<desc>ColorI consoleFrameColor</desc>
</field>
<field>
<name>consoleLineWidth</name>
<desc>int consoleLineWidth</desc>
</field>
<field>
<name>consoleSphereLevel</name>
<desc>int consoleSphereLevel</desc>
</field>
<field>
<name>GizmoProfile</name>
<desc>SimObjectPtr GizmoProfile</desc>
</field>
<field>
<name>missionAreaFillColor</name>
<desc>ColorI missionAreaFillColor</desc>
</field>
<field>
<name>missionAreaFrameColor</name>
<desc>ColorI missionAreaFrameColor</desc>
</field>
<field>
<name>renderMissionArea</name>
<desc>bool renderMissionArea</desc>
</field>
</class>
<class>
<name>EventManager</name>
<base>SimObject</base>
<method>
<name>dumpEvents</name>
<desc>Print all registered events to the console.</desc>
</method>
<method>
<name>dumpSubscribers</name>
<args> String event </args>
<desc>Print all subscribers to an event to the console.
@param event The event whose subscribers are to be printed. If this parameter isn't specified, all events will be dumped.</desc>
</method>
<method>
<name>isRegisteredEvent</name>
<args> String event </args>
<desc>Check if an event is registered or not.
@param event The event to check.
@return Whether or not the event exists.</desc>
</method>
<method>
<name>postEvent</name>
<args> String event, String data </args>
<desc>Trigger an event.
@param event The event to trigger.
@param data The data associated with the event.
@return Whether or not the event was dispatched successfully.</desc>
</method>
<method>
<name>registerEvent</name>
<args> String event </args>
<desc>Register an event with the event manager.
@param event The event to register.
@return Whether or not the event was registered successfully.</desc>
</method>
<method>
<name>remove</name>
<args> SimObject listener, String event </args>
<desc>Remove a listener from an event.
@param listener The listener to remove.
@param event The event to be removed from.</desc>
</method>
<method>
<name>removeAll</name>
<args> SimObject listener </args>
<desc>Remove a listener from all events.
@param listener The listener to remove.</desc>
</method>
<method>
<name>subscribe</name>
<args> SimObject listener, String event, String callback </args>
<desc>Subscribe a listener to an event.
@param listener The listener to subscribe.
@param event The event to subscribe to.
@param callback Optional method name to receive the event notification. If this is not specified, "on[event]" will be used.
@return Whether or not the subscription was successful.</desc>
</method>
<method>
<name>unregisterEvent</name>
<args> String event </args>
<desc>Remove an event from the EventManager.
@param event The event to remove.</desc>
</method>
<field>
<name>queue</name>
<desc>string queue</desc>
</field>
</class>
<class>
<name>Explosion</name>
<base>GameBase</base>
</class>
<class>
<name>ExplosionData</name>
<base>GameBaseData</base>
<field>
<name>camShakeAmp</name>
<desc>Point3F camShakeAmp</desc>
</field>
<field>
<name>camShakeDuration</name>
<desc>float camShakeDuration</desc>
</field>
<field>
<name>camShakeFalloff</name>
<desc>float camShakeFalloff</desc>
</field>
<field>
<name>camShakeFreq</name>
<desc>Point3F camShakeFreq</desc>
</field>
<field>
<name>camShakeRadius</name>
<desc>float camShakeRadius</desc>
</field>
<field>
<name>Debris</name>
<desc>DebrisData Debris</desc>
</field>
<field>
<name>debrisNum</name>
<desc>int debrisNum</desc>
</field>
<field>
<name>debrisNumVariance</name>
<desc>int debrisNumVariance</desc>
</field>
<field>
<name>debrisPhiMax</name>
<desc>float debrisPhiMax</desc>
</field>
<field>
<name>debrisPhiMin</name>
<desc>float debrisPhiMin</desc>
</field>
<field>
<name>debrisThetaMax</name>
<desc>float debrisThetaMax</desc>
</field>
<field>
<name>debrisThetaMin</name>
<desc>float debrisThetaMin</desc>
</field>
<field>
<name>debrisVelocity</name>
<desc>float debrisVelocity</desc>
</field>
<field>
<name>debrisVelocityVariance</name>
<desc>float debrisVelocityVariance</desc>
</field>
<field>
<name>delayMS</name>
<desc>int delayMS</desc>
</field>
<field>
<name>delayVariance</name>
<desc>int delayVariance</desc>
</field>
<field>
<name>emitter</name>
<desc>ParticleEmitterData emitter</desc>
</field>
<field>
<name>explosionScale</name>
<desc>Point3F explosionScale</desc>
</field>
<field>
<name>explosionShape</name>
<desc>filename explosionShape</desc>
</field>
<field>
<name>faceViewer</name>
<desc>bool faceViewer</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>int lifetimeMS</desc>
</field>
<field>
<name>lifetimeVariance</name>
<desc>int lifetimeVariance</desc>
</field>
<field>
<name>lightEndBrightness</name>
<desc>float lightEndBrightness</desc>
</field>
<field>
<name>lightEndColor</name>
<desc>ColorF lightEndColor</desc>
</field>
<field>
<name>lightEndRadius</name>
<desc>float lightEndRadius</desc>
</field>
<field>
<name>lightNormalOffset</name>
<desc>float lightNormalOffset</desc>
</field>
<field>
<name>lightStartBrightness</name>
<desc>float lightStartBrightness</desc>
</field>
<field>
<name>lightStartColor</name>
<desc>ColorF lightStartColor</desc>
</field>
<field>
<name>lightStartRadius</name>
<desc>float lightStartRadius</desc>
</field>
<field>
<name>offset</name>
<desc>float offset</desc>
</field>
<field>
<name>particleDensity</name>
<desc>int particleDensity</desc>
</field>
<field>
<name>particleEmitter</name>
<desc>ParticleEmitterData particleEmitter</desc>
</field>
<field>
<name>particleRadius</name>
<desc>float particleRadius</desc>
</field>
<field>
<name>playSpeed</name>
<desc>float playSpeed</desc>
</field>
<field>
<name>shakeCamera</name>
<desc>bool shakeCamera</desc>
</field>
<field>
<name>sizes</name>
<desc>Point3F sizes</desc>
</field>
<field>
<name>soundProfile</name>
<desc>SFXProfile soundProfile</desc>
</field>
<field>
<name>subExplosion</name>
<desc>ExplosionData subExplosion</desc>
</field>
<field>
<name>times</name>
<desc>float times</desc>
</field>
</class>
<class>
<name>FieldBrushObject</name>
<base>SimObject</base>
<method>
<name>copyFields</name>
<args>simObject, [fieldList]</args>
<desc>Copy selected static-fields for selected object./
@param simObject Object to copy static-fields from.
@param fieldList fields to filter static-fields against.
@return No return value.</desc>
</method>
<method>
<name>pasteFields</name>
<args>simObject</args>
<desc>Paste copied static-fields to selected object./
@param simObject Object to paste static-fields to.
@return No return value.</desc>
</method>
<method>
<name>queryFields</name>
<args>simObject, [groupList]</args>
<desc>Query available static-fields for selected object./
@param simObject Object to query static-fields on.
@param groupList groups to filter static-fields against.
@return Space-seperated static-field list.</desc>
</method>
<method>
<name>queryGroups</name>
<args>simObject</args>
<desc>Query available static-field groups for selected object./
@param simObject Object to query static-field groups on.
@return Space-seperated static-field group list.</desc>
</method>
<field>
<name>description</name>
<desc>caseString description</desc>
</field>
<field>
<name>sortName</name>
<desc>string sortName</desc>
</field>
</class>
<class>
<name>FileChunkEvent</name>
</class>
<class>
<name>FileDialog</name>
<base>SimObject</base>
<method>
<name>Execute</name>
</method>
<field>
<name>changePath</name>
<desc>True/False whether to set the working directory to the directory returned by the dialog.</desc>
</field>
<field>
<name>defaultFile</name>
<desc>The default file path when the dialog is shown.</desc>
</field>
<field>
<name>defaultPath</name>
<desc>The default directory path when the dialog is shown.</desc>
</field>
<field>
<name>fileName</name>
<desc>The default file name when the dialog is shown.</desc>
</field>
<field>
<name>filters</name>
<desc>The filter string for limiting the types of files visible in the dialog.  For example:

^ 'All Files|*.*'
^ 'Image Files|*.png;*.jpg|Png Files|*.png|Jepg Files|*.jpg'</desc>
</field>
<field>
<name>title</name>
<desc>The title for the dialog.</desc>
</field>
</class>
<class>
<name>FileDownloadRequestEvent</name>
</class>
<class>
<name>FileObject</name>
<base>SimObject</base>
<method>
<name>close</name>
<desc>Close the file.</desc>
</method>
<method>
<name>isEOF</name>
<desc>Are we at the end of the file?</desc>
</method>
<method>
<name>openForAppend</name>
<args>string filename</args>
</method>
<method>
<name>openForRead</name>
<args>string filename</args>
</method>
<method>
<name>openForWrite</name>
<args>string filename</args>
</method>
<method>
<name>peekLine</name>
<desc>Read a line from the file without moving the stream position.</desc>
</method>
<method>
<name>readLine</name>
<desc>Read a line from the file.</desc>
</method>
<method>
<name>writeLine</name>
<args>string text</args>
<desc>Write a line to the file, if it was opened for writing.</desc>
</method>
<method>
<name>writeObject</name>
<args>SimObject, object prepend</args>
</method>
</class>
<class>
<name>FileStreamObject</name>
<base>StreamObject</base>
<method>
<name>close</name>
<desc>Close the file.</desc>
</method>
<method>
<name>open</name>
<args>filename, mode</args>
<desc>Open a file. Mode can be one of Read, Write, ReadWrite or WriteAppend.</desc>
</method>
</class>
<class>
<name>FlyingVehicle</name>
<base>Vehicle</base>
<method>
<name>useCreateHeight</name>
<args>bool enabled</args>
<desc>Should the vehicle temporarily use the create height specified in the datablock? This can help avoid problems with spawning.</desc>
</method>
</class>
<class>
<name>FlyingVehicleData</name>
<base>VehicleData</base>
<field>
<name>autoAngularForce</name>
<desc>float autoAngularForce</desc>
</field>
<field>
<name>autoInputDamping</name>
<desc>float autoInputDamping</desc>
</field>
<field>
<name>autoLinearForce</name>
<desc>float autoLinearForce</desc>
</field>
<field>
<name>backwardJetEmitter</name>
<desc>ParticleEmitterData backwardJetEmitter</desc>
</field>
<field>
<name>createHoverHeight</name>
<desc>float createHoverHeight</desc>
</field>
<field>
<name>downJetEmitter</name>
<desc>ParticleEmitterData downJetEmitter</desc>
</field>
<field>
<name>engineSound</name>
<desc>SFXProfile engineSound</desc>
</field>
<field>
<name>forwardJetEmitter</name>
<desc>ParticleEmitterData forwardJetEmitter</desc>
</field>
<field>
<name>horizontalSurfaceForce</name>
<desc>float horizontalSurfaceForce</desc>
</field>
<field>
<name>hoverHeight</name>
<desc>float hoverHeight</desc>
</field>
<field>
<name>jetSound</name>
<desc>SFXProfile jetSound</desc>
</field>
<field>
<name>maneuveringForce</name>
<desc>float maneuveringForce</desc>
</field>
<field>
<name>maxAutoSpeed</name>
<desc>float maxAutoSpeed</desc>
</field>
<field>
<name>minTrailSpeed</name>
<desc>float minTrailSpeed</desc>
</field>
<field>
<name>rollForce</name>
<desc>float rollForce</desc>
</field>
<field>
<name>rotationalDrag</name>
<desc>float rotationalDrag</desc>
</field>
<field>
<name>steeringForce</name>
<desc>float steeringForce</desc>
</field>
<field>
<name>steeringRollForce</name>
<desc>float steeringRollForce</desc>
</field>
<field>
<name>trailEmitter</name>
<desc>ParticleEmitterData trailEmitter</desc>
</field>
<field>
<name>verticalSurfaceForce</name>
<desc>float verticalSurfaceForce</desc>
</field>
<field>
<name>vertThrustMultiple</name>
<desc>float vertThrustMultiple</desc>
</field>
</class>
<class>
<name>ForcedMaterialMeshMgr</name>
<base>RenderMeshMgr</base>
<field>
<name>Material</name>
<desc>Material used to draw all meshes in the render bin.</desc>
</field>
</class>
<class>
<name>fxFoliageReplicator</name>
<base>SceneObject</base>
<field>
<name>AllowedTerrainSlope</name>
<desc>Maximum surface angle allowed for foliage instances.</desc>
</field>
<field>
<name>AllowOnInteriors</name>
<desc>Foliage will be placed on InteriorInstances when set.</desc>
</field>
<field>
<name>AllowOnStatics</name>
<desc>Foliage will be placed on Static shapes when set.</desc>
</field>
<field>
<name>AllowOnTerrain</name>
<desc>Foliage will be placed on terrain when set.</desc>
</field>
<field>
<name>AllowOnWater</name>
<desc>Foliage will be placed on/under water when set.</desc>
</field>
<field>
<name>AllowWaterSurface</name>
<desc>Foliage will be placed on water when set. Requires AllowOnWater.</desc>
</field>
<field>
<name>AlphaCutoff</name>
<desc>Minimum alpha value allowed on foliage instances.</desc>
</field>
<field>
<name>CullResolution</name>
<desc>Minimum size of culling bins.  Must be &gt;= 8 and &lt;= OuterRadius.</desc>
</field>
<field>
<name>DebugBoxHeight</name>
<desc>Height multiplier for drawn culling bins.</desc>
</field>
<field>
<name>FadeInRegion</name>
<desc>Region beyond ViewDistance where foliage fades in/out.</desc>
</field>
<field>
<name>FadeOutRegion</name>
<desc>Region before ViewClosest where foliage fades in/out.</desc>
</field>
<field>
<name>FixAspectRatio</name>
<desc>Maintain aspect ratio of image if true. This option ignores MaxWidth.</desc>
</field>
<field>
<name>FixSizeToMax</name>
<desc>Use only MaxWidth and MaxHeight for billboard size. Ignores MinWidth and MinHeight.</desc>
</field>
<field>
<name>FoliageCount</name>
<desc>Maximum foliage instance count.</desc>
</field>
<field>
<name>FoliageFile</name>
<desc>Image file for the foliage texture.</desc>
</field>
<field>
<name>FoliageRetries</name>
<desc>Number of times to try placing a foliage instance before giving up.</desc>
</field>
<field>
<name>GroundAlpha</name>
<desc>Alpha of the foliage at ground level. 0 = transparent, 1 = opaque.</desc>
</field>
<field>
<name>HideFoliage</name>
<desc>Foliage is hidden when set to true.</desc>
</field>
<field>
<name>InnerRadiusX</name>
<desc>Placement area inner radius on the X axis</desc>
</field>
<field>
<name>InnerRadiusY</name>
<desc>Placement area inner radius on the Y axis</desc>
</field>
<field>
<name>LightOn</name>
<desc>Foliage should be illuminated with changing lights when true.</desc>
</field>
<field>
<name>LightSync</name>
<desc>Foliage instances have the same lighting when set and LightOn is set.</desc>
</field>
<field>
<name>LightTime</name>
<desc>Time before foliage illumination cycle repeats.</desc>
</field>
<field>
<name>MaxHeight</name>
<desc>Maximum height of foliage billboards</desc>
</field>
<field>
<name>MaxLuminance</name>
<desc>Maximum luminance for foliage instances.</desc>
</field>
<field>
<name>MaxSwayTime</name>
<desc>Maximum sway cycle time in seconds.</desc>
</field>
<field>
<name>MaxWidth</name>
<desc>Maximum width of foliage billboards</desc>
</field>
<field>
<name>MinHeight</name>
<desc>Minimum height of foliage billboards</desc>
</field>
<field>
<name>MinLuminance</name>
<desc>Minimum luminance for foliage instances.</desc>
</field>
<field>
<name>MinSwayTime</name>
<desc>Minumum sway cycle time in seconds.</desc>
</field>
<field>
<name>MinWidth</name>
<desc>Minimum width of foliage billboards</desc>
</field>
<field>
<name>OffsetZ</name>
<desc>Offset billboards by this amount vertically.</desc>
</field>
<field>
<name>OuterRadiusX</name>
<desc>Placement area outer radius on the X axis</desc>
</field>
<field>
<name>OuterRadiusY</name>
<desc>Placement area outer radius on the Y axis</desc>
</field>
<field>
<name>PlacementAreaHeight</name>
<desc>Height of the placement ring in world units.</desc>
</field>
<field>
<name>PlacementColour</name>
<desc>Color of the placement ring.</desc>
</field>
<field>
<name>RandomFlip</name>
<desc>Randomly flip billboards left-to-right.</desc>
</field>
<field>
<name>seed</name>
<desc>Random seed for foliage placement.</desc>
</field>
<field>
<name>ShowPlacementArea</name>
<desc>Draw placement rings when set to true.</desc>
</field>
<field>
<name>SwayMagFront</name>
<desc>Front-to-back sway magnitude.</desc>
</field>
<field>
<name>SwayMagSide</name>
<desc>Left-to-right sway magnitude.</desc>
</field>
<field>
<name>SwayOn</name>
<desc>Foliage should sway randomly when true.</desc>
</field>
<field>
<name>SwaySync</name>
<desc>Foliage instances should sway together when true and SwayOn is enabled.</desc>
</field>
<field>
<name>UseCulling</name>
<desc>Use culling bins when enabled.</desc>
</field>
<field>
<name>UseDebugInfo</name>
<desc>Culling bins are drawn when set to true.</desc>
</field>
<field>
<name>useTrueBillboards</name>
<desc>Use camera facing billboards ( including the z axis ).</desc>
</field>
<field>
<name>ViewClosest</name>
<desc>Minimum distance from camera where foliage appears.</desc>
</field>
<field>
<name>ViewDistance</name>
<desc>Maximum distance from camera where foliage appears.</desc>
</field>
</class>
<class>
<name>fxFoliageSet</name>
<base>SimSet</base>
</class>
<class>
<name>fxReplicatorSet</name>
<base>SimSet</base>
</class>
<class>
<name>fxShapeReplicatedStatic</name>
<base>SceneObject</base>
<field>
<name>allowPlayerStep</name>
<desc>Allow a player to collide with this object.</desc>
</field>
<field>
<name>collisionType</name>
<desc>enumval collisionType</desc>
</field>
<field>
<name>customAmbientLighting</name>
<desc>ColorF customAmbientLighting</desc>
</field>
<field>
<name>lightGroupName</name>
<desc>Groups shape in a set with other objects affected by a designatedlight source.</desc>
</field>
<field>
<name>playAmbient</name>
<desc>Play the "ambient" animation.</desc>
</field>
<field>
<name>receiveLMLighting</name>
<desc>Shape lighting affected by nearby lightmaps</desc>
</field>
<field>
<name>receiveSunLight</name>
<desc>Shape lighting affected by global Sun</desc>
</field>
<field>
<name>renderNormals</name>
<desc>Debug rendering mode which highlights shape normals.</desc>
</field>
<field>
<name>shapeName</name>
<desc>Name and path to model file.</desc>
</field>
<field>
<name>useCustomAmbientLighting</name>
<desc>Ambient light color (in low/no lighting condition))which overrides other sources, such as Sun.</desc>
</field>
</class>
<class>
<name>fxShapeReplicator</name>
<base>SceneObject</base>
<field>
<name>AlignToTerrain</name>
<desc>Align shapes to surface normal when set.</desc>
</field>
<field>
<name>AllowedTerrainSlope</name>
<desc>Maximum surface angle allowed for shape instances.</desc>
</field>
<field>
<name>AllowOnInteriors</name>
<desc>Shapes will be placed on InteriorInstances when set.</desc>
</field>
<field>
<name>AllowOnStatics</name>
<desc>Shapes will be placed on Static shapes when set.</desc>
</field>
<field>
<name>AllowOnTerrain</name>
<desc>Shapes will be placed on terrain when set.</desc>
</field>
<field>
<name>AllowOnWater</name>
<desc>Shapes will be placed on/under water when set.</desc>
</field>
<field>
<name>AllowWaterSurface</name>
<desc>Shapes will be placed on water when set. Requires AllowOnWater.</desc>
</field>
<field>
<name>HideReplications</name>
<desc>Replicated shapes are hidden when set to true.</desc>
</field>
<field>
<name>InnerRadiusX</name>
<desc>Placement area inner radius on the X axis</desc>
</field>
<field>
<name>InnerRadiusY</name>
<desc>Placement area inner radius on the Y axis</desc>
</field>
<field>
<name>Interactions</name>
<desc>Allow physics interactions with shapes.</desc>
</field>
<field>
<name>OffsetZ</name>
<desc>Offset shapes by this amount vertically.</desc>
</field>
<field>
<name>OuterRadiusX</name>
<desc>Placement area outer radius on the X axis</desc>
</field>
<field>
<name>OuterRadiusY</name>
<desc>Placement area outer radius on the Y axis</desc>
</field>
<field>
<name>PlacementAreaHeight</name>
<desc>Height of the placement ring in world units.</desc>
</field>
<field>
<name>PlacementColour</name>
<desc>Color of the placement ring.</desc>
</field>
<field>
<name>seed</name>
<desc>Random seed for shape placement.</desc>
</field>
<field>
<name>ShapeCount</name>
<desc>Maximum shape instance count.</desc>
</field>
<field>
<name>shapeFile</name>
<desc>Filename of shape to replicate.</desc>
</field>
<field>
<name>ShapeRetries</name>
<desc>Number of times to try placing a shape instance before giving up.</desc>
</field>
<field>
<name>ShapeRotateMax</name>
<desc>Maximum shape rotation angles.</desc>
</field>
<field>
<name>ShapeRotateMin</name>
<desc>Minimum shape rotation angles.</desc>
</field>
<field>
<name>ShapeScaleMax</name>
<desc>Maximum shape scale.</desc>
</field>
<field>
<name>ShapeScaleMin</name>
<desc>Minimum shape scale.</desc>
</field>
<field>
<name>ShowPlacementArea</name>
<desc>Draw placement rings when set to true.</desc>
</field>
<field>
<name>TerrainAlignment</name>
<desc>Surface normals will be multiplied by these values when AlignToTerrain is enabled.</desc>
</field>
</class>
<class>
<name>GameBase</name>
<base>SceneObject</base>
<method>
<name>applyImpulse</name>
<args>Point3F Pos, VectorF vel</args>
</method>
<method>
<name>applyRadialImpulse</name>
<args>Point3F origin, F32 radius, F32 magnitude</args>
</method>
<method>
<name>getDataBlock</name>
<desc>Return the datablock this GameBase is using.</desc>
</method>
<method>
<name>setDataBlock</name>
<args>DataBlock db</args>
<desc>Assign this GameBase to use the specified datablock.</desc>
</method>
<field>
<name>dataBlock</name>
<desc>Script datablock used for game objects.</desc>
</field>
<field>
<name>nameTag</name>
<desc>Name of the precipitation box.</desc>
</field>
</class>
<class>
<name>GameBaseData</name>
<base>SimDataBlock</base>
<field>
<name>category</name>
<desc>caseString category</desc>
</field>
</class>
<class>
<name>GameConnection</name>
<base>NetConnection</base>
<method>
<name>activateGhosting</name>
</method>
<method>
<name>chaseCam</name>
<args>int size</args>
</method>
<method>
<name>clearCameraObject</name>
</method>
<method>
<name>delete</name>
<args>string reason=NULL</args>
<desc>Disconnect a client; reason is sent as part of the disconnect packet.</desc>
</method>
<method>
<name>getCameraObject</name>
</method>
<method>
<name>getControlCameraFov</name>
</method>
<method>
<name>getControlObject</name>
</method>
<method>
<name>getServerConnection</name>
<desc>Get the server connection if any.</desc>
</method>
<method>
<name>isAIControlled</name>
</method>
<method>
<name>isControlObjectRotDampedCamera</name>
</method>
<method>
<name>isDemoPlaying</name>
</method>
<method>
<name>isDemoRecording</name>
</method>
<method>
<name>isFirstPerson</name>
<desc>True if this connection is in first person mode.</desc>
</method>
<method>
<name>listClassIDs</name>
<desc>List all of the classes that this connection knows about, and what their IDs are. Useful for debugging network problems.</desc>
</method>
<method>
<name>play2D</name>
<args>SFXProfile ap</args>
</method>
<method>
<name>play3D</name>
<args>SFXProfile ap, Transform pos</args>
</method>
<method>
<name>playDemo</name>
<args>string demoFileName</args>
<desc>plays a previously recorded demo.</desc>
</method>
<method>
<name>resetGhosting</name>
</method>
<method>
<name>setBlackOut</name>
<args>bool doFade, int timeMS</args>
</method>
<method>
<name>setCameraObject</name>
</method>
<method>
<name>setConnectArgs</name>
</method>
<method>
<name>setControlCameraFov</name>
<args>int newFOV</args>
<desc>Set new FOV in degrees.</desc>
</method>
<method>
<name>setControlObject</name>
<args>ShapeBase object</args>
</method>
<method>
<name>setFirstPerson</name>
<args>bool firstPerson</args>
<desc>Sets this connection into or out of first person mode.</desc>
</method>
<method>
<name>setJoinPassword</name>
</method>
<method>
<name>setMissionCRC</name>
<args>int CRC</args>
</method>
<method>
<name>startRecording</name>
<args>string fileName</args>
<desc>records the network connection to a demo file.</desc>
</method>
<method>
<name>stopRecording</name>
<desc>stops the demo recording.</desc>
</method>
<method>
<name>transmitDataBlocks</name>
<args>int sequence</args>
</method>
</class>
<class>
<name>GameTSCtrl</name>
<base>GuiTSCtrl</base>
</class>
<class>
<name>GFXCardProfiler</name>
<method>
<name>getCard</name>
<desc>- Returns the card name (GeforceFX 5950 Ultra).</desc>
</method>
<method>
<name>getRenderer</name>
<desc>- Returns the renderer name (D3D9, for instance).</desc>
</method>
<method>
<name>getVendor</name>
<desc>- Returns the vendor name (nVidia, ATI).</desc>
</method>
<method>
<name>getVersion</name>
<desc>- Returns the driver version (59.72).</desc>
</method>
<method>
<name>setCapability</name>
<args>name, true/false</args>
<desc>- Set a specific card capability.</desc>
</method>
</class>
<class>
<name>GFXInit</name>
<method>
<name>createNullDevice</name>
<desc>Create a NULL device</desc>
</method>
<method>
<name>getAdapterCount</name>
<desc>Return the number of adapters available.</desc>
</method>
<method>
<name>getAdapterMode</name>
<args>int id, int modeId</args>
<desc>Gets information on the specified adapter and mode.

\param id Index of the adapter to get data from.
\param modeId Index of the mode to get data from.
\return (string) A video mode string given an adapter and mode index. See GuiCanvas.getVideoMode()</desc>
</method>
<method>
<name>getAdapterModeCount</name>
<args>int id</args>
<desc>Gets the number of modes available on the specified adapter.

\param id Index of the adapter to get data from.
\return (int) The number of video modes supported by the adapter, or -1 if the given adapter was not found.</desc>
</method>
<method>
<name>getAdapterName</name>
<args>int id</args>
<desc>Returns the name of a given adapter.</desc>
</method>
<method>
<name>getAdapterShaderModel</name>
<args>int id</args>
<desc>Returns the SM supported by a given adapter.</desc>
</method>
<method>
<name>getAdapterType</name>
<args>int id</args>
<desc>Returns the type (D3D9, D3D8, GL, Null) of a given adapter.</desc>
</method>
<method>
<name>getDefaultAdapterIndex</name>
<desc>Returns the index of the adapter we'll be starting up with.</desc>
</method>
</class>
<class>
<name>GFXSamplerStateData</name>
<base>SimObject</base>
<field>
<name>addressModeU</name>
<desc>enumval addressModeU</desc>
</field>
<field>
<name>addressModeV</name>
<desc>enumval addressModeV</desc>
</field>
<field>
<name>addressModeW</name>
<desc>enumval addressModeW</desc>
</field>
<field>
<name>alphaArg1</name>
<desc>modenumval alphaArg1</desc>
</field>
<field>
<name>alphaArg2</name>
<desc>modenumval alphaArg2</desc>
</field>
<field>
<name>alphaArg3</name>
<desc>modenumval alphaArg3</desc>
</field>
<field>
<name>alphaOp</name>
<desc>enumval alphaOp</desc>
</field>
<field>
<name>colorArg1</name>
<desc>modenumval colorArg1</desc>
</field>
<field>
<name>colorArg2</name>
<desc>modenumval colorArg2</desc>
</field>
<field>
<name>colorArg3</name>
<desc>modenumval colorArg3</desc>
</field>
<field>
<name>magFilter</name>
<desc>enumval magFilter</desc>
</field>
<field>
<name>maxAnisotropy</name>
<desc>int maxAnisotropy</desc>
</field>
<field>
<name>minFilter</name>
<desc>enumval minFilter</desc>
</field>
<field>
<name>mipFilter</name>
<desc>enumval mipFilter</desc>
</field>
<field>
<name>mipLODBias</name>
<desc>float mipLODBias</desc>
</field>
<field>
<name>resultArg</name>
<desc>enumval resultArg</desc>
</field>
<field>
<name>textureColorOp</name>
<desc>enumval textureColorOp</desc>
</field>
<field>
<name>textureTransform</name>
<desc>enumval textureTransform</desc>
</field>
</class>
<class>
<name>GFXStateBlockData</name>
<base>SimObject</base>
<field>
<name>alphaDefined</name>
<desc>bool alphaDefined</desc>
</field>
<field>
<name>alphaTestEnable</name>
<desc>bool alphaTestEnable</desc>
</field>
<field>
<name>alphaTestFunc</name>
<desc>enumval alphaTestFunc</desc>
</field>
<field>
<name>alphaTestRef</name>
<desc>int alphaTestRef</desc>
</field>
<field>
<name>blendDefined</name>
<desc>bool blendDefined</desc>
</field>
<field>
<name>blendDest</name>
<desc>enumval blendDest</desc>
</field>
<field>
<name>blendEnable</name>
<desc>bool blendEnable</desc>
</field>
<field>
<name>blendOp</name>
<desc>enumval blendOp</desc>
</field>
<field>
<name>blendSrc</name>
<desc>enumval blendSrc</desc>
</field>
<field>
<name>colorWriteAlpha</name>
<desc>bool colorWriteAlpha</desc>
</field>
<field>
<name>colorWriteBlue</name>
<desc>bool colorWriteBlue</desc>
</field>
<field>
<name>colorWriteDefined</name>
<desc>bool colorWriteDefined</desc>
</field>
<field>
<name>colorWriteGreen</name>
<desc>bool colorWriteGreen</desc>
</field>
<field>
<name>colorWriteRed</name>
<desc>bool colorWriteRed</desc>
</field>
<field>
<name>cullDefined</name>
<desc>bool cullDefined</desc>
</field>
<field>
<name>cullMode</name>
<desc>enumval cullMode</desc>
</field>
<field>
<name>ffLighting</name>
<desc>bool ffLighting</desc>
</field>
<field>
<name>samplersDefined</name>
<desc>bool samplersDefined</desc>
</field>
<field>
<name>samplerStates</name>
<desc>SimObjectPtr samplerStates</desc>
</field>
<field>
<name>separateAlphaBlendDefined</name>
<desc>bool separateAlphaBlendDefined</desc>
</field>
<field>
<name>separateAlphaBlendDest</name>
<desc>enumval separateAlphaBlendDest</desc>
</field>
<field>
<name>separateAlphaBlendEnable</name>
<desc>bool separateAlphaBlendEnable</desc>
</field>
<field>
<name>separateAlphaBlendOp</name>
<desc>enumval separateAlphaBlendOp</desc>
</field>
<field>
<name>separateAlphaBlendSrc</name>
<desc>enumval separateAlphaBlendSrc</desc>
</field>
<field>
<name>stencilDefined</name>
<desc>bool stencilDefined</desc>
</field>
<field>
<name>stencilEnable</name>
<desc>bool stencilEnable</desc>
</field>
<field>
<name>stencilFailOp</name>
<desc>enumval stencilFailOp</desc>
</field>
<field>
<name>stencilFunc</name>
<desc>enumval stencilFunc</desc>
</field>
<field>
<name>stencilMask</name>
<desc>int stencilMask</desc>
</field>
<field>
<name>stencilPassOp</name>
<desc>enumval stencilPassOp</desc>
</field>
<field>
<name>stencilRef</name>
<desc>int stencilRef</desc>
</field>
<field>
<name>stencilWriteMask</name>
<desc>int stencilWriteMask</desc>
</field>
<field>
<name>stencilZFailOp</name>
<desc>enumval stencilZFailOp</desc>
</field>
<field>
<name>textureFactor</name>
<desc>ColorI textureFactor</desc>
</field>
<field>
<name>vertexColorEnable</name>
<desc>bool vertexColorEnable</desc>
</field>
<field>
<name>zBias</name>
<desc>int zBias</desc>
</field>
<field>
<name>zDefined</name>
<desc>bool zDefined</desc>
</field>
<field>
<name>zEnable</name>
<desc>bool zEnable</desc>
</field>
<field>
<name>zFunc</name>
<desc>enumval zFunc</desc>
</field>
<field>
<name>zSlopeBias</name>
<desc>int zSlopeBias</desc>
</field>
<field>
<name>zWriteEnable</name>
<desc>bool zWriteEnable</desc>
</field>
</class>
<class>
<name>GhostAlwaysObjectEvent</name>
</class>
<class>
<name>GhostAlwaysSet</name>
<base>SimSet</base>
</class>
<class>
<name>Gizmo</name>
<base>SimObject</base>
</class>
<class>
<name>GizmoProfile</name>
<base>SimObject</base>
<field>
<name>alignment</name>
<desc>enumval alignment</desc>
</field>
<field>
<name>allowSnapRotations</name>
<desc>bool allowSnapRotations</desc>
</field>
<field>
<name>allowSnapScale</name>
<desc>bool allowSnapScale</desc>
</field>
<field>
<name>flags</name>
<desc>int flags</desc>
</field>
<field>
<name>gridColor</name>
<desc>ColorI gridColor</desc>
</field>
<field>
<name>gridSize</name>
<desc>Point3F gridSize</desc>
</field>
<field>
<name>mode</name>
<desc>enumval mode</desc>
</field>
<field>
<name>planeDim</name>
<desc>float planeDim</desc>
</field>
<field>
<name>renderPlane</name>
<desc>bool renderPlane</desc>
</field>
<field>
<name>renderPlaneHashes</name>
<desc>bool renderPlaneHashes</desc>
</field>
<field>
<name>rotateScalar</name>
<desc>float rotateScalar</desc>
</field>
<field>
<name>rotationSnap</name>
<desc>float rotationSnap</desc>
</field>
<field>
<name>scaleScalar</name>
<desc>float scaleScalar</desc>
</field>
<field>
<name>scaleSnap</name>
<desc>float scaleSnap</desc>
</field>
<field>
<name>screenLength</name>
<desc>int screenLength</desc>
</field>
<field>
<name>snapToGrid</name>
<desc>bool snapToGrid</desc>
</field>
</class>
<class>
<name>GlobalActionMap</name>
<base>ActionMap</base>
</class>
<class>
<name>GroundCover</name>
<base>SceneObject</base>
<method>
<name>getQualityScale</name>
<desc>Returns the global quality scale.  See GroundCover::setQualityScale()...</desc>
</method>
<method>
<name>setQualityScale</name>
<args> F32 scale </args>
<desc>Sets the global ground cover LOD scalar which controls the percentage of the maximum designed cover to put down. It scales both rendering cost and placement CPU performance. Returns the actual value set.</desc>
</method>
<field>
<name>billboardTexture</name>
<desc>filename billboardTexture</desc>
</field>
<field>
<name>billboardUVs</name>
<desc>RectF billboardUVs</desc>
</field>
<field>
<name>clumpExponent</name>
<desc>float clumpExponent</desc>
</field>
<field>
<name>clumpRadius</name>
<desc>float clumpRadius</desc>
</field>
<field>
<name>dissolveRadius</name>
<desc>float dissolveRadius</desc>
</field>
<field>
<name>gridSize</name>
<desc>int gridSize</desc>
</field>
<field>
<name>invertLayer</name>
<desc>bool invertLayer</desc>
</field>
<field>
<name>layer</name>
<desc>int layer</desc>
</field>
<field>
<name>lockFrustum</name>
<desc>bool lockFrustum</desc>
</field>
<field>
<name>maxBillboardTiltAngle</name>
<desc>float maxBillboardTiltAngle</desc>
</field>
<field>
<name>maxClumpCount</name>
<desc>int maxClumpCount</desc>
</field>
<field>
<name>maxElements</name>
<desc>int maxElements</desc>
</field>
<field>
<name>maxElevation</name>
<desc>float maxElevation</desc>
</field>
<field>
<name>maxSlope</name>
<desc>float maxSlope</desc>
</field>
<field>
<name>minClumpCount</name>
<desc>int minClumpCount</desc>
</field>
<field>
<name>minElevation</name>
<desc>float minElevation</desc>
</field>
<field>
<name>noBillboards</name>
<desc>bool noBillboards</desc>
</field>
<field>
<name>noShapes</name>
<desc>bool noShapes</desc>
</field>
<field>
<name>probability</name>
<desc>float probability</desc>
</field>
<field>
<name>radius</name>
<desc>float radius</desc>
</field>
<field>
<name>reflectScale</name>
<desc>float reflectScale</desc>
</field>
<field>
<name>renderCells</name>
<desc>bool renderCells</desc>
</field>
<field>
<name>seed</name>
<desc>int seed</desc>
</field>
<field>
<name>shapeCullRadius</name>
<desc>float shapeCullRadius</desc>
</field>
<field>
<name>shapeFilename</name>
<desc>filename shapeFilename</desc>
</field>
<field>
<name>sizeExponent</name>
<desc>float sizeExponent</desc>
</field>
<field>
<name>sizeMax</name>
<desc>float sizeMax</desc>
</field>
<field>
<name>sizeMin</name>
<desc>float sizeMin</desc>
</field>
<field>
<name>windDirection</name>
<desc>Point2F windDirection</desc>
</field>
<field>
<name>windGustFrequency</name>
<desc>float windGustFrequency</desc>
</field>
<field>
<name>windGustLength</name>
<desc>float windGustLength</desc>
</field>
<field>
<name>windGustStrength</name>
<desc>float windGustStrength</desc>
</field>
<field>
<name>windScale</name>
<desc>float windScale</desc>
</field>
<field>
<name>windTurbulenceFrequency</name>
<desc>float windTurbulenceFrequency</desc>
</field>
<field>
<name>windTurbulenceStrength</name>
<desc>float windTurbulenceStrength</desc>
</field>
<field>
<name>zOffset</name>
<desc>float zOffset</desc>
</field>
</class>
<class>
<name>GroundPlane</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
</method>
<field>
<name>Material</name>
<desc>MaterialName Material</desc>
</field>
<field>
<name>scaleU</name>
<desc>float scaleU</desc>
</field>
<field>
<name>scaleV</name>
<desc>float scaleV</desc>
</field>
<field>
<name>squareSize</name>
<desc>float squareSize</desc>
</field>
</class>
<class>
<name>GuiArrayCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiAutoScrollCtrl</name>
<base>GuiTickCtrl</base>
<field>
<name>childBorder</name>
<desc>int childBorder</desc>
</field>
<field>
<name>resetDelay</name>
<desc>float resetDelay</desc>
</field>
<field>
<name>scrollSpeed</name>
<desc>float scrollSpeed</desc>
</field>
<field>
<name>startDelay</name>
<desc>float startDelay</desc>
</field>
<field>
<name>tickCallback</name>
<desc>bool tickCallback</desc>
</field>
</class>
<class>
<name>GuiAviBitmapCtrl</name>
<base>GuiControl</base>
<field>
<name>done</name>
<desc>bool done</desc>
</field>
</class>
<class>
<name>GuiBackgroundCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiBitmapBorderCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiBitmapButtonCtrl</name>
<base>GuiButtonCtrl</base>
<method>
<name>setBitmap</name>
<args>filepath name</args>
</method>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
</class>
<class>
<name>GuiBitmapButtonTextCtrl</name>
<base>GuiBitmapButtonCtrl</base>
</class>
<class>
<name>GuiBitmapCtrl</name>
<base>GuiControl</base>
<method>
<name>setBgColor</name>
<desc>int r,g,b,a</desc>
</method>
<method>
<name>setBitmap</name>
<args>string filename, bool resize=false</args>
<desc>Set the bitmap displayed in the control. Note that it is limited in size, to 256x256.</desc>
</method>
<method>
<name>setValue</name>
<args>int xAxis, int yAxis</args>
<desc>Set the offset of the bitmap.</desc>
</method>
<field>
<name>bgColor</name>
<desc>ColorI bgColor</desc>
</field>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
<field>
<name>wrap</name>
<desc>bool wrap</desc>
</field>
</class>
<class>
<name>GuiBorderButtonCtrl</name>
<base>GuiButtonBaseCtrl</base>
</class>
<class>
<name>GuiBubbleTextCtrl</name>
<base>GuiTextCtrl</base>
</class>
<class>
<name>GuiButtonBaseCtrl</name>
<base>GuiControl</base>
<method>
<name>getStateOn</name>
</method>
<method>
<name>getText</name>
<desc>- returns the text of the button.</desc>
</method>
<method>
<name>performClick</name>
<desc>- simulates a button click from script.</desc>
</method>
<method>
<name>resetState</name>
<desc>- resets the state of the button.</desc>
</method>
<method>
<name>setStateOn</name>
<args>bool isStateOn</args>
<desc>- sets the state on member and updates siblings of the same group.</desc>
</method>
<method>
<name>setText</name>
<args>string text</args>
<desc>- sets the text of the button to the string.</desc>
</method>
<method>
<name>setTextID</name>
<args>string id</args>
<desc>- sets the text of the button to the localized string.</desc>
</method>
<field>
<name>buttonType</name>
<desc>enumval buttonType</desc>
</field>
<field>
<name>groupNum</name>
<desc>int groupNum</desc>
</field>
<field>
<name>text</name>
<desc>caseString text</desc>
</field>
<field>
<name>textID</name>
<desc>string textID</desc>
</field>
<field>
<name>useMouseEvents</name>
<desc>bool useMouseEvents</desc>
</field>
</class>
<class>
<name>GuiButtonCtrl</name>
<base>GuiButtonBaseCtrl</base>
</class>
<class>
<name>GuiCanvas</name>
<base>GuiControl</base>
<method>
<name>cursorOff</name>
</method>
<method>
<name>cursorOn</name>
</method>
<method>
<name>getContent</name>
<desc>Get the GuiControl which is being used as the content.</desc>
</method>
<method>
<name>getCursorPos</name>
<desc>Get the current position of the cursor.</desc>
</method>
<method>
<name>getExtent</name>
<desc>Returns the dimensions of the canvas.</desc>
</method>
<method>
<name>getMode</name>
<args>int modeId</args>
<desc>Gets information on the specified mode of this device.

\param modeId Index of the mode to get data from.
\return (string) A video mode string given an adapter and mode index. See GuiCanvas.getVideoMode()</desc>
</method>
<method>
<name>getModeCount</name>
<desc>Gets the number of modes available on this device.

\return (int) The number of video modes supported by the device.</desc>
</method>
<method>
<name>getMouseControl</name>
<desc>Gets the gui control under the mouse.</desc>
</method>
<method>
<name>getVideoMode</name>
<desc>Gets the current screen mode as a string.

\return (string) The current screen mode as "(int)width (int)height (bool)fullscreen (int)bitdepth (int)refreshRate"</desc>
</method>
<method>
<name>hideCursor</name>
</method>
<method>
<name>isCursorOn</name>
</method>
<method>
<name>isCursorShown</name>
</method>
<method>
<name>isFullscreen</name>
<desc>- Is this canvas currently fullscreen?</desc>
</method>
<method>
<name>isMaximized</name>
</method>
<method>
<name>isMinimized</name>
</method>
<method>
<name>maximizeWindow</name>
<desc>- maximize this canvas' window.</desc>
</method>
<method>
<name>minimizeWindow</name>
<desc>- minimize this canvas' window.</desc>
</method>
<method>
<name>popDialog</name>
<args>GuiControl ctrl=NULL</args>
</method>
<method>
<name>popLayer</name>
<args>int layer</args>
</method>
<method>
<name>pushDialog</name>
<args>GuiControl ctrl, int layer</args>
</method>
<method>
<name>renderFront</name>
<args>bool enable</args>
</method>
<method>
<name>repaint</name>
<desc>Force canvas to redraw.</desc>
</method>
<method>
<name>reset</name>
<desc>Reset the update regions for the canvas.</desc>
</method>
<method>
<name>restoreWindow</name>
<desc>- restore this canvas' window.</desc>
</method>
<method>
<name>setContent</name>
<args>GuiControl ctrl</args>
<desc>Set the content of the canvas.</desc>
</method>
<method>
<name>setCursor</name>
<args>cursorName</args>
</method>
<method>
<name>setCursorPos</name>
<args>Point2I pos</args>
</method>
<method>
<name>setVideoMode</name>
<args>int width, int height, bool fullscreen, [int bitDepth], [int refreshRate]</args>
<desc>Change the video mode of this canvas. This method has the side effect of setting the $pref::Video::mode to the new values.

\param width The screen width to set.
\param height The screen height to set.
\param fullscreen Specify true to run fullscreen or false to run in a window
\param bitDepth [optional] The desired bit-depth. Defaults to the current setting. This parameter is ignored if you are running in a window.
\param refreshRate [optional] The desired refresh rate. Defaults to the current setting. This parameter is ignored if you are running in a window\param antialiasLevel [optional] The level of anti-aliasing to apply 0 = none</desc>
</method>
<method>
<name>setWindowTitle</name>
<args>string newTitle</args>
</method>
<method>
<name>showCursor</name>
</method>
<method>
<name>toggleFullscreen</name>
<desc>- toggle canvas from fullscreen to windowed mode or back.</desc>
</method>
<field>
<name>numFences</name>
<desc>The number of GFX fences to use.</desc>
</field>
</class>
<class>
<name>GuiCheckBoxCtrl</name>
<base>GuiButtonBaseCtrl</base>
<method>
<name>setStateOn</name>
<args>state</args>
</method>
<field>
<name>useInactiveState</name>
<desc>bool useInactiveState</desc>
</field>
</class>
<class>
<name>GuiChunkedBitmapCtrl</name>
<base>GuiControl</base>
<method>
<name>setBitmap</name>
<args>string filename</args>
<desc>Set the bitmap contained in this control.</desc>
</method>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
<field>
<name>tile</name>
<desc>bool tile</desc>
</field>
<field>
<name>useVariable</name>
<desc>bool useVariable</desc>
</field>
</class>
<class>
<name>GuiClockHud</name>
<base>GuiControl</base>
<method>
<name>getTime</name>
<desc>Returns current time in secs.</desc>
</method>
<method>
<name>setTime</name>
<args>time in sec</args>
<desc>Sets the current base time for the clock</desc>
</method>
<field>
<name>fillColor</name>
<desc>ColorF fillColor</desc>
</field>
<field>
<name>frameColor</name>
<desc>ColorF frameColor</desc>
</field>
<field>
<name>showFill</name>
<desc>bool showFill</desc>
</field>
<field>
<name>showFrame</name>
<desc>bool showFrame</desc>
</field>
<field>
<name>textColor</name>
<desc>ColorF textColor</desc>
</field>
</class>
<class>
<name>GuiColorPickerCtrl</name>
<base>GuiControl</base>
<method>
<name>getSelectorPos</name>
<desc>Gets the current position of the selector</desc>
</method>
<method>
<name>setSelectorPos</name>
<desc>Sets the current position of the selector</desc>
</method>
<method>
<name>updateColor</name>
<desc>Forces update of pick color</desc>
</method>
<field>
<name>ActionOnMove</name>
<desc>bool ActionOnMove</desc>
</field>
<field>
<name>BaseColor</name>
<desc>ColorF BaseColor</desc>
</field>
<field>
<name>DisplayMode</name>
<desc>enumval DisplayMode</desc>
</field>
<field>
<name>PickColor</name>
<desc>ColorF PickColor</desc>
</field>
<field>
<name>SelectorGap</name>
<desc>int SelectorGap</desc>
</field>
<field>
<name>ShowReticle</name>
<desc>bool ShowReticle</desc>
</field>
</class>
<class>
<name>GuiConsole</name>
<base>GuiArrayCtrl</base>
</class>
<class>
<name>GuiConsoleEditCtrl</name>
<base>GuiTextEditCtrl</base>
<field>
<name>useSiblingScroller</name>
<desc>bool useSiblingScroller</desc>
</field>
</class>
<class>
<name>GuiConsoleTextCtrl</name>
<base>GuiControl</base>
<field>
<name>expression</name>
<desc>String expression</desc>
</field>
</class>
<class>
<name>GuiContainer</name>
<base>GuiControl</base>
<field>
<name>AnchorBottom</name>
<desc>bool AnchorBottom</desc>
</field>
<field>
<name>AnchorLeft</name>
<desc>bool AnchorLeft</desc>
</field>
<field>
<name>AnchorRight</name>
<desc>bool AnchorRight</desc>
</field>
<field>
<name>AnchorTop</name>
<desc>bool AnchorTop</desc>
</field>
<field>
<name>Docking</name>
<desc>enumval Docking</desc>
</field>
<field>
<name>Margin</name>
<desc>RectSpacingI Margin</desc>
</field>
<field>
<name>Padding</name>
<desc>RectSpacingI Padding</desc>
</field>
</class>
<class>
<name>GuiControl</name>
<base>SimGroup</base>
<method>
<name>addGuiControl</name>
<desc>S32 controlId</desc>
</method>
<method>
<name>clearFirstResponder</name>
<desc>Clear this control from being the first responder</desc>
</method>
<method>
<name>controlIsChild</name>
<desc>returns true if the given control is a child of this control</desc>
</method>
<method>
<name>findHitControl</name>
<desc>returns the Id of the control at the point</desc>
</method>
<method>
<name>findHitControls</name>
<args> x, y, width, height </args>
<desc>- Return the IDs of all controls that intersect with the given global bounds.</desc>
</method>
<method>
<name>getAspect</name>
<desc>Returns the width divided by the height of the control.</desc>
</method>
<method>
<name>getCenter</name>
<desc>returns center of control, as space seperated ints</desc>
</method>
<method>
<name>getExtent</name>
<desc>Get the width and height of the control.</desc>
</method>
<method>
<name>getFirstResponder</name>
<desc>Get the first responder this control is aware of</desc>
</method>
<method>
<name>getGlobalCenter</name>
<desc>returns center of control, as space seperated ints</desc>
</method>
<method>
<name>getGlobalPosition</name>
</method>
<method>
<name>getMinExtent</name>
<desc>Get the minimum allowed size of the control.</desc>
</method>
<method>
<name>getParent</name>
<desc>returns the Id of the parent control</desc>
</method>
<method>
<name>getPosition</name>
</method>
<method>
<name>getRoot</name>
<desc>returns the Id of the parent canvas.</desc>
</method>
<method>
<name>getScriptFile</name>
<desc>Gets the script file the control was created in</desc>
</method>
<method>
<name>getValue</name>
</method>
<method>
<name>isActive</name>
</method>
<method>
<name>isAwake</name>
</method>
<method>
<name>isFirstResponder</name>
<desc>returns true if this control is the first responder</desc>
</method>
<method>
<name>isVisible</name>
</method>
<method>
<name>makeFirstResponder</name>
<args>bool isFirst</args>
</method>
<method>
<name>pointInControl</name>
<desc>returns true if the point is in the control, point is in parent coords</desc>
</method>
<method>
<name>removeChildren</name>
</method>
<method>
<name>reorderChild</name>
<args>child1, child2</args>
<desc>uses simset reorder to push child 1 after child 2 - both must already be child controls of this control</desc>
</method>
<method>
<name>resize</name>
<args>int x, int y, int w, int h</args>
</method>
<method>
<name>setActive</name>
<args>bool active</args>
</method>
<method>
<name>setCanSave</name>
<desc>Sets whether this control can serialize itself to the hard disk</desc>
</method>
<method>
<name>setCenter</name>
<desc>sets control position, by center - coords are local not global</desc>
</method>
<method>
<name>setExtent</name>
<args>"x y"</args>
<desc>or (x,y) Sets the width &amp; height of the control.</desc>
</method>
<method>
<name>setFirstResponder</name>
<desc>Sets this control as the first responder</desc>
</method>
<method>
<name>setPosition</name>
<desc>int x,y in local space</desc>
</method>
<method>
<name>setPositionGlobal</name>
<desc>int x,y in global screen space</desc>
</method>
<method>
<name>setProfile</name>
<args>GuiControlProfile p</args>
</method>
<method>
<name>setScriptFile</name>
<desc>Associates the control with a script file.</desc>
</method>
<method>
<name>setValue</name>
<args>string value</args>
</method>
<method>
<name>setVisible</name>
<args>bool visible</args>
</method>
<field>
<name>Accelerator</name>
<desc>string Accelerator</desc>
</field>
<field>
<name>AltCommand</name>
<desc>string AltCommand</desc>
</field>
<field>
<name>canSave</name>
<desc>bool canSave</desc>
</field>
<field>
<name>Command</name>
<desc>string Command</desc>
</field>
<field>
<name>Extent</name>
<desc>Point2I Extent</desc>
</field>
<field>
<name>HorizSizing</name>
<desc>enumval HorizSizing</desc>
</field>
<field>
<name>hovertime</name>
<desc>int hovertime</desc>
</field>
<field>
<name>isContainer</name>
<desc>bool isContainer</desc>
</field>
<field>
<name>langTableMod</name>
<desc>string langTableMod</desc>
</field>
<field>
<name>MinExtent</name>
<desc>Point2I MinExtent</desc>
</field>
<field>
<name>Modal</name>
<desc>@deprecated This member is deprecated, which means that its value is always undefined.</desc>
</field>
<field>
<name>passMouseEventsTo</name>
<desc>string passMouseEventsTo</desc>
</field>
<field>
<name>position</name>
<desc>Point2I position</desc>
</field>
<field>
<name>Profile</name>
<desc>GuiProfile Profile</desc>
</field>
<field>
<name>setFirstResponder</name>
<desc>@deprecated This member is deprecated, which means that its value is always undefined.</desc>
</field>
<field>
<name>ToolTip</name>
<desc>caseString ToolTip</desc>
</field>
<field>
<name>tooltipprofile</name>
<desc>GuiProfile tooltipprofile</desc>
</field>
<field>
<name>Variable</name>
<desc>string Variable</desc>
</field>
<field>
<name>VertSizing</name>
<desc>enumval VertSizing</desc>
</field>
<field>
<name>Visible</name>
<desc>bool Visible</desc>
</field>
</class>
<class>
<name>GuiControlArrayControl</name>
<base>GuiControl</base>
<field>
<name>colCount</name>
<desc>int colCount</desc>
</field>
<field>
<name>colSizes</name>
<desc>intList colSizes</desc>
</field>
<field>
<name>colSpacing</name>
<desc>int colSpacing</desc>
</field>
<field>
<name>RowSize</name>
<desc>int RowSize</desc>
</field>
<field>
<name>rowSpacing</name>
<desc>int rowSpacing</desc>
</field>
</class>
<class>
<name>GuiControlListPopUp</name>
<base>GuiPopUpMenuCtrl</base>
</class>
<class>
<name>GuiControlProfile</name>
<base>SimObject</base>
<method>
<name>getStringWidth</name>
<args> pString </args>
</method>
<field>
<name>autoSizeHeight</name>
<desc>bool autoSizeHeight</desc>
</field>
<field>
<name>autoSizeWidth</name>
<desc>bool autoSizeWidth</desc>
</field>
<field>
<name>bevelColorHL</name>
<desc>ColorI bevelColorHL</desc>
</field>
<field>
<name>bevelColorLL</name>
<desc>ColorI bevelColorLL</desc>
</field>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
<field>
<name>border</name>
<desc>int border</desc>
</field>
<field>
<name>borderColor</name>
<desc>ColorI borderColor</desc>
</field>
<field>
<name>borderColorHL</name>
<desc>ColorI borderColorHL</desc>
</field>
<field>
<name>borderColorNA</name>
<desc>ColorI borderColorNA</desc>
</field>
<field>
<name>borderThickness</name>
<desc>int borderThickness</desc>
</field>
<field>
<name>canKeyFocus</name>
<desc>bool canKeyFocus</desc>
</field>
<field>
<name>cursorColor</name>
<desc>ColorI cursorColor</desc>
</field>
<field>
<name>fillColor</name>
<desc>ColorI fillColor</desc>
</field>
<field>
<name>fillColorHL</name>
<desc>ColorI fillColorHL</desc>
</field>
<field>
<name>fillColorNA</name>
<desc>ColorI fillColorNA</desc>
</field>
<field>
<name>fillColorSEL</name>
<desc>ColorI fillColorSEL</desc>
</field>
<field>
<name>fontCharset</name>
<desc>enumval fontCharset</desc>
</field>
<field>
<name>fontColor</name>
<desc>ColorI fontColor</desc>
</field>
<field>
<name>fontColorHL</name>
<desc>ColorI fontColorHL</desc>
</field>
<field>
<name>fontColorLink</name>
<desc>ColorI fontColorLink</desc>
</field>
<field>
<name>fontColorLinkHL</name>
<desc>ColorI fontColorLinkHL</desc>
</field>
<field>
<name>fontColorNA</name>
<desc>ColorI fontColorNA</desc>
</field>
<field>
<name>fontColors</name>
<desc>ColorI fontColors</desc>
</field>
<field>
<name>fontColorSEL</name>
<desc>ColorI fontColorSEL</desc>
</field>
<field>
<name>fontSize</name>
<desc>int fontSize</desc>
</field>
<field>
<name>fontType</name>
<desc>string fontType</desc>
</field>
<field>
<name>hasBitmapArray</name>
<desc>bool hasBitmapArray</desc>
</field>
<field>
<name>justify</name>
<desc>enumval justify</desc>
</field>
<field>
<name>Modal</name>
<desc>bool Modal</desc>
</field>
<field>
<name>mouseOverSelected</name>
<desc>bool mouseOverSelected</desc>
</field>
<field>
<name>numbersOnly</name>
<desc>bool numbersOnly</desc>
</field>
<field>
<name>opaque</name>
<desc>bool opaque</desc>
</field>
<field>
<name>profileForChildren</name>
<desc>string profileForChildren</desc>
</field>
<field>
<name>returnTab</name>
<desc>bool returnTab</desc>
</field>
<field>
<name>soundButtonDown</name>
<desc>SFXProfile soundButtonDown</desc>
</field>
<field>
<name>soundButtonOver</name>
<desc>SFXProfile soundButtonOver</desc>
</field>
<field>
<name>tab</name>
<desc>bool tab</desc>
</field>
<field>
<name>textOffset</name>
<desc>Point2I textOffset</desc>
</field>
<field>
<name>yPositionOffset</name>
<desc>int yPositionOffset</desc>
</field>
</class>
<class>
<name>GuiCrossHairHud</name>
<base>GuiBitmapCtrl</base>
<field>
<name>damageFillColor</name>
<desc>ColorF damageFillColor</desc>
</field>
<field>
<name>damageFrameColor</name>
<desc>ColorF damageFrameColor</desc>
</field>
<field>
<name>damageOffset</name>
<desc>Point2I damageOffset</desc>
</field>
<field>
<name>damageRect</name>
<desc>Point2I damageRect</desc>
</field>
</class>
<class>
<name>GuiCursor</name>
<base>SimObject</base>
<field>
<name>bitmapName</name>
<desc>filename bitmapName</desc>
</field>
<field>
<name>hotSpot</name>
<desc>Point2I hotSpot</desc>
</field>
<field>
<name>renderOffset</name>
<desc>Point2F renderOffset</desc>
</field>
</class>
<class>
<name>GuiDataGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>GuiDecalEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteDecalDatablock</name>
<desc>deleteSelectedDecalDatablock( String datablock )</desc>
</method>
<method>
<name>deleteSelectedDecal</name>
</method>
<method>
<name>editDecalDetails</name>
<args> S32 </args>
<desc>()</desc>
</method>
<method>
<name>getDecalCount</name>
</method>
<method>
<name>getDecalLookupName</name>
<args> S32 </args>
<desc>()</desc>
</method>
<method>
<name>getDecalTransform</name>
</method>
<method>
<name>getMode</name>
</method>
<method>
<name>selectDecal</name>
<args> S32 </args>
<desc>()</desc>
</method>
<method>
<name>setMode</name>
<args> String mode </args>
<desc>()</desc>
</method>
<field>
<name>currentDecalData</name>
<desc>SimObjectPtr currentDecalData</desc>
</field>
</class>
<class>
<name>GuiDecoyCtrl</name>
<base>GuiControl</base>
<field>
<name>isDecoy</name>
<desc>bool isDecoy</desc>
</field>
</class>
<class>
<name>GuiDirectoryFileListCtrl</name>
<base>GuiListBoxCtrl</base>
<method>
<name>getSelectedFile</name>
<desc>- returns the currently selected file name</desc>
</method>
<method>
<name>getSelectedFiles</name>
<desc>- returns a word separated list of selected file(s)</desc>
</method>
<method>
<name>reload</name>
<desc>- Update the file list.</desc>
</method>
<method>
<name>setFilter</name>
<args>[mask space delimited]</args>
</method>
<method>
<name>setPath</name>
<args>path,filter</args>
<desc>- directory to enumerate files from (without trailing slash)</desc>
</method>
<field>
<name>fileFilter</name>
<desc>Tab-delimited list of file name patterns. Only matched files will be displayed.</desc>
</field>
<field>
<name>filePath</name>
<desc>Path in game directory from which to list files.</desc>
</field>
</class>
<class>
<name>GuiDragAndDropControl</name>
<base>GuiControl</base>
<method>
<name>startDragging</name>
<args>%offset</args>
</method>
<field>
<name>deleteOnMouseUp</name>
<desc>bool deleteOnMouseUp</desc>
</field>
</class>
<class>
<name>GuiDynamicCtrlArrayControl</name>
<base>GuiControl</base>
<method>
<name>refresh</name>
<desc>Forces the child controls to recalculate</desc>
</method>
<field>
<name>autoCellSize</name>
<desc>When true cell size is set to the widest/tallest child control.</desc>
</field>
<field>
<name>colCount</name>
<desc>int colCount</desc>
</field>
<field>
<name>colSize</name>
<desc>int colSize</desc>
</field>
<field>
<name>colSpacing</name>
<desc>int colSpacing</desc>
</field>
<field>
<name>DynamicSize</name>
<desc>Calculate one component of the extent based on number of children or use user defined extent only</desc>
</field>
<field>
<name>fillRowFirst</name>
<desc>Fill rows or columns first</desc>
</field>
<field>
<name>frozen</name>
<desc>When true array will not updateChildrenControls when new children are added or in response to children resize events.</desc>
</field>
<field>
<name>Padding</name>
<desc>RectSpacingI Padding</desc>
</field>
<field>
<name>rowCount</name>
<desc>int rowCount</desc>
</field>
<field>
<name>RowSize</name>
<desc>int RowSize</desc>
</field>
<field>
<name>rowSpacing</name>
<desc>int rowSpacing</desc>
</field>
</class>
<class>
<name>GuiEditCtrl</name>
<base>GuiControl</base>
<method>
<name>addNewCtrl</name>
<args>GuiControl ctrl</args>
</method>
<method>
<name>addSelection</name>
<desc>selects a control.</desc>
</method>
<method>
<name>bringToFront</name>
</method>
<method>
<name>clearGuides</name>
<args> [ int axis ] </args>
<desc>- Clear all currently set guide lines.</desc>
</method>
<method>
<name>clearSelection</name>
<desc>Clear selected controls list.</desc>
</method>
<method>
<name>deleteSelection</name>
<desc>Delete the selected text.</desc>
</method>
<method>
<name>getContentControl</name>
<desc>- Return the toplevel control edited inside the GUI editor.</desc>
</method>
<method>
<name>getCurrentAddSet</name>
<desc>Returns the set to which new controls will be added</desc>
</method>
<method>
<name>getSelected</name>
<desc>- Gets the GUI control(s) the editor is currently selecting</desc>
</method>
<method>
<name>getSelectionGlobalBounds</name>
<desc>- Returns global bounds of current selection as vector 'x y width height'.</desc>
</method>
<method>
<name>getTrash</name>
<desc>- Gets the GUI controls(s) that are currently in the trash.</desc>
</method>
<method>
<name>getUndoManager</name>
<desc>- Gets the Gui Editor's UndoManager object</desc>
</method>
<method>
<name>justify</name>
<args>int mode</args>
</method>
<method>
<name>loadSelection</name>
<args>string fileName</args>
</method>
<method>
<name>moveSelection</name>
<args>int deltax, int deltay</args>
</method>
<method>
<name>pushToBack</name>
</method>
<method>
<name>readGuides</name>
<args> GuiControl ctrl [, int axis ] </args>
<desc>- Read the guides from the given control.</desc>
</method>
<method>
<name>removeSelection</name>
<desc>deselects a control.</desc>
</method>
<method>
<name>saveSelection</name>
<args>string fileName</args>
</method>
<method>
<name>select</name>
<args>GuiControl ctrl</args>
</method>
<method>
<name>selectAll</name>
</method>
<method>
<name>setContentControl</name>
<args> GuiControl ctrl </args>
<desc>- Set the toplevel control to edit in the GUI editor.</desc>
</method>
<method>
<name>setCurrentAddSet</name>
<args>GuiControl ctrl</args>
</method>
<method>
<name>setSnapToGrid</name>
<args>gridsize</args>
</method>
<method>
<name>toggle</name>
<desc>Toggle activation.</desc>
</method>
<method>
<name>writeGuides</name>
<args> GuiControl ctrl [, int axis ] </args>
<desc>- Write the guides to the given control.</desc>
</method>
<field>
<name>drawBorderLines</name>
<desc>If true, lines will be drawn extending along the edges of selected objects.</desc>
</field>
<field>
<name>drawGuides</name>
<desc>If true, guides will be included in rendering.</desc>
</field>
<field>
<name>fullBoxSelection</name>
<desc>If true, rectangle selection will only select controls fully inside the drag rectangle. (default)</desc>
</field>
<field>
<name>snapSensitivity</name>
<desc>Distance in pixels that edge and center snapping will work across.</desc>
</field>
<field>
<name>snapToCenters</name>
<desc>If true, selection centers will snap into alignment when moved or resized.</desc>
</field>
<field>
<name>snapToControls</name>
<desc>If true, edge and center snapping will work against controls.</desc>
</field>
<field>
<name>snapToEdges</name>
<desc>If true, selection edges will snap into alignment when moved or resized.</desc>
</field>
<field>
<name>snapToGuides</name>
<desc>If true, edge and center snapping will work against guides.</desc>
</field>
</class>
<class>
<name>GuiEditorRuler</name>
<base>GuiControl</base>
<field>
<name>editCtrl</name>
<desc>String editCtrl</desc>
</field>
<field>
<name>refCtrl</name>
<desc>String refCtrl</desc>
</field>
</class>
<class>
<name>GuiFadeinBitmapCtrl</name>
<base>GuiBitmapCtrl</base>
<field>
<name>done</name>
<desc>bool done</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>int fadeInTime</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>int fadeOutTime</desc>
</field>
<field>
<name>waitTime</name>
<desc>int waitTime</desc>
</field>
</class>
<class>
<name>GuiFileTreeCtrl</name>
<base>GuiTreeViewCtrl</base>
<method>
<name>getSelectedPath</name>
<desc>- returns the currently selected path in the tree</desc>
</method>
<method>
<name>reload</name>
<desc>- Reread the directory tree hierarchy.</desc>
</method>
<method>
<name>setSelectedPath</name>
<args>path</args>
<desc>- expands the tree to the specified path</desc>
</method>
<field>
<name>fileFilter</name>
<desc>Vector of file patterns.  If not empty, only files matching the pattern will be shown in the control.</desc>
</field>
<field>
<name>rootPath</name>
<desc>Path in game directory that should be displayed in the control.</desc>
</field>
</class>
<class>
<name>GuiFilterCtrl</name>
<base>GuiControl</base>
<method>
<name>getValue</name>
<desc>Return a tuple containing all the values in the filter.</desc>
</method>
<method>
<name>identity</name>
<desc>Reset the filtering.</desc>
</method>
<method>
<name>setValue</name>
<args>f1, f2, ...</args>
<desc>Reset the filter to use the specified points, spread equidistantly across the domain.</desc>
</method>
<field>
<name>controlPoints</name>
<desc>int controlPoints</desc>
</field>
<field>
<name>filter</name>
<desc>floatList filter</desc>
</field>
<field>
<name>identity</name>
<desc>Point2F identity</desc>
</field>
<field>
<name>showIdentity</name>
<desc>bool showIdentity</desc>
</field>
</class>
<class>
<name>GuiFormCtrl</name>
<base>GuiPanel</base>
<method>
<name>getMenuID</name>
<desc>Returns the ID of the Form Menu</desc>
</method>
<method>
<name>setCaption</name>
<args>caption</args>
<desc>- Sets the title of the Form</desc>
</method>
<field>
<name>Caption</name>
<desc>caseString Caption</desc>
</field>
<field>
<name>Content</name>
<desc>string Content</desc>
</field>
<field>
<name>ContentLibrary</name>
<desc>string ContentLibrary</desc>
</field>
<field>
<name>HasMenu</name>
<desc>bool HasMenu</desc>
</field>
<field>
<name>Movable</name>
<desc>bool Movable</desc>
</field>
</class>
<class>
<name>GuiFrameSetCtrl</name>
<base>GuiContainer</base>
<method>
<name>addColumn</name>
</method>
<method>
<name>addRow</name>
</method>
<method>
<name>frameBorder</name>
<args>int index, bool enable=true</args>
</method>
<method>
<name>frameMinExtent</name>
<args>int index, int w, int h</args>
</method>
<method>
<name>frameMovable</name>
<args>int index, bool enable=true</args>
</method>
<method>
<name>framePadding</name>
<args>int index, int t, int b, int l, int r</args>
</method>
<method>
<name>getColumnCount</name>
</method>
<method>
<name>getColumnOffset</name>
<args>int index</args>
</method>
<method>
<name>getRowCount</name>
</method>
<method>
<name>getRowOffset</name>
<args>int index</args>
</method>
<method>
<name>removeColumn</name>
</method>
<method>
<name>removeRow</name>
</method>
<method>
<name>setColumnOffset</name>
<args>int index, int offset</args>
</method>
<method>
<name>setRowOffset</name>
<args>int index, int offset</args>
</method>
<method>
<name>updateSizes</name>
</method>
<field>
<name>autoBalance</name>
<desc>bool autoBalance</desc>
</field>
<field>
<name>borderColor</name>
<desc>ColorI borderColor</desc>
</field>
<field>
<name>borderEnable</name>
<desc>enumval borderEnable</desc>
</field>
<field>
<name>borderMovable</name>
<desc>enumval borderMovable</desc>
</field>
<field>
<name>borderWidth</name>
<desc>int borderWidth</desc>
</field>
<field>
<name>columns</name>
<desc>intList columns</desc>
</field>
<field>
<name>fudgeFactor</name>
<desc>int fudgeFactor</desc>
</field>
<field>
<name>rows</name>
<desc>intList rows</desc>
</field>
</class>
<class>
<name>GuiGameListMenuCtrl</name>
<base>GuiControl</base>
<method>
<name>activateRow</name>
<desc>Activates the current row. The script callback of  the current row will be called (if it has one).</desc>
</method>
<method>
<name>addRow</name>
<args>string label, string callback, int icon, int yPad, bool enabled</args>
<desc>Add a row to the list control.

\param label The text to display on the row as a label.
\param callback Name of a script function to use as a callback when this row is activated.
\param icon [optional] Index of the icon to use as a marker.
\param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
\param useHighlightIcon [optional] Does this row use the highlight icon?.
\param enabled [optional] If this row is initially enabled.</desc>
</method>
<method>
<name>getRowCount</name>
<desc>Gets the number of rows on the control.

\return (int) The number of rows on the control.</desc>
</method>
<method>
<name>getRowLabel</name>
<args>int rowIndex</args>
<desc>Gets the label displayed on the specified row.

\param rowIndex Index of the row to get the label of.
\return (string) The label for the row.</desc>
</method>
<method>
<name>getSelectedRow</name>
<desc>Gets the index of the currently selected row.

\return (int) Index of the selected row.</desc>
</method>
<method>
<name>isRowEnabled</name>
<args>int row</args>
<desc>Determines if the specified row is enabled or disabled.

\param row The row to set the enabled status of.
\return (bool) True if the specified row is enabled. False if the row is not enabled or the given index was not valid.</desc>
</method>
<method>
<name>setRowEnabled</name>
<args>int row, bool enabled</args>
<desc>Sets a row's enabled status according to the given parameters.

\param row The index to check for validity.
\param enabled Indicate true to enable the row or false to disable it.</desc>
</method>
<method>
<name>setRowLabel</name>
<args>int rowIndex, string label</args>
<desc>Sets the label on the given row.

\param rowIndex Index of the row to set the label on.
\param label Text to set as the label of the row.</desc>
</method>
<method>
<name>setSelected</name>
<args>int rowIndex</args>
<desc>Sets the selected row. Only rows that are enabled can be selected.

\param index The index to set as selected.</desc>
</method>
<field>
<name>CallbackOnA</name>
<desc>string CallbackOnA</desc>
</field>
<field>
<name>CallbackOnB</name>
<desc>string CallbackOnB</desc>
</field>
<field>
<name>CallbackOnX</name>
<desc>string CallbackOnX</desc>
</field>
<field>
<name>CallbackOnY</name>
<desc>string CallbackOnY</desc>
</field>
<field>
<name>DebugRender</name>
<desc>bool DebugRender</desc>
</field>
</class>
<class>
<name>GuiGameListMenuProfile</name>
<base>GuiControlProfile</base>
<field>
<name>HitAreaLowerRight</name>
<desc>Point2I HitAreaLowerRight</desc>
</field>
<field>
<name>HitAreaUpperLeft</name>
<desc>Point2I HitAreaUpperLeft</desc>
</field>
<field>
<name>IconOffset</name>
<desc>Point2I IconOffset</desc>
</field>
<field>
<name>RowSize</name>
<desc>Point2I RowSize</desc>
</field>
</class>
<class>
<name>GuiGameListOptionsCtrl</name>
<base>GuiGameListMenuCtrl</base>
<method>
<name>addRow</name>
<args>string label, string options, bool wrapOptions, string callback, int icon, int yPad, bool enabled</args>
<desc>Add a row to the list control.

\param label The text to display on the row as a label.
\param options A tab separated list of options.
\param wrapOptions Specify true to allow options to wrap at each end or false to prevent wrapping.
\param callback Name of a script function to use as a callback when this row is activated.
\param icon [optional] Index of the icon to use as a marker.
\param yPad [optional] An extra amount of height padding before the row. Does nothing on the first row.
\param enabled [optional] If this row is initially enabled.</desc>
</method>
<method>
<name>getCurrentOption</name>
<args>int rowIndex</args>
<desc>Gets the text for the currently selected option of the given row.

\param rowIndex Index of the row to get the option from.
\return A string representing the text currently displayed as the selected option on the given row. If there is no such displayed text then the empty string is returned.</desc>
</method>
<method>
<name>selectOption</name>
<args>int rowIndex, string option</args>
<desc>Set the row's current option to the one specified

\param rowIndex Index of the row to set an option on.
\param option The option to be made active.
\return True if the row contained the option and was set, false otherwise.</desc>
</method>
<method>
<name>setOptions</name>
<args>int rowIndex, string options</args>
<desc>Sets the list of options on the given row.

\param rowIndex Index of the row to set options on.\param optionsList A tab separated list of options for the control.</desc>
</method>
</class>
<class>
<name>GuiGameListOptionsProfile</name>
<base>GuiGameListMenuProfile</base>
<field>
<name>ColumnSplit</name>
<desc>int ColumnSplit</desc>
</field>
<field>
<name>RightPad</name>
<desc>int RightPad</desc>
</field>
</class>
<class>
<name>GuiGraphCtrl</name>
<base>GuiControl</base>
<method>
<name>addAutoPlot</name>
<args>int plotID, string variable, int update</args>
<desc>Adds a data point with value variable, every update ms.</desc>
</method>
<method>
<name>addDatum</name>
<args>int plotID, float v</args>
<desc>Add a data point to the given plot.</desc>
</method>
<method>
<name>getDatum</name>
<args>int plotID, int samples</args>
<desc>Get a data point from the plot specified, samples from the start of the graph.</desc>
</method>
<method>
<name>matchScale</name>
<args>int plotID, int plotID, ...</args>
<desc>Sets the scale of all specified plots to the maximum scale among them.</desc>
</method>
<method>
<name>removeAutoPlot</name>
<args>int plotID</args>
<desc>Stops automatic pointing over set interval.</desc>
</method>
<method>
<name>setGraphType</name>
<args>int plotID, string graphType</args>
<desc>Change GraphType of plot plotID.</desc>
</method>
</class>
<class>
<name>GuiGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>GuiHealthBarHud</name>
<base>GuiControl</base>
<field>
<name>damageFillColor</name>
<desc>ColorF damageFillColor</desc>
</field>
<field>
<name>displayEnergy</name>
<desc>bool displayEnergy</desc>
</field>
<field>
<name>fillColor</name>
<desc>ColorF fillColor</desc>
</field>
<field>
<name>frameColor</name>
<desc>ColorF frameColor</desc>
</field>
<field>
<name>pulseRate</name>
<desc>int pulseRate</desc>
</field>
<field>
<name>pulseThreshold</name>
<desc>float pulseThreshold</desc>
</field>
<field>
<name>showFill</name>
<desc>bool showFill</desc>
</field>
<field>
<name>showFrame</name>
<desc>bool showFrame</desc>
</field>
</class>
<class>
<name>GuiIconButtonCtrl</name>
<base>GuiButtonCtrl</base>
<method>
<name>setBitmap</name>
<args>filepath name</args>
</method>
<field>
<name>autoSize</name>
<desc>bool autoSize</desc>
</field>
<field>
<name>buttonMargin</name>
<desc>Point2I buttonMargin</desc>
</field>
<field>
<name>iconBitmap</name>
<desc>filename iconBitmap</desc>
</field>
<field>
<name>iconLocation</name>
<desc>enumval iconLocation</desc>
</field>
<field>
<name>makeIconSquare</name>
<desc>bool makeIconSquare</desc>
</field>
<field>
<name>sizeIconToButton</name>
<desc>bool sizeIconToButton</desc>
</field>
<field>
<name>textLocation</name>
<desc>enumval textLocation</desc>
</field>
<field>
<name>textMargin</name>
<desc>int textMargin</desc>
</field>
</class>
<class>
<name>GuiIdleCamFadeBitmapCtrl</name>
<base>GuiBitmapCtrl</base>
<method>
<name>fadeIn</name>
</method>
<method>
<name>fadeOut</name>
</method>
<field>
<name>done</name>
<desc>bool done</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>int fadeInTime</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>int fadeOutTime</desc>
</field>
</class>
<class>
<name>GuiImageList</name>
<base>SimObject</base>
<method>
<name>clear</name>
<desc>clears the imagelist</desc>
</method>
<method>
<name>count</name>
<desc>gets the number of images in the list</desc>
</method>
<method>
<name>getImage</name>
<args>int index</args>
<desc>Get a path to the texture at the specified index</desc>
</method>
<method>
<name>getIndex</name>
<args>image path</args>
<desc>retrieves the imageindex of a specified texture in the list</desc>
</method>
<method>
<name>insert</name>
<args>image path</args>
<desc>insert an image into imagelist- returns the image index or -1 for failure</desc>
</method>
<method>
<name>remove</name>
<args>image index</args>
<desc>removes an image from the list by index</desc>
</method>
</class>
<class>
<name>GuiInputCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiInspector</name>
<base>GuiStackControl</base>
<method>
<name>apply</name>
<desc>- Force application of inspected object's attributes</desc>
</method>
<method>
<name>getInspectObject</name>
<desc>- Returns currently inspected object</desc>
</method>
<method>
<name>inspect</name>
<desc>Inspect(Object)</desc>
</method>
<method>
<name>refresh</name>
<desc>Reinspect the currently selected object.</desc>
</method>
<method>
<name>setName</name>
<args>NewObjectName</args>
</method>
<field>
<name>dividerMargin</name>
<desc>int dividerMargin</desc>
</field>
<field>
<name>groupFilters</name>
<desc>Specify groups that should be shown or not. Specifying 'shown' implicitly does 'not show' all other groups. Example string: +name -otherName</desc>
</field>
</class>
<class>
<name>GuiInspectorCustomField</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorDatablockField</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorDynamicField</name>
<base>GuiInspectorField</base>
<method>
<name>renameField</name>
<args>newDynamicFieldName</args>
</method>
</class>
<class>
<name>GuiInspectorDynamicGroup</name>
<base>GuiInspectorGroup</base>
<method>
<name>addDynamicField</name>
</method>
<method>
<name>inspectGroup</name>
<desc>Refreshes the dynamic fields in the inspector.</desc>
</method>
</class>
<class>
<name>GuiInspectorField</name>
<base>GuiControl</base>
<method>
<name>apply</name>
<args>newValue</args>
</method>
<method>
<name>getData</name>
</method>
</class>
<class>
<name>GuiInspectorGroup</name>
<base>GuiRolloutCtrl</base>
</class>
<class>
<name>GuiInspectorTypeBitMask32</name>
<base>GuiInspectorField</base>
<method>
<name>applyBit</name>
<desc>apply();</desc>
</method>
</class>
<class>
<name>GuiInspectorTypeBitMask32Helper</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeCheckBox</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeColor</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeColorF</name>
<base>GuiInspectorTypeColor</base>
</class>
<class>
<name>GuiInspectorTypeColorI</name>
<base>GuiInspectorTypeColor</base>
</class>
<class>
<name>GuiInspectorTypeCommand</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeCubemapName</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeEnum</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeFileName</name>
<base>GuiInspectorField</base>
<method>
<name>apply</name>
<args>newValue</args>
</method>
</class>
<class>
<name>GuiInspectorTypeGuiProfile</name>
<base>GuiInspectorTypeMenuBase</base>
</class>
<class>
<name>GuiInspectorTypeImageFileName</name>
<base>GuiInspectorTypeFileName</base>
</class>
<class>
<name>GuiInspectorTypeMaterialName</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeMenuBase</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeName</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorTypeS32</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorVariableField</name>
<base>GuiInspectorField</base>
</class>
<class>
<name>GuiInspectorVariableGroup</name>
<base>GuiInspectorGroup</base>
</class>
<class>
<name>GuiListBoxCtrl</name>
<base>GuiControl</base>
<method>
<name>addFilteredItem</name>
</method>
<method>
<name>addItem</name>
<args>text, color</args>
<desc>- adds an item to the end of the list with an optional color</desc>
</method>
<method>
<name>clearItemColor</name>
<args>index</args>
</method>
<method>
<name>clearItems</name>
<desc>- Clears all the items in the listbox</desc>
</method>
<method>
<name>clearSelection</name>
<desc>- sets all currently selected items to unselected</desc>
</method>
<method>
<name>deleteItem</name>
<args>itemIndex</args>
</method>
<method>
<name>doMirror</name>
</method>
<method>
<name>findItemText</name>
<args> myItemText, [?caseSensitive - false] </args>
<desc>- Returns index of item with matching text or -1 if none</desc>
</method>
<method>
<name>getItemCount</name>
<desc>- returns the number of items in the list</desc>
</method>
<method>
<name>getItemObject</name>
<args>index</args>
<desc>- returns the object associated with an item. This only makes sense if you are mirroring a simset.</desc>
</method>
<method>
<name>getItemText</name>
<args>index</args>
<desc>- returns the text of the item at the specified index</desc>
</method>
<method>
<name>getLastClickItem</name>
<desc>returns the item index that was last clicked, -1 if none</desc>
</method>
<method>
<name>getSelCount</name>
<desc>- returns the number of items currently selected</desc>
</method>
<method>
<name>getSelectedItem</name>
<desc>- returns the selected items index or -1 if none. If multiple selections exist it returns the first selected item</desc>
</method>
<method>
<name>getSelectedItems</name>
<desc>- returns a space delimited list of the selected items indexes in the list</desc>
</method>
<method>
<name>insertItem</name>
<args> text, index </args>
<desc>- inserts an item into the list at the specified index and returns the index assigned or -1 on error</desc>
</method>
<method>
<name>removeFilteredItem</name>
</method>
<method>
<name>setCurSel</name>
<args>index</args>
<desc>- sets the currently selected item at the specified index</desc>
</method>
<method>
<name>setCurSelRange</name>
<args>start,[stop]</args>
<desc>- sets the current selection range from index start to stop.  if no stop is specified it sets from start index to the end of the list</desc>
</method>
<method>
<name>setItemColor</name>
<args>index, color</args>
</method>
<method>
<name>setItemText</name>
<args>index, newtext</args>
<desc>- sets the items text at the specified index</desc>
</method>
<method>
<name>setItemTooltip</name>
<args> int index, string text </args>
<desc>- Set the tooltip text to display for the given list item.</desc>
</method>
<method>
<name>setMultipleSelection</name>
<args>[true/false]</args>
</method>
<method>
<name>setSelected</name>
<args>index, [true]/false</args>
<desc>- sets the item at the index specified to selected or not</desc>
</method>
<field>
<name>AllowMultipleSelections</name>
<desc>bool AllowMultipleSelections</desc>
</field>
<field>
<name>fitParentWidth</name>
<desc>bool fitParentWidth</desc>
</field>
<field>
<name>makeNameCallback</name>
<desc>String makeNameCallback</desc>
</field>
<field>
<name>mirrorSet</name>
<desc>String mirrorSet</desc>
</field>
</class>
<class>
<name>GuiMaterialCtrl</name>
<base>GuiContainer</base>
<method>
<name>setMaterial</name>
<args> string materialName </args>
<desc>Set the material to be displayed in the control.</desc>
</method>
<field>
<name>materialName</name>
<desc>filename materialName</desc>
</field>
</class>
<class>
<name>GuiMaterialPreview</name>
<base>GuiTSCtrl</base>
<method>
<name>deleteModel</name>
<desc>Deletes the preview model.</desc>
</method>
<method>
<name>reset</name>
<desc>Resets the viewport to default zoom, pan, rotate and lighting.</desc>
</method>
<method>
<name>setAmbientLightColor</name>
<args>r,g,b</args>
<desc>Sets the color of the ambient light in the scene.</desc>
</method>
<method>
<name>setLightColor</name>
<args>r,g,b</args>
<desc>Sets the color of the light in the scene.</desc>
</method>
<method>
<name>setModel</name>
<args>string shapeName</args>
<desc>Sets the model to be displayed in this control

\param shapeName Name of the model to display.</desc>
</method>
<method>
<name>setOrbitDistance</name>
<args>float distance</args>
<desc>Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

\param distance The distance to set the orbit to (will be clamped).</desc>
</method>
</class>
<class>
<name>GuiMenuBar</name>
<base>GuiTickCtrl</base>
<method>
<name>addMenu</name>
<args>string menuText, int menuId</args>
<desc>- adds a new menu to the menu bar.</desc>
</method>
<method>
<name>addMenuItem</name>
<args>string menu, string menuItemText, int menuItemId, string accelerator = NULL, int checkGroup = -1</args>
<desc>- adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.</desc>
</method>
<method>
<name>addSubmenuItem</name>
<args>string menu, string menuItem, string submenuItemText, int submenuItemId, string accelerator = NULL, int checkGroup = -1</args>
<desc>- adds a menu item to the specified menu.  The menu argument can be either the text of a menu or its id.</desc>
</method>
<method>
<name>clearMenuItems</name>
<args>string menu</args>
<desc>- removes all the menu items from the specified menu.</desc>
</method>
<method>
<name>clearMenus</name>
<desc>- clears all the menus from the menu bar.</desc>
</method>
<method>
<name>clearSubmenuItems</name>
<args>string menu, string menuItem</args>
<desc>- removes all the menu items from the specified submenu.</desc>
</method>
<method>
<name>removeMenu</name>
<args>string menu</args>
<desc>- removes the specified menu from the menu bar.</desc>
</method>
<method>
<name>removeMenuItem</name>
<args>string menu, string menuItem</args>
<desc>- removes the specified menu item from the menu.</desc>
</method>
<method>
<name>setCheckmarkBitmapIndex</name>
<args>S32 bitmapindex</args>
<desc>- sets the menu bitmap index for the check mark image.</desc>
</method>
<method>
<name>setMenuBitmapIndex</name>
<args>string menu, S32 bitmapindex, bool bitmaponly, bool drawborder</args>
<desc>- sets the bitmap index for the menu and toggles rendering only the bitmap.</desc>
</method>
<method>
<name>setMenuItemBitmap</name>
<args>string menu, string menuItem, int bitmapIndex</args>
<desc>- sets the specified menu item bitmap index in the bitmap array.  Setting the item's index to -1 will remove any bitmap.</desc>
</method>
<method>
<name>setMenuItemChecked</name>
<args>string menu, string menuItem, bool checked</args>
<desc>- sets the menu item bitmap to a check mark, which by default is the first element in the bitmap array (although this may be changed with setCheckmarkBitmapIndex()).  Any other menu items in the menu with the same check group become unchecked if they are checked.</desc>
</method>
<method>
<name>setMenuItemEnable</name>
<args>string menu, string menuItem, bool enabled</args>
<desc>- sets the menu item to enabled or disabled based on the enable parameter.  The specified menu and menu item can either be text or ids.</desc>
</method>
<method>
<name>setMenuItemSubmenuState</name>
<args>string menu, string menuItem, bool isSubmenu</args>
<desc>- Sets the given menu item to be a submenu</desc>
</method>
<method>
<name>setMenuItemText</name>
<args>string menu, string menuItem, string newMenuItemText</args>
<desc>- sets the text of the specified menu item to the new string.</desc>
</method>
<method>
<name>setMenuItemVisible</name>
<args>string menu, string menuItem, bool isVisible</args>
<desc>- sets the specified menu item to be either visible or not.</desc>
</method>
<method>
<name>setMenuMargins</name>
<args>S32 horizontalMargin, S32 verticalMargin, S32 bitmapToTextSpacing</args>
<desc>- Sets the menu rendering margins: horizontal, vertical, bitmap spacing.</desc>
</method>
<method>
<name>setMenuText</name>
<args>string menu, string newMenuText</args>
<desc>- sets the text of the specified menu to the new string.</desc>
</method>
<method>
<name>setMenuVisible</name>
<args>string menu, bool visible</args>
<desc>- sets the whether or not to display the specified menu.</desc>
</method>
<method>
<name>setSubmenuItemChecked</name>
<args>string menu, string menuItem, string submenuItemText, bool checked</args>
<desc>- sets the menu item bitmap to a check mark, which by default is the first element in the bitmap array (although this may be changed with setCheckmarkBitmapIndex()).  Any other menu items in the menu with the same check group become unchecked if they are checked.</desc>
</method>
<field>
<name>Padding</name>
<desc>int Padding</desc>
</field>
</class>
<class>
<name>GuiMeshRoadEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteNode</name>
</method>
<method>
<name>getMode</name>
</method>
<method>
<name>getNodeDepth</name>
</method>
<method>
<name>getNodeNormal</name>
</method>
<method>
<name>getNodePosition</name>
</method>
<method>
<name>getNodeWidth</name>
</method>
<method>
<name>getSelectedRoad</name>
</method>
<method>
<name>matchTerrainToRoad</name>
</method>
<method>
<name>regenerate</name>
</method>
<method>
<name>setMode</name>
<args> String mode </args>
</method>
<method>
<name>setNodeDepth</name>
</method>
<method>
<name>setNodeNormal</name>
</method>
<method>
<name>setNodePosition</name>
</method>
<method>
<name>setNodeWidth</name>
</method>
<method>
<name>setSelectedRoad</name>
</method>
<field>
<name>DefaultDepth</name>
<desc>float DefaultDepth</desc>
</field>
<field>
<name>DefaultNormal</name>
<desc>Point3F DefaultNormal</desc>
</field>
<field>
<name>DefaultWidth</name>
<desc>float DefaultWidth</desc>
</field>
<field>
<name>HoverNodeColor</name>
<desc>ColorI HoverNodeColor</desc>
</field>
<field>
<name>HoverSplineColor</name>
<desc>ColorI HoverSplineColor</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>SelectedSplineColor</name>
<desc>ColorI SelectedSplineColor</desc>
</field>
</class>
<class>
<name>GuiMessageVectorCtrl</name>
<base>GuiControl</base>
<method>
<name>attach</name>
<args>MessageVector item</args>
<desc>Make this gui control display messages from the specified MessageVector</desc>
</method>
<method>
<name>detach</name>
<desc>Stop listing messages from the MessageVector previously attached to, if any.</desc>
</method>
<field>
<name>allowedMatches</name>
<desc>string allowedMatches</desc>
</field>
<field>
<name>lineContinuedIndex</name>
<desc>int lineContinuedIndex</desc>
</field>
<field>
<name>lineSpacing</name>
<desc>int lineSpacing</desc>
</field>
<field>
<name>matchColor</name>
<desc>ColorI matchColor</desc>
</field>
<field>
<name>maxColorIndex</name>
<desc>int maxColorIndex</desc>
</field>
</class>
<class>
<name>GuiMLTextCtrl</name>
<base>GuiControl</base>
<method>
<name>addText</name>
<args>string text, bool reformat</args>
</method>
<method>
<name>forceReflow</name>
<desc>forces the text control to reflow the text after new text is added, possibly resizing the control.</desc>
</method>
<method>
<name>getText</name>
<desc>Returns the text from the control, including ML.</desc>
</method>
<method>
<name>scrollToBottom</name>
<desc>Scroll to the top of the text.</desc>
</method>
<method>
<name>scrollToTag</name>
<args>int tagID</args>
<desc>Scroll down to a specified tag.</desc>
</method>
<method>
<name>scrollToTop</name>
<desc>Scroll to the top of the text.</desc>
</method>
<method>
<name>setAlpha</name>
</method>
<method>
<name>setCursorPosition</name>
<args>int newPos</args>
<desc>Offset in characters to set cursor's position to.</desc>
</method>
<method>
<name>setText</name>
<args>string text</args>
<desc>Set the text contained in the control.</desc>
</method>
<field>
<name>allowColorChars</name>
<desc>bool allowColorChars</desc>
</field>
<field>
<name>deniedSound</name>
<desc>SFXProfile deniedSound</desc>
</field>
<field>
<name>lineSpacing</name>
<desc>int lineSpacing</desc>
</field>
<field>
<name>maxChars</name>
<desc>int maxChars</desc>
</field>
<field>
<name>text</name>
<desc>caseString text</desc>
</field>
<field>
<name>useURLMouseCursor</name>
<desc>bool useURLMouseCursor</desc>
</field>
</class>
<class>
<name>GuiMLTextEditCtrl</name>
<base>GuiMLTextCtrl</base>
<field>
<name>escapeCommand</name>
<desc>string escapeCommand</desc>
</field>
</class>
<class>
<name>GuiMouseEventCtrl</name>
<base>GuiControl</base>
<field>
<name>lockMouse</name>
<desc>bool lockMouse</desc>
</field>
</class>
<class>
<name>GuiNoMouseCtrl</name>
<base>GuiControl</base>
</class>
<class>
<name>GuiObjectView</name>
<base>GuiTSCtrl</base>
<method>
<name>fitToShape</name>
</method>
<method>
<name>getMeshCount</name>
</method>
<method>
<name>getMeshName</name>
<desc>int meshIndex</desc>
</method>
<method>
<name>getNodeCount</name>
</method>
<method>
<name>getNodeName</name>
<desc>int nodeIndex</desc>
</method>
<method>
<name>getNodeSkeletonHidden</name>
</method>
<method>
<name>getParentNodeIndex</name>
<desc>int nodeIndex</desc>
</method>
<method>
<name>getSequenceCount</name>
</method>
<method>
<name>getSequenceFrameCount</name>
<desc>int sequenceIndex</desc>
</method>
<method>
<name>getSequenceName</name>
<desc>int sequenceIndex</desc>
</method>
<method>
<name>getTargetCount</name>
</method>
<method>
<name>getTargetName</name>
<desc>int meshIndex</desc>
</method>
<method>
<name>isBlend</name>
<desc>int sequenceIndex</desc>
</method>
<method>
<name>isCyclic</name>
<desc>int sequenceIndex</desc>
</method>
<method>
<name>loadCamPrefs</name>
</method>
<method>
<name>playSequence</name>
<args>int sequenceIndex</args>
</method>
<method>
<name>setCamPosition</name>
<args>Point3F pos</args>
<desc>Set the free camera's position.

@param pos   Cam position in the form of: 'x y z'</desc>
</method>
<method>
<name>setCyclic</name>
<desc>int sequenceIndex, bool state</desc>
</method>
<method>
<name>setEyeCamMode</name>
<args>bool</args>
<desc>Indicate if free cam mode is on</desc>
</method>
<method>
<name>setFov</name>
<args>float fov</args>
</method>
<method>
<name>setMeshForceHidden</name>
<args> string meshName, bool hidden </args>
<desc>Set the force hidden state on the named mesh.</desc>
</method>
<method>
<name>setModel</name>
<args>string shapeName</args>
<desc>Sets the model to be displayed in this control

\param shapeName Name of the model to display.</desc>
</method>
<method>
<name>setMount</name>
<args>string shapeName, int mountPoint</args>
<desc>Mounts the given model to the specified mount point of the primary model displayed in this control.

\param shapeName Name of the model to mount.\param mountPoint Index of the mount point to be mounted to. Corresponds to "mountPointN" in your shape where N is the number passed here.\param scale Scaling of the mounted object in "x z y" format.</desc>
</method>
<method>
<name>setNodeForceHidden</name>
<desc>string nodeName, bool hidden</desc>
</method>
<method>
<name>setNodeSkeletonHidden</name>
<desc>bool hidden</desc>
</method>
<method>
<name>setOrbitDistance</name>
<args>float distance</args>
<desc>Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

\param distance The distance to set the orbit to (will be clamped).</desc>
</method>
<method>
<name>setOrbitOffset</name>
<args>Point3F offset</args>
<desc>Set the viewer camera's offset.

@param offset   Orbit offset in the form of: 'x y z'</desc>
</method>
<method>
<name>setOrtho</name>
<args>bool isOrtho</args>
</method>
<method>
<name>setSeq</name>
<args>int index</args>
<desc>Sets the animation to play for the viewed object.

\param index The index of the animation to play.</desc>
</method>
<method>
<name>setSeqByName</name>
<args>string sequence_name</args>
</method>
<method>
<name>setSequencePosition</name>
<args>float position</args>
</method>
<method>
<name>setSkinName</name>
<args>string newskin, string oldskin, string refpath</args>
</method>
<method>
<name>setTimeScale</name>
<args>float timeScale</args>
</method>
<method>
<name>setView</name>
<desc>int view</desc>
</method>
<field>
<name>ambient</name>
<desc>ColorF ambient</desc>
</field>
<field>
<name>animSlider</name>
<desc>string animSlider</desc>
</field>
<field>
<name>azimuth</name>
<desc>float azimuth</desc>
</field>
<field>
<name>displayNodes</name>
<desc>bool displayNodes</desc>
</field>
<field>
<name>elevation</name>
<desc>float elevation</desc>
</field>
<field>
<name>lightColor</name>
<desc>ColorF lightColor</desc>
</field>
<field>
<name>lockedXRotation</name>
<desc>float lockedXRotation</desc>
</field>
<field>
<name>lockedZRotation</name>
<desc>float lockedZRotation</desc>
</field>
<field>
<name>lockOrbit</name>
<desc>bool lockOrbit</desc>
</field>
<field>
<name>lockXRotation</name>
<desc>bool lockXRotation</desc>
</field>
<field>
<name>lockZRotation</name>
<desc>bool lockZRotation</desc>
</field>
<field>
<name>orbitDistance</name>
<desc>float orbitDistance</desc>
</field>
<field>
<name>orbitOffset</name>
<desc>Point2F orbitOffset</desc>
</field>
<field>
<name>sliderOverride</name>
<desc>bool sliderOverride</desc>
</field>
<field>
<name>transparent</name>
<desc>bool transparent</desc>
</field>
</class>
<class>
<name>GuiPaneControl</name>
<base>GuiControl</base>
<method>
<name>setCollapsed</name>
<args>bool</args>
</method>
<field>
<name>barBehindText</name>
<desc>bool barBehindText</desc>
</field>
<field>
<name>Caption</name>
<desc>caseString Caption</desc>
</field>
<field>
<name>captionID</name>
<desc>string captionID</desc>
</field>
<field>
<name>collapsable</name>
<desc>bool collapsable</desc>
</field>
</class>
<class>
<name>GuiPanel</name>
<base>GuiContainer</base>
</class>
<class>
<name>GuiParticleGraphCtrl</name>
<base>GuiControl</base>
<method>
<name>addPlotPoint</name>
<args>int plotID, float x, float y, bool setAdded = true;</args>
<desc>Add a data point to the given plot.@return</desc>
</method>
<method>
<name>changePlotPoint</name>
<args>int plotID, int i, float x, float y</args>
<desc>Change a data point to the given plot and plot position.
@param plotID The plot you want to access
@param i The data point.
@param x,y The plot position.
@return No return value.</desc>
</method>
<method>
<name>clearAllGraphs</name>
<desc>Clear all of the graphs.@return No return value</desc>
</method>
<method>
<name>clearGraph</name>
<args>int plotID</args>
<desc>Clear the graph of the given plot.@return No return value</desc>
</method>
<method>
<name>getGraphColor</name>
<args>int plotID</args>
<desc>Get the color of the graph passed.@return Returns the color of the graph as a string of RGB values formatted as "R G B"</desc>
</method>
<method>
<name>getGraphMax</name>
<args>int plotID</args>
<desc>Get the maximum values of the graph ranges.
@return Returns the maximum of the range formatted as "x-max y-max"</desc>
</method>
<method>
<name>getGraphMin</name>
<args>int plotID</args>
<desc>Get the minimum values of the graph ranges.
@return Returns the minimum of the range formatted as "x-min y-min"</desc>
</method>
<method>
<name>getGraphName</name>
<args>int plotID</args>
<desc>Get the name of the graph passed.
@return Returns the name of the plot</desc>
</method>
<method>
<name>getPlotIndex</name>
<args>int plotID, float x, float y</args>
<desc>Gets the index of the point passed on the plotID passed (graph ID).
@param plotID The plot you wish to check.
@param x,y The coordinates of the point to get.
@return Returns the index of the point.</desc>
</method>
<method>
<name>getPlotPoint</name>
<args>int plotID, int samples</args>
<desc>Get a data point from the plot specified, samples from the start of the graph.@return The data point ID</desc>
</method>
<method>
<name>getSelectedPlot</name>
<desc>Gets the selected Plot (a.k.a. graph).
@return The plot's ID.</desc>
</method>
<method>
<name>getSelectedPoint</name>
<desc>Gets the selected Point on the Plot (a.k.a. graph).@return The last selected point ID</desc>
</method>
<method>
<name>insertPlotPoint</name>
<args>int plotID, int i, float x, float y</args>
<desc>Insert a data point to the given plot and plot position.
@param plotID The plot you want to access
@param i The data point.
@param x,y The plot position.
@return No return value.</desc>
</method>
<method>
<name>isExistingPoint</name>
<args>int plotID, int samples</args>
<desc>@return Returns true or false whether or not the point in the plot passed is an existing point.</desc>
</method>
<method>
<name>resetSelectedPoint</name>
<desc>This will reset the currently selected point to nothing.@return No return value.</desc>
</method>
<method>
<name>setAutoGraphMax</name>
<args>bool autoMax</args>
<desc>Set whether the max will automatically be set when adding points (ie if you add a value over the current max, the max is increased to that value).
@return No return value.</desc>
</method>
<method>
<name>setAutoRemove</name>
<args>bool autoRemove</args>
<desc>Set whether or not a point should be deleted when you drag another one over it.@return No return value.</desc>
</method>
<method>
<name>setGraphHidden</name>
<args>int plotID, bool isHidden</args>
<desc>Set whether the graph number passed is hidden or not.@return No return value.</desc>
</method>
<method>
<name>setGraphMax</name>
<args>int plotID, float maxX, float maxY</args>
<desc>Set the max values of the graph of plotID.@param plotID The plot to modify
@param maxX,maxY The maximum bound of the value range.
@return No return value.</desc>
</method>
<method>
<name>setGraphMaxX</name>
<args>int plotID, float maxX</args>
<desc>Set the max X value of the graph of plotID.@param plotID The plot to modify.
@param maxX The maximum x value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphMaxY</name>
<args>int plotID, float maxY</args>
<desc>Set the max Y value of the graph of plotID.@param plotID The plot to modify.
@param maxY The maximum y value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphMin</name>
<args>int plotID, float minX, float minY</args>
<desc>Set the min values of the graph of plotID.
@param plotID The plot to modify
@param minX,minY The minimum bound of the value range.
@return No return value.</desc>
</method>
<method>
<name>setGraphMinX</name>
<args>int plotID, float minX</args>
<desc>Set the min X value of the graph of plotID.
@param plotID The plot to modify.
@param minX The minimum x value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphMinY</name>
<args>int plotID, float minY</args>
<desc>Set the min Y value of the graph of plotID.@param plotID The plot to modify.
@param minY The minimum y value.
@return No return Value.</desc>
</method>
<method>
<name>setGraphName</name>
<args>int plotID, string graphName</args>
<desc>Set the name of the given plot.
@param plotID The plot to modify.
@param graphName The name to set on the plot.
@return No return value.</desc>
</method>
<method>
<name>setPointXMovementClamped</name>
<args>bool clamped</args>
<desc>Set whether the x position of the selected graph point should be clamped@return No return value.</desc>
</method>
<method>
<name>setRenderAll</name>
<args>bool renderAll</args>
<desc>Set whether or not a position should be rendered on every point or just the last selected.@return No return value.</desc>
</method>
<method>
<name>setRenderGraphTooltip</name>
<args>bool renderGraphTooltip</args>
<desc>Set whether or not to render the graph tooltip.@return No return value.</desc>
</method>
<method>
<name>setSelectedPlot</name>
<args>int plotID</args>
<desc>Set the selected plot (a.k.a. graph).@return No return value</desc>
</method>
<method>
<name>setSelectedPoint</name>
<args>int point</args>
<desc>Set the selected point on the graph.
@return No return value</desc>
</method>
</class>
<class>
<name>GuiPopUpMenuCtrl</name>
<base>GuiTextCtrl</base>
<method>
<name>add</name>
<args>string name, int idNum, int scheme=0</args>
</method>
<method>
<name>addScheme</name>
<args>int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL</args>
</method>
<method>
<name>clear</name>
<desc>Clear the popup list.</desc>
</method>
<method>
<name>clearEntry</name>
<args>S32 entry</args>
</method>
<method>
<name>findText</name>
<args>string text</args>
<desc>Returns the position of the first entry containing the specified text.</desc>
</method>
<method>
<name>forceClose</name>
</method>
<method>
<name>forceOnAction</name>
</method>
<method>
<name>getSelected</name>
</method>
<method>
<name>getText</name>
</method>
<method>
<name>getTextById</name>
<args>int id</args>
</method>
<method>
<name>replaceText</name>
<args>bool doReplaceText</args>
</method>
<method>
<name>setEnumContent</name>
<args>string class, string enum</args>
<desc>This fills the popup with a classrep's field enumeration type info.

More of a helper function than anything.   If console access to the field list is added, at least for the enumerated types, then this should go away..</desc>
</method>
<method>
<name>setFirstSelected</name>
<args>[scriptCallback=true]</args>
</method>
<method>
<name>setNoneSelected</name>
</method>
<method>
<name>setSelected</name>
<args>int id, [scriptCallback=true]</args>
</method>
<method>
<name>setText</name>
<args>string text</args>
</method>
<method>
<name>size</name>
<desc>Get the size of the menu - the number of entries in it.</desc>
</method>
<method>
<name>sort</name>
<desc>Sort the list alphabetically.</desc>
</method>
<method>
<name>sortID</name>
<desc>Sort the list by ID.</desc>
</method>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
<field>
<name>bitmapBounds</name>
<desc>Point2I bitmapBounds</desc>
</field>
<field>
<name>maxPopupHeight</name>
<desc>int maxPopupHeight</desc>
</field>
<field>
<name>reverseTextList</name>
<desc>bool reverseTextList</desc>
</field>
<field>
<name>sbUsesNAColor</name>
<desc>bool sbUsesNAColor</desc>
</field>
</class>
<class>
<name>GuiPopUpMenuCtrlEx</name>
<base>GuiTextCtrl</base>
<method>
<name>add</name>
<args>string name, int idNum, int scheme=0</args>
</method>
<method>
<name>addCategory</name>
<args>string text</args>
</method>
<method>
<name>addScheme</name>
<args>int id, ColorI fontColor, ColorI fontColorHL, ColorI fontColorSEL</args>
</method>
<method>
<name>clear</name>
<desc>Clear the popup list.</desc>
</method>
<method>
<name>clearEntry</name>
<args>S32 entry</args>
</method>
<method>
<name>findText</name>
<args>string text</args>
<desc>Returns the id of the first entry containing the specified text.</desc>
</method>
<method>
<name>forceClose</name>
</method>
<method>
<name>forceOnAction</name>
</method>
<method>
<name>getSelected</name>
</method>
<method>
<name>getText</name>
</method>
<method>
<name>getTextById</name>
<args>int id</args>
</method>
<method>
<name>replaceText</name>
<args>bool doReplaceText</args>
</method>
<method>
<name>setEnumContent</name>
<args>string class, string enum</args>
<desc>This fills the popup with a classrep's field enumeration type info.

More of a helper function than anything.   If console access to the field list is added, at least for the enumerated types, then this should go away..</desc>
</method>
<method>
<name>setFirstSelected</name>
<args>[scriptCallback=true]</args>
</method>
<method>
<name>setNoneSelected</name>
</method>
<method>
<name>setSelected</name>
<args>int id, [scriptCallback=true]</args>
</method>
<method>
<name>setText</name>
<args>string text</args>
</method>
<method>
<name>size</name>
<desc>Get the size of the menu - the number of entries in it.</desc>
</method>
<method>
<name>sort</name>
<desc>Sort the list alphabetically.</desc>
</method>
<method>
<name>sortID</name>
<desc>Sort the list by ID.</desc>
</method>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
<field>
<name>bitmapBounds</name>
<desc>Point2I bitmapBounds</desc>
</field>
<field>
<name>hotTrackCallback</name>
<desc>Whether to provide a 'onHotTrackItem' callback when a list item is hovered over</desc>
</field>
<field>
<name>maxPopupHeight</name>
<desc>int maxPopupHeight</desc>
</field>
<field>
<name>reverseTextList</name>
<desc>bool reverseTextList</desc>
</field>
<field>
<name>sbUsesNAColor</name>
<desc>bool sbUsesNAColor</desc>
</field>
</class>
<class>
<name>GuiProgressBitmapCtrl</name>
<base>GuiTextCtrl</base>
<method>
<name>setBitmap</name>
<args>string filename</args>
<desc>Set the bitmap contained in this control.</desc>
</method>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
</class>
<class>
<name>GuiProgressCtrl</name>
<base>GuiTextCtrl</base>
</class>
<class>
<name>GuiRadioCtrl</name>
<base>GuiCheckBoxCtrl</base>
</class>
<class>
<name>GuiRiverEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteNode</name>
</method>
<method>
<name>getMode</name>
</method>
<method>
<name>getNodeDepth</name>
</method>
<method>
<name>getNodeNormal</name>
</method>
<method>
<name>getNodePosition</name>
</method>
<method>
<name>getNodeWidth</name>
</method>
<method>
<name>getSelectedRiver</name>
</method>
<method>
<name>regenerate</name>
</method>
<method>
<name>setMode</name>
<args> String mode </args>
</method>
<method>
<name>setNodeDepth</name>
</method>
<method>
<name>setNodeNormal</name>
</method>
<method>
<name>setNodePosition</name>
</method>
<method>
<name>setNodeWidth</name>
</method>
<method>
<name>setSelectedRiver</name>
</method>
<field>
<name>DefaultDepth</name>
<desc>float DefaultDepth</desc>
</field>
<field>
<name>DefaultNormal</name>
<desc>Point3F DefaultNormal</desc>
</field>
<field>
<name>DefaultWidth</name>
<desc>float DefaultWidth</desc>
</field>
<field>
<name>HoverNodeColor</name>
<desc>ColorI HoverNodeColor</desc>
</field>
<field>
<name>HoverSplineColor</name>
<desc>ColorI HoverSplineColor</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>SelectedSplineColor</name>
<desc>ColorI SelectedSplineColor</desc>
</field>
</class>
<class>
<name>GuiRoadEditorCtrl</name>
<base>EditTSCtrl</base>
<method>
<name>deleteNode</name>
</method>
<method>
<name>deleteRoad</name>
</method>
<method>
<name>getMode</name>
</method>
<method>
<name>getNodePosition</name>
</method>
<method>
<name>getNodeWidth</name>
</method>
<method>
<name>getSelectedNode</name>
</method>
<method>
<name>getSelectedRoad</name>
</method>
<method>
<name>setMode</name>
<args> String mode </args>
</method>
<method>
<name>setNodePosition</name>
</method>
<method>
<name>setNodeWidth</name>
</method>
<method>
<name>setSelectedRoad</name>
</method>
<field>
<name>DefaultWidth</name>
<desc>float DefaultWidth</desc>
</field>
<field>
<name>HoverNodeColor</name>
<desc>ColorI HoverNodeColor</desc>
</field>
<field>
<name>HoverSplineColor</name>
<desc>ColorI HoverSplineColor</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>SelectedSplineColor</name>
<desc>ColorI SelectedSplineColor</desc>
</field>
</class>
<class>
<name>GuiRolloutCtrl</name>
<base>GuiControl</base>
<method>
<name>collapse</name>
</method>
<method>
<name>expand</name>
</method>
<method>
<name>instantCollapse</name>
</method>
<method>
<name>instantExpand</name>
</method>
<method>
<name>isExpanded</name>
</method>
<method>
<name>sizeToContents</name>
</method>
<method>
<name>toggleCollapse</name>
</method>
<method>
<name>toggleExpanded</name>
<args> bool instant </args>
</method>
<field>
<name>Caption</name>
<desc>caseString Caption</desc>
</field>
<field>
<name>ClickCollapse</name>
<desc>bool ClickCollapse</desc>
</field>
<field>
<name>DefaultHeight</name>
<desc>int DefaultHeight</desc>
</field>
<field>
<name>Expanded</name>
<desc>bool Expanded</desc>
</field>
<field>
<name>HideHeader</name>
<desc>bool HideHeader</desc>
</field>
<field>
<name>Margin</name>
<desc>RectI Margin</desc>
</field>
</class>
<class>
<name>GuiScriptNotifyCtrl</name>
<base>GuiControl</base>
<field>
<name>onChildAdded</name>
<desc>bool onChildAdded</desc>
</field>
<field>
<name>onChildRemoved</name>
<desc>bool onChildRemoved</desc>
</field>
<field>
<name>onChildResized</name>
<desc>bool onChildResized</desc>
</field>
<field>
<name>onGainFirstResponder</name>
<desc>bool onGainFirstResponder</desc>
</field>
<field>
<name>onLoseFirstResponder</name>
<desc>bool onLoseFirstResponder</desc>
</field>
<field>
<name>onParentResized</name>
<desc>bool onParentResized</desc>
</field>
<field>
<name>onResize</name>
<desc>bool onResize</desc>
</field>
</class>
<class>
<name>GuiScrollCtrl</name>
<base>GuiContainer</base>
<method>
<name>computeSizes</name>
<desc>- Refresh the sizes of the child objects.</desc>
</method>
<method>
<name>getScrollPositionX</name>
<desc>- get the current x scroll position of the scroll control.</desc>
</method>
<method>
<name>getScrollPositionY</name>
<desc>- get the current y scroll position of the scroll control.</desc>
</method>
<method>
<name>scrollToBottom</name>
<desc>- scrolls the scroll control to the bottom of the child content area.</desc>
</method>
<method>
<name>scrollToObject</name>
<args>obj</args>
<desc>- scrolls the scroll control to view the specified object.</desc>
</method>
<method>
<name>scrollToTop</name>
<desc>- scrolls the scroll control to the top of the child content area.</desc>
</method>
<method>
<name>setScrollPosition</name>
<args>x, y</args>
<desc>- scrolls the scroll control to the specified position.</desc>
</method>
<field>
<name>childMargin</name>
<desc>Point2I childMargin</desc>
</field>
<field>
<name>constantThumbHeight</name>
<desc>bool constantThumbHeight</desc>
</field>
<field>
<name>hScrollBar</name>
<desc>When to display the horizontal scrollbar.</desc>
</field>
<field>
<name>lockHorizScroll</name>
<desc>Horizontal scrolling not allowed if set.</desc>
</field>
<field>
<name>lockVertScroll</name>
<desc>Vertical scrolling not allowed if set.</desc>
</field>
<field>
<name>mouseWheelScrollSpeed</name>
<desc>Pixels/Tick - if not positive then mousewheel scrolling occurs instantly (like other scrolling).</desc>
</field>
<field>
<name>vScrollBar</name>
<desc>When to display the vertical scrollbar.</desc>
</field>
<field>
<name>willFirstRespond</name>
<desc>bool willFirstRespond</desc>
</field>
</class>
<class>
<name>GuiSeparatorCtrl</name>
<base>GuiControl</base>
<field>
<name>BorderMargin</name>
<desc>int BorderMargin</desc>
</field>
<field>
<name>Caption</name>
<desc>string Caption</desc>
</field>
<field>
<name>Invisible</name>
<desc>bool Invisible</desc>
</field>
<field>
<name>LeftMargin</name>
<desc>int LeftMargin</desc>
</field>
<field>
<name>type</name>
<desc>enumval type</desc>
</field>
</class>
<class>
<name>GuiShapeEdPreview</name>
<base>EditTSCtrl</base>
<method>
<name>fitToShape</name>
</method>
<method>
<name>setModel</name>
<args> string shapeName </args>
<desc>Sets the model to be displayed in this control

\param shapeName Name of the model to display.</desc>
</method>
<method>
<name>setOrbitDistance</name>
<args> float distance </args>
<desc>Sets the distance at which the camera orbits the object. Clamped to the acceptable range defined in the class by min and max orbit distances.

\param distance The distance to set the orbit to ( will be clamped ).</desc>
</method>
<method>
<name>setSequence</name>
<args> string sequence </args>
<desc>Sets the animation to play for the viewed object.

\param sequence The name of the animation to play.</desc>
</method>
<method>
<name>setSliderCtrl</name>
<args> string ctrl_name </args>
</method>
<method>
<name>setTimeScale</name>
<args> float scale </args>
</method>
<method>
<name>updateNodeTransforms</name>
</method>
<field>
<name>isPlaying</name>
<desc>bool isPlaying</desc>
</field>
<field>
<name>renderBounds</name>
<desc>bool renderBounds</desc>
</field>
<field>
<name>renderGhost</name>
<desc>bool renderGhost</desc>
</field>
<field>
<name>renderGrid</name>
<desc>bool renderGrid</desc>
</field>
<field>
<name>renderNodes</name>
<desc>bool renderNodes</desc>
</field>
<field>
<name>selectedNode</name>
<desc>int selectedNode</desc>
</field>
<field>
<name>seqIn</name>
<desc>float seqIn</desc>
</field>
<field>
<name>seqOut</name>
<desc>float seqOut</desc>
</field>
</class>
<class>
<name>GuiShapeNameHud</name>
<base>GuiControl</base>
<field>
<name>distanceFade</name>
<desc>float distanceFade</desc>
</field>
<field>
<name>fillColor</name>
<desc>ColorF fillColor</desc>
</field>
<field>
<name>frameColor</name>
<desc>ColorF frameColor</desc>
</field>
<field>
<name>showFill</name>
<desc>bool showFill</desc>
</field>
<field>
<name>showFrame</name>
<desc>bool showFrame</desc>
</field>
<field>
<name>textColor</name>
<desc>ColorF textColor</desc>
</field>
<field>
<name>verticalOffset</name>
<desc>float verticalOffset</desc>
</field>
</class>
<class>
<name>GuiSliderCtrl</name>
<base>GuiControl</base>
<method>
<name>getValue</name>
<desc>Get the position of the slider.</desc>
</method>
<method>
<name>setValue</name>
<args> float pos </args>
<desc>- Set position of the slider.</desc>
</method>
<field>
<name>altMultiplier</name>
<desc>float altMultiplier</desc>
</field>
<field>
<name>altVariable</name>
<desc>string altVariable</desc>
</field>
<field>
<name>defaultValue</name>
<desc>float defaultValue</desc>
</field>
<field>
<name>fluid</name>
<desc>bool fluid</desc>
</field>
<field>
<name>mouseDragged</name>
<desc>bool mouseDragged</desc>
</field>
<field>
<name>range</name>
<desc>Point2F range</desc>
</field>
<field>
<name>snap</name>
<desc>bool snap</desc>
</field>
<field>
<name>ticks</name>
<desc>int ticks</desc>
</field>
<field>
<name>value</name>
<desc>float value</desc>
</field>
</class>
<class>
<name>GuiSpeedometerHud</name>
<base>GuiBitmapCtrl</base>
<field>
<name>center</name>
<desc>Point2F center</desc>
</field>
<field>
<name>color</name>
<desc>ColorF color</desc>
</field>
<field>
<name>length</name>
<desc>float length</desc>
</field>
<field>
<name>maxAngle</name>
<desc>float maxAngle</desc>
</field>
<field>
<name>maxSpeed</name>
<desc>float maxSpeed</desc>
</field>
<field>
<name>minAngle</name>
<desc>float minAngle</desc>
</field>
<field>
<name>tail</name>
<desc>float tail</desc>
</field>
<field>
<name>width</name>
<desc>float width</desc>
</field>
</class>
<class>
<name>GuiSplitContainer</name>
<base>GuiContainer</base>
<field>
<name>FixedPanel</name>
<desc>Which panel will stay fixed on parent resizing</desc>
</field>
<field>
<name>FixedSize</name>
<desc>The total width of the fixed panel</desc>
</field>
<field>
<name>Orientation</name>
<desc>Vertical/Horizontal Splitter</desc>
</field>
<field>
<name>SplitPoint</name>
<desc>The x/y is used depending on the orientation.  This value will change as the parent is resized.</desc>
</field>
<field>
<name>SplitterSize</name>
<desc>The size of the splitter</desc>
</field>
</class>
<class>
<name>GuiStackControl</name>
<base>GuiControl</base>
<method>
<name>freeze</name>
<args>bool</args>
<desc>- Prevents control from restacking</desc>
</method>
<method>
<name>updateStack</name>
<desc>- Restacks controls it owns</desc>
</method>
<field>
<name>ChangeChildPosition</name>
<desc>bool ChangeChildPosition</desc>
</field>
<field>
<name>ChangeChildSizeToFit</name>
<desc>bool ChangeChildSizeToFit</desc>
</field>
<field>
<name>DynamicSize</name>
<desc>bool DynamicSize</desc>
</field>
<field>
<name>HorizStacking</name>
<desc>enumval HorizStacking</desc>
</field>
<field>
<name>Padding</name>
<desc>int Padding</desc>
</field>
<field>
<name>StackingType</name>
<desc>enumval StackingType</desc>
</field>
<field>
<name>VertStacking</name>
<desc>enumval VertStacking</desc>
</field>
</class>
<class>
<name>GuiSwatchButtonCtrl</name>
<base>GuiButtonBaseCtrl</base>
<field>
<name>color</name>
<desc>Foreground color</desc>
</field>
</class>
<class>
<name>GuiTabBookCtrl</name>
<base>GuiContainer</base>
<method>
<name>addPage</name>
<args>no arguments expected</args>
</method>
<method>
<name>getSelectedPage</name>
<args>return S32 mSelectedPageNum</args>
</method>
<method>
<name>selectPage</name>
<args>int pageIndex</args>
</method>
<field>
<name>AllowReorder</name>
<desc>bool AllowReorder</desc>
</field>
<field>
<name>FrontTabPadding</name>
<desc>int FrontTabPadding</desc>
</field>
<field>
<name>MinTabWidth</name>
<desc>int MinTabWidth</desc>
</field>
<field>
<name>TabHeight</name>
<desc>int TabHeight</desc>
</field>
<field>
<name>TabMargin</name>
<desc>int TabMargin</desc>
</field>
<field>
<name>TabPosition</name>
<desc>enumval TabPosition</desc>
</field>
</class>
<class>
<name>GuiTabPageCtrl</name>
<base>GuiTextCtrl</base>
<field>
<name>fitBook</name>
<desc>bool fitBook</desc>
</field>
</class>
<class>
<name>GuiTerrPreviewCtrl</name>
<base>GuiControl</base>
<method>
<name>getOrigin</name>
<desc>Return a Point2F containing the position of the origin.</desc>
</method>
<method>
<name>getRoot</name>
<desc>Return a Point2F representing the position of the root.</desc>
</method>
<method>
<name>getValue</name>
<desc>Returns a 4-tuple containing: root_x root_y origin_x origin_y</desc>
</method>
<method>
<name>reset</name>
<desc>Reset the view of the terrain.</desc>
</method>
<method>
<name>setOrigin</name>
<args>float x, float y</args>
<desc>Set the origin of the view.</desc>
</method>
<method>
<name>setRoot</name>
<desc>Add the origin to the root and reset the origin.</desc>
</method>
<method>
<name>setValue</name>
</method>
</class>
<class>
<name>GuiTextCtrl</name>
<base>GuiContainer</base>
<method>
<name>setText</name>
<args> newText </args>
</method>
<method>
<name>setTextID</name>
<args> newText </args>
</method>
<field>
<name>maxLength</name>
<desc>int maxLength</desc>
</field>
<field>
<name>text</name>
<desc>caseString text</desc>
</field>
<field>
<name>textID</name>
<desc>string textID</desc>
</field>
</class>
<class>
<name>GuiTextEditCtrl</name>
<base>GuiTextCtrl</base>
<method>
<name>clearSelectedText</name>
</method>
<method>
<name>forceValidateText</name>
</method>
<method>
<name>getCursorPos</name>
</method>
<method>
<name>getText</name>
</method>
<method>
<name>isAllTextSelected</name>
</method>
<method>
<name>selectAllText</name>
</method>
<method>
<name>setCursorPos</name>
<args> newPos </args>
</method>
<method>
<name>setText</name>
<args> %text </args>
</method>
<field>
<name>deniedSound</name>
<desc>SFXProfile deniedSound</desc>
</field>
<field>
<name>escapeCommand</name>
<desc>string escapeCommand</desc>
</field>
<field>
<name>historySize</name>
<desc>int historySize</desc>
</field>
<field>
<name>password</name>
<desc>bool password</desc>
</field>
<field>
<name>passwordMask</name>
<desc>string passwordMask</desc>
</field>
<field>
<name>sinkAllKeyEvents</name>
<desc>bool sinkAllKeyEvents</desc>
</field>
<field>
<name>tabComplete</name>
<desc>bool tabComplete</desc>
</field>
<field>
<name>validate</name>
<desc>string validate</desc>
</field>
</class>
<class>
<name>GuiTextEditSliderBitmapCtrl</name>
<base>GuiTextEditCtrl</base>
<field>
<name>bitmap</name>
<desc>filename bitmap</desc>
</field>
<field>
<name>focusOnMouseWheel</name>
<desc>bool focusOnMouseWheel</desc>
</field>
<field>
<name>format</name>
<desc>string format</desc>
</field>
<field>
<name>increment</name>
<desc>float increment</desc>
</field>
<field>
<name>range</name>
<desc>Point2F range</desc>
</field>
</class>
<class>
<name>GuiTextEditSliderCtrl</name>
<base>GuiTextEditCtrl</base>
<field>
<name>focusOnMouseWheel</name>
<desc>bool focusOnMouseWheel</desc>
</field>
<field>
<name>format</name>
<desc>string format</desc>
</field>
<field>
<name>increment</name>
<desc>float increment</desc>
</field>
<field>
<name>range</name>
<desc>Point2F range</desc>
</field>
</class>
<class>
<name>GuiTextListCtrl</name>
<base>GuiArrayCtrl</base>
<method>
<name>addRow</name>
<args>int id, string text, int index=0</args>
<desc>Returns row number of the new item.</desc>
</method>
<method>
<name>clear</name>
<desc>Clear the list.</desc>
</method>
<method>
<name>clearSelection</name>
<desc>Set the selection to nothing.</desc>
</method>
<method>
<name>findTextIndex</name>
<args>string needle</args>
<desc>Find needle in the list, and return the row number it was found in.</desc>
</method>
<method>
<name>getRowId</name>
<args>int index</args>
<desc>Get the row ID for an index.</desc>
</method>
<method>
<name>getRowNumById</name>
<args>int id</args>
<desc>Get the row number for a specified id.</desc>
</method>
<method>
<name>getRowText</name>
<args>int index</args>
<desc>Get the text of the row with the specified index.</desc>
</method>
<method>
<name>getRowTextById</name>
<args>int id</args>
<desc>Get the text of a row with the specified id.</desc>
</method>
<method>
<name>getSelectedId</name>
<desc>Get the ID of the currently selected item.</desc>
</method>
<method>
<name>getSelectedRow</name>
<args>not ID</args>
</method>
<method>
<name>isRowActive</name>
<args>int rowNum</args>
<desc>Is the specified row currently active?</desc>
</method>
<method>
<name>removeRow</name>
<args>int index</args>
<desc>Remove a row from the table, based on its index.</desc>
</method>
<method>
<name>removeRowById</name>
<args>int id</args>
<desc>Remove row with the specified id.</desc>
</method>
<method>
<name>rowCount</name>
<desc>Get the number of rows.</desc>
</method>
<method>
<name>scrollVisible</name>
<args>int rowNum</args>
<desc>Scroll so the specified row is visible.</desc>
</method>
<method>
<name>setRowActive</name>
<args>int rowNum, bool active</args>
<desc>Mark a specified row as active/not.</desc>
</method>
<method>
<name>setRowById</name>
<args>int id, string text</args>
</method>
<method>
<name>setSelectedById</name>
<args>int id</args>
<desc>Finds the specified entry by id, then marks its row as selected.</desc>
</method>
<method>
<name>setSelectedRow</name>
<args>int rowNum</args>
<desc>Selects the specified row.</desc>
</method>
<method>
<name>sort</name>
<args>int columnID, bool increasing=false</args>
<desc>Performs a standard (alphabetical) sort on the values in the specified column.</desc>
</method>
<method>
<name>sortNumerical</name>
<args>int columnID, bool increasing=false</args>
<desc>Perform a numerical sort on the values in the specified column.</desc>
</method>
<field>
<name>clipColumnText</name>
<desc>If true, text exceeding a column's given width will get clipped.</desc>
</field>
<field>
<name>columns</name>
<desc>A vector of column offsets.  The number of values determines the number of columns in the table.</desc>
</field>
<field>
<name>fitParentWidth</name>
<desc>bool fitParentWidth</desc>
</field>
</class>
<class>
<name>GuiTheoraCtrl</name>
<base>GuiControl</base>
<method>
<name>getCurrentTime</name>
<desc>- Return the time elapsed in playback, in seconds.</desc>
</method>
<method>
<name>isPlaybackDone</name>
<desc>- Return true if the video has finished playing.</desc>
</method>
<method>
<name>pause</name>
<desc>- Pause playback.</desc>
</method>
<method>
<name>play</name>
<desc>- Start playback.</desc>
</method>
<method>
<name>setFile</name>
<args>string filename</args>
<desc>Set an Ogg Theora file to play.</desc>
</method>
<method>
<name>stop</name>
<desc>- Stop playback.</desc>
</method>
<field>
<name>backgroundColor</name>
<desc>Fill color when video is not playing.</desc>
</field>
<field>
<name>matchVideoSize</name>
<desc>Match control extents with video size.</desc>
</field>
<field>
<name>playOnWake</name>
<desc>Start playing video when control is woken up.</desc>
</field>
<field>
<name>renderDebugInfo</name>
<desc>Render text information useful for debugging.</desc>
</field>
<field>
<name>stopOnSleep</name>
<desc>Stop video when control is set to sleep.</desc>
</field>
<field>
<name>theoraFile</name>
<desc>Theora video file to play.</desc>
</field>
<field>
<name>transcoder</name>
<desc>enumval transcoder</desc>
</field>
</class>
<class>
<name>GuiTickCtrl</name>
<base>GuiControl</base>
<method>
<name>setProcessTicks</name>
<args> [tick = true] </args>
<desc>- This will set this object to either be processing ticks or not</desc>
</method>
</class>
<class>
<name>GuiToggleButtonCtrl</name>
<base>GuiButtonCtrl</base>
</class>
<class>
<name>GuiToolboxButtonCtrl</name>
<base>GuiButtonCtrl</base>
<method>
<name>setHoverBitmap</name>
<args> filepath name </args>
<desc>sets the bitmap that shows when the button is disabled</desc>
</method>
<method>
<name>setLoweredBitmap</name>
<args> filepath name </args>
<desc>sets the bitmap that shows when the button is disabled</desc>
</method>
<method>
<name>setNormalBitmap</name>
<args> filepath name </args>
<desc>sets the bitmap that shows when the button is active</desc>
</method>
<field>
<name>hoverBitmap</name>
<desc>filename hoverBitmap</desc>
</field>
<field>
<name>loweredBitmap</name>
<desc>filename loweredBitmap</desc>
</field>
<field>
<name>normalBitmap</name>
<desc>filename normalBitmap</desc>
</field>
</class>
<class>
<name>GuiTreeViewCtrl</name>
<base>GuiArrayCtrl</base>
<method>
<name>addChildSelectionByValue</name>
<args>TreeItemId parent, value</args>
</method>
<method>
<name>addSelection</name>
<args>selects an item</args>
</method>
<method>
<name>buildIconTable</name>
<args>builds an icon table</args>
</method>
<method>
<name>buildVisibleTree</name>
<desc>Build the visible tree</desc>
</method>
<method>
<name>clear</name>
<desc>- empty tree</desc>
</method>
<method>
<name>clearSelection</name>
<args>clears selection</args>
</method>
<method>
<name>deleteSelection</name>
<args>deletes the selected items</args>
</method>
<method>
<name>editItem</name>
<args>TreeItemId item, string newText, string newValue</args>
</method>
<method>
<name>expandItem</name>
<args>TreeItemId item, bool expand=true</args>
</method>
<method>
<name>findChildItemByName</name>
<args> int parent, string name </args>
<desc>- Return the ID of the child that matches the given name or 0.</desc>
</method>
<method>
<name>findItemByName</name>
<args>find item by name and returns the mId</args>
</method>
<method>
<name>findItemByObjectId</name>
<args>find item by object id and returns the mId</args>
</method>
<method>
<name>getChild</name>
<args>TreeItemId item</args>
</method>
<method>
<name>getFirstRootItem</name>
<desc>Get id for root item.</desc>
</method>
<method>
<name>getItemCount</name>
</method>
<method>
<name>getItemText</name>
<args>TreeItemId item</args>
</method>
<method>
<name>getItemValue</name>
<args>TreeItemId item</args>
</method>
<method>
<name>getNextSibling</name>
<args>TreeItemId item</args>
</method>
<method>
<name>getParent</name>
<args>TreeItemId item</args>
</method>
<method>
<name>getPrevSibling</name>
<args>TreeItemId item</args>
</method>
<method>
<name>getSelectedItem</name>
</method>
<method>
<name>getSelectedItemList</name>
<desc>returns a space seperated list of mulitple item ids</desc>
</method>
<method>
<name>getSelectedItemsCount</name>
</method>
<method>
<name>getSelectedObject</name>
<desc>returns the currently selected simObject in inspector mode or -1</desc>
</method>
<method>
<name>getTextToRoot</name>
<args>TreeItemId item,Delimiter=none</args>
<desc>gets the text from the current node to the root, concatenating at each branch upward, with a specified delimiter optionally</desc>
</method>
<method>
<name>hideSelection</name>
<args> [bool state] </args>
<desc>- set hidden state of objects in selection</desc>
</method>
<method>
<name>insertItem</name>
<args>TreeItemId parent, name, value, icon, normalImage=0, expandedImage=0</args>
</method>
<method>
<name>isParentItem</name>
<args> int id </args>
<desc>- Returns true if the given item contains child items.</desc>
</method>
<method>
<name>lockSelection</name>
<args>locks selections</args>
</method>
<method>
<name>markItem</name>
<args>TreeItemId item, bool mark=true</args>
</method>
<method>
<name>moveItemDown</name>
<args>TreeItemId item</args>
</method>
<method>
<name>moveItemUp</name>
<args>TreeItemId item</args>
</method>
<method>
<name>open</name>
<args>SimSet obj, bool okToEdit=true</args>
<desc>Set the root of the tree view to the specified object, or to the root set.</desc>
</method>
<method>
<name>removeAllChildren</name>
<args>TreeItemId parent</args>
</method>
<method>
<name>removeChildSelectionByValue</name>
<args>TreeItemId parent, value</args>
</method>
<method>
<name>removeItem</name>
<args>TreeItemId item</args>
</method>
<method>
<name>removeSelection</name>
<args>deselects an item</args>
</method>
<method>
<name>scrollVisible</name>
<args>TreeItemId item</args>
</method>
<method>
<name>scrollVisibleByObjectId</name>
<args>show item by object id. returns true if sucessful.</args>
</method>
<method>
<name>selectItem</name>
<args>TreeItemId item, bool select=true</args>
</method>
<method>
<name>setItemImages</name>
<args> int id, int normalImage, int expandedImage </args>
<desc>- Sets the normal and expanded images to show for the given item.</desc>
</method>
<method>
<name>setItemTooltip</name>
<args> int id, string text </args>
<desc>- Set the tooltip to show for the given item.</desc>
</method>
<method>
<name>sort</name>
<args> [int parent, bool traverseHierarchy=false, bool parentsFirst=false, bool caseSensitive=true </args>
<desc>- Sorts all items of the given parent (or root).  With 'hierarchy', traverses hierarchy.</desc>
</method>
<field>
<name>ClearAllOnSingleSelection</name>
<desc>bool ClearAllOnSingleSelection</desc>
</field>
<field>
<name>compareToObjectID</name>
<desc>bool compareToObjectID</desc>
</field>
<field>
<name>DeleteObjectAllowed</name>
<desc>bool DeleteObjectAllowed</desc>
</field>
<field>
<name>destroyTreeOnSleep</name>
<desc>bool destroyTreeOnSleep</desc>
</field>
<field>
<name>DragToItemAllowed</name>
<desc>bool DragToItemAllowed</desc>
</field>
<field>
<name>fullRowSelect</name>
<desc>bool fullRowSelect</desc>
</field>
<field>
<name>internalNamesOnly</name>
<desc>bool internalNamesOnly</desc>
</field>
<field>
<name>itemHeight</name>
<desc>int itemHeight</desc>
</field>
<field>
<name>MouseDragging</name>
<desc>bool MouseDragging</desc>
</field>
<field>
<name>MultipleSelections</name>
<desc>bool MultipleSelections</desc>
</field>
<field>
<name>objectNamesOnly</name>
<desc>bool objectNamesOnly</desc>
</field>
<field>
<name>showRoot</name>
<desc>bool showRoot</desc>
</field>
<field>
<name>tabSize</name>
<desc>int tabSize</desc>
</field>
<field>
<name>textOffset</name>
<desc>int textOffset</desc>
</field>
<field>
<name>tooltipOnWidthOnly</name>
<desc>bool tooltipOnWidthOnly</desc>
</field>
<field>
<name>useInspectorTooltips</name>
<desc>bool useInspectorTooltips</desc>
</field>
</class>
<class>
<name>GuiTSCtrl</name>
<base>GuiContainer</base>
<method>
<name>calculateViewDistance</name>
<args> radius </args>
<desc>: Returns the distance required to fit the given radius within the camera's view.</desc>
</method>
<method>
<name>getWorldToScreenScale</name>
<desc>: Returns the scale for converting world space units to pixels.</desc>
</method>
<method>
<name>project</name>
<args> %worldPosition </args>
<desc>: Transforms world space coordinates to screen space (x, y, depth)</desc>
</method>
<method>
<name>unproject</name>
<args> %screenPosition </args>
<desc>: Transforms 3D screen space coordinates (x, y, depth) to world space.</desc>
</method>
<field>
<name>cameraZRot</name>
<desc>float cameraZRot</desc>
</field>
<field>
<name>forceFOV</name>
<desc>float forceFOV</desc>
</field>
<field>
<name>reflectPriority</name>
<desc>float reflectPriority</desc>
</field>
</class>
<class>
<name>GuiVariableInspector</name>
<base>GuiInspector</base>
<method>
<name>loadVars</name>
<args> searchString </args>
</method>
</class>
<class>
<name>GuiWindowCollapseCtrl</name>
<base>GuiWindowCtrl</base>
<method>
<name>setCollapseGroup</name>
<args>bool collapse</args>
<desc>- Set the window's collapsing state.</desc>
</method>
<method>
<name>toggleCollapseGroup</name>
<desc>- Toggle the window collapsing.</desc>
</method>
<field>
<name>CollapseGroup</name>
<desc>int CollapseGroup</desc>
</field>
<field>
<name>CollapseGroupNum</name>
<desc>int CollapseGroupNum</desc>
</field>
</class>
<class>
<name>GuiWindowCtrl</name>
<base>GuiContainer</base>
<method>
<name>selectWindow</name>
<desc>- Bring the window to the front.</desc>
</method>
<field>
<name>canClose</name>
<desc>bool canClose</desc>
</field>
<field>
<name>canMaximize</name>
<desc>bool canMaximize</desc>
</field>
<field>
<name>canMinimize</name>
<desc>bool canMinimize</desc>
</field>
<field>
<name>canMove</name>
<desc>bool canMove</desc>
</field>
<field>
<name>closeCommand</name>
<desc>string closeCommand</desc>
</field>
<field>
<name>EdgeSnap</name>
<desc>bool EdgeSnap</desc>
</field>
<field>
<name>minSize</name>
<desc>Point2I minSize</desc>
</field>
<field>
<name>resizeHeight</name>
<desc>bool resizeHeight</desc>
</field>
<field>
<name>resizeWidth</name>
<desc>bool resizeWidth</desc>
</field>
<field>
<name>text</name>
<desc>caseString text</desc>
</field>
</class>
<class>
<name>HoverVehicle</name>
<base>Vehicle</base>
</class>
<class>
<name>HoverVehicleData</name>
<base>VehicleData</base>
<field>
<name>brakingActivationSpeed</name>
<desc>float brakingActivationSpeed</desc>
</field>
<field>
<name>brakingForce</name>
<desc>float brakingForce</desc>
</field>
<field>
<name>dragForce</name>
<desc>float dragForce</desc>
</field>
<field>
<name>dustTrailEmitter</name>
<desc>ParticleEmitterData dustTrailEmitter</desc>
</field>
<field>
<name>dustTrailFreqMod</name>
<desc>float dustTrailFreqMod</desc>
</field>
<field>
<name>dustTrailOffset</name>
<desc>Point3F dustTrailOffset</desc>
</field>
<field>
<name>engineSound</name>
<desc>SFXProfile engineSound</desc>
</field>
<field>
<name>floatingGravMag</name>
<desc>float floatingGravMag</desc>
</field>
<field>
<name>floatingThrustFactor</name>
<desc>float floatingThrustFactor</desc>
</field>
<field>
<name>floatSound</name>
<desc>SFXProfile floatSound</desc>
</field>
<field>
<name>forwardJetEmitter</name>
<desc>ParticleEmitterData forwardJetEmitter</desc>
</field>
<field>
<name>gyroDrag</name>
<desc>float gyroDrag</desc>
</field>
<field>
<name>jetSound</name>
<desc>SFXProfile jetSound</desc>
</field>
<field>
<name>mainThrustForce</name>
<desc>float mainThrustForce</desc>
</field>
<field>
<name>normalForce</name>
<desc>float normalForce</desc>
</field>
<field>
<name>pitchForce</name>
<desc>float pitchForce</desc>
</field>
<field>
<name>restorativeForce</name>
<desc>float restorativeForce</desc>
</field>
<field>
<name>reverseThrustForce</name>
<desc>float reverseThrustForce</desc>
</field>
<field>
<name>rollForce</name>
<desc>float rollForce</desc>
</field>
<field>
<name>stabDampingConstant</name>
<desc>float stabDampingConstant</desc>
</field>
<field>
<name>stabLenMax</name>
<desc>float stabLenMax</desc>
</field>
<field>
<name>stabLenMin</name>
<desc>float stabLenMin</desc>
</field>
<field>
<name>stabSpringConstant</name>
<desc>float stabSpringConstant</desc>
</field>
<field>
<name>steeringForce</name>
<desc>float steeringForce</desc>
</field>
<field>
<name>strafeThrustForce</name>
<desc>float strafeThrustForce</desc>
</field>
<field>
<name>triggerTrailHeight</name>
<desc>float triggerTrailHeight</desc>
</field>
<field>
<name>turboFactor</name>
<desc>float turboFactor</desc>
</field>
<field>
<name>vertFactor</name>
<desc>float vertFactor</desc>
</field>
</class>
<class>
<name>HTTPObject</name>
<base>TCPObject</base>
<method>
<name>get</name>
<args>TransportAddress addr, string requirstURI, string query=NULL</args>
</method>
<method>
<name>post</name>
<args>TransportAddress addr, string requestURI, string query, string post</args>
</method>
</class>
<class>
<name>InspectorFieldUndoAction</name>
<base>UndoAction</base>
<field>
<name>arrayIndex</name>
<desc>string arrayIndex</desc>
</field>
<field>
<name>fieldName</name>
<desc>string fieldName</desc>
</field>
<field>
<name>fieldValue</name>
<desc>String fieldValue</desc>
</field>
<field>
<name>inspectorGui</name>
<desc>SimObjectPtr inspectorGui</desc>
</field>
<field>
<name>objectId</name>
<desc>int objectId</desc>
</field>
</class>
<class>
<name>InteriorInstance</name>
<base>SceneObject</base>
<method>
<name>changeMaterial</name>
<args>mapTo, fromMaterial, ToMaterial</args>
</method>
<method>
<name>exportToCollada</name>
<args>[bool bakeTransform] exports the Interior to a Collada file</args>
</method>
<method>
<name>getModelFile</name>
<args> String </args>
</method>
<method>
<name>getNumDetailLevels</name>
</method>
<method>
<name>getTargetCount</name>
<args>detailLevel</args>
</method>
<method>
<name>getTargetName</name>
<args>detailLevel, targetNum</args>
</method>
<method>
<name>setAlarmMode</name>
<args>string mode</args>
<desc>Mode is 'On' or 'Off'</desc>
</method>
<method>
<name>setDetailLevel</name>
<args>int level</args>
</method>
<method>
<name>setSkinBase</name>
<args>string basename</args>
</method>
<field>
<name>interiorFile</name>
<desc>filename interiorFile</desc>
</field>
<field>
<name>SFXEnvironment</name>
<desc>SFXEnvironment SFXEnvironment</desc>
</field>
<field>
<name>SFXProfile</name>
<desc>SFXProfile SFXProfile</desc>
</field>
<field>
<name>showTerrainInside</name>
<desc>bool showTerrainInside</desc>
</field>
<field>
<name>smoothLighting</name>
<desc>bool smoothLighting</desc>
</field>
</class>
<class>
<name>Item</name>
<base>ShapeBase</base>
<method>
<name>getLastStickyNormal</name>
<desc>Get the normal of the surface on which the object is stuck.</desc>
</method>
<method>
<name>getLastStickyPos</name>
<desc>Get the position on the surface on which the object is stuck.</desc>
</method>
<method>
<name>isRotating</name>
<desc>Is the object still rotating?</desc>
</method>
<method>
<name>isStatic</name>
<desc>Is the object static (ie, non-movable)?</desc>
</method>
<method>
<name>setCollisionTimeout</name>
<args>ShapeBase obj</args>
<desc>Temporarily disable collisions against obj.</desc>
</method>
<field>
<name>collideable</name>
<desc>bool collideable</desc>
</field>
<field>
<name>rotate</name>
<desc>bool rotate</desc>
</field>
<field>
<name>rotate2</name>
<desc>bool rotate2</desc>
</field>
<field>
<name>static</name>
<desc>bool static</desc>
</field>
</class>
<class>
<name>ItemData</name>
<base>ShapeBaseData</base>
<field>
<name>dynamicType</name>
<desc>int dynamicType</desc>
</field>
<field>
<name>elasticity</name>
<desc>float elasticity</desc>
</field>
<field>
<name>friction</name>
<desc>float friction</desc>
</field>
<field>
<name>gravityMod</name>
<desc>float gravityMod</desc>
</field>
<field>
<name>lightColor</name>
<desc>ColorF lightColor</desc>
</field>
<field>
<name>lightOnlyStatic</name>
<desc>bool lightOnlyStatic</desc>
</field>
<field>
<name>lightRadius</name>
<desc>float lightRadius</desc>
</field>
<field>
<name>LightTime</name>
<desc>int LightTime</desc>
</field>
<field>
<name>lightType</name>
<desc>enumval lightType</desc>
</field>
<field>
<name>maxVelocity</name>
<desc>float maxVelocity</desc>
</field>
<field>
<name>pickUpName</name>
<desc>caseString pickUpName</desc>
</field>
<field>
<name>sticky</name>
<desc>bool sticky</desc>
</field>
</class>
<class>
<name>LangTable</name>
<base>SimObject</base>
<method>
<name>addLanguage</name>
<args>string filename, [string languageName]</args>
</method>
<method>
<name>getCurrentLanguage</name>
</method>
<method>
<name>getLangName</name>
<args>int language</args>
</method>
<method>
<name>getNumLang</name>
</method>
<method>
<name>getString</name>
<args>string filename</args>
</method>
<method>
<name>setCurrentLanguage</name>
<args>int language</args>
</method>
<method>
<name>setDefaultLanguage</name>
<args>int language</args>
</method>
</class>
<class>
<name>LevelInfo</name>
<base>NetObject</base>
<field>
<name>advancedLightmapSupport</name>
<desc>Enable expanded support for mixing static and dynamic lighting (more costly)</desc>
</field>
<field>
<name>canvasClearColor</name>
<desc>The color used to clear the background before the scene or any GUIs are rendered.</desc>
</field>
<field>
<name>decalBias</name>
<desc>NearPlane bias used when rendering Decal and DecalRoad. This should be tuned to the visibleDistance in your level.</desc>
</field>
<field>
<name>fogAtmosphereHeight</name>
<desc>A height in meters for altitude fog falloff.</desc>
</field>
<field>
<name>fogColor</name>
<desc>The default color for the scene fog.</desc>
</field>
<field>
<name>fogDensity</name>
<desc>The 0 to 1 density value for the exponential fog falloff.</desc>
</field>
<field>
<name>fogDensityOffset</name>
<desc>An offset from the camera in meters for moving the start of the fog effect.</desc>
</field>
<field>
<name>nearClip</name>
<desc>float nearClip</desc>
</field>
<field>
<name>visibleDistance</name>
<desc>float visibleDistance</desc>
</field>
</class>
<class>
<name>LightAnimData</name>
<base>SimDataBlock</base>
<field>
<name>animEnabled</name>
<desc>bool animEnabled</desc>
</field>
<field>
<name>chanceTurnOff</name>
<desc>float chanceTurnOff</desc>
</field>
<field>
<name>chanceTurnOn</name>
<desc>float chanceTurnOn</desc>
</field>
<field>
<name>flicker</name>
<desc>bool flicker</desc>
</field>
<field>
<name>maxBrightness</name>
<desc>float maxBrightness</desc>
</field>
<field>
<name>minBrightness</name>
<desc>float minBrightness</desc>
</field>
</class>
<class>
<name>LightBase</name>
<base>SceneObject</base>
<method>
<name>pauseAnimation</name>
<desc>Stops the light animation.</desc>
</method>
<method>
<name>playAnimation</name>
<args> [LightAnimData anim] </args>
<desc>^Plays a light animation on the light.  If no LightAnimData is passed the existing one is played.</desc>
</method>
<method>
<name>setLightEnabled</name>
<args> bool enabled </args>
<desc>^Toggles the light on and off.</desc>
</method>
<field>
<name>animate</name>
<desc>bool animate</desc>
</field>
<field>
<name>animationPeriod</name>
<desc>float animationPeriod</desc>
</field>
<field>
<name>animationPhase</name>
<desc>float animationPhase</desc>
</field>
<field>
<name>animationType</name>
<desc>LightAnimData animationType</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>brightness</name>
<desc>float brightness</desc>
</field>
<field>
<name>castShadows</name>
<desc>bool castShadows</desc>
</field>
<field>
<name>color</name>
<desc>ColorF color</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>float flareScale</desc>
</field>
<field>
<name>flareType</name>
<desc>LightFlareData flareType</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>isEnabled</name>
<desc>bool isEnabled</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>priority</name>
<desc>float priority</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>splitFadeDistances</name>
<desc>Distances (in world space units) that the shadows will fade between PSSM splits</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
</class>
<class>
<name>LightDescription</name>
<base>SimDataBlock</base>
<method>
<name>apply</name>
<desc>force an inspectPostApply for the benefit of tweaking via the console</desc>
</method>
<field>
<name>animationPeriod</name>
<desc>float animationPeriod</desc>
</field>
<field>
<name>animationPhase</name>
<desc>float animationPhase</desc>
</field>
<field>
<name>animationType</name>
<desc>LightAnimData animationType</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>brightness</name>
<desc>float brightness</desc>
</field>
<field>
<name>castShadows</name>
<desc>bool castShadows</desc>
</field>
<field>
<name>color</name>
<desc>ColorF color</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>float flareScale</desc>
</field>
<field>
<name>flareType</name>
<desc>LightFlareData flareType</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>range</name>
<desc>float range</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>splitFadeDistances</name>
<desc>Distances (in world space units) that the shadows will fade between PSSM splits</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
</class>
<class>
<name>LightFlareData</name>
<base>SimDataBlock</base>
<method>
<name>apply</name>
<desc>force an inspectPostApply for the benefit of tweaking via the console</desc>
</method>
<field>
<name>elementDist</name>
<desc>float elementDist</desc>
</field>
<field>
<name>elementRect</name>
<desc>RectF elementRect</desc>
</field>
<field>
<name>elementRotate</name>
<desc>bool elementRotate</desc>
</field>
<field>
<name>elementScale</name>
<desc>float elementScale</desc>
</field>
<field>
<name>elementTint</name>
<desc>ColorF elementTint</desc>
</field>
<field>
<name>elementUseLightColor</name>
<desc>bool elementUseLightColor</desc>
</field>
<field>
<name>flareEnabled</name>
<desc>bool flareEnabled</desc>
</field>
<field>
<name>flareTexture</name>
<desc>filename flareTexture</desc>
</field>
<field>
<name>occlusionRadius</name>
<desc>Radius in world units to test for occlusion if supported by hardware, disable by setting radius non-positive.</desc>
</field>
<field>
<name>overallScale</name>
<desc>float overallScale</desc>
</field>
</class>
<class>
<name>Lightning</name>
<base>GameBase</base>
<method>
<name>strikeObject</name>
<args>ShapeBase id</args>
</method>
<method>
<name>strikeRandomPoint</name>
</method>
<method>
<name>warningFlashes</name>
</method>
<field>
<name>boltStartRadius</name>
<desc>float boltStartRadius</desc>
</field>
<field>
<name>chanceToHitTarget</name>
<desc>float chanceToHitTarget</desc>
</field>
<field>
<name>color</name>
<desc>ColorF color</desc>
</field>
<field>
<name>fadeColor</name>
<desc>ColorF fadeColor</desc>
</field>
<field>
<name>strikeRadius</name>
<desc>float strikeRadius</desc>
</field>
<field>
<name>strikesPerMinute</name>
<desc>int strikesPerMinute</desc>
</field>
<field>
<name>strikeWidth</name>
<desc>float strikeWidth</desc>
</field>
<field>
<name>useFog</name>
<desc>bool useFog</desc>
</field>
</class>
<class>
<name>LightningData</name>
<base>GameBaseData</base>
<field>
<name>strikeSound</name>
<desc>SFXProfile strikeSound</desc>
</field>
<field>
<name>strikeTextures</name>
<desc>string strikeTextures</desc>
</field>
<field>
<name>thunderSounds</name>
<desc>SFXProfile thunderSounds</desc>
</field>
</class>
<class>
<name>LightningStrikeEvent</name>
</class>
<class>
<name>Marker</name>
<base>SceneObject</base>
<field>
<name>msToNext</name>
<desc>int msToNext</desc>
</field>
<field>
<name>seqNum</name>
<desc>int seqNum</desc>
</field>
<field>
<name>smoothingType</name>
<desc>enumval smoothingType</desc>
</field>
<field>
<name>type</name>
<desc>enumval type</desc>
</field>
</class>
<class>
<name>Material</name>
<base>SimObject</base>
<method>
<name>dumpInstances</name>
<desc>Dumps a formatted list of the currently allocated material instances for this material to the console.</desc>
</method>
<method>
<name>flush</name>
<desc>Flushes all material instances that use this material.</desc>
</method>
<method>
<name>getAnimFlags</name>
</method>
<method>
<name>getFilename</name>
<desc>Get filename of material</desc>
</method>
<method>
<name>isAutoGenerated</name>
<desc>Returns true if this Material was automatically generated by MaterialList::mapMaterials()</desc>
</method>
<method>
<name>reload</name>
<desc>Reloads all material instances that use this material.</desc>
</method>
<method>
<name>setAutoGenerated</name>
<args>bool isAutoGenerated</args>
<desc>: Set whether or not the Material is autogenerated.</desc>
</method>
<field>
<name>alphaRef</name>
<desc>int alphaRef</desc>
</field>
<field>
<name>alphaTest</name>
<desc>bool alphaTest</desc>
</field>
<field>
<name>animFlags</name>
<desc>int animFlags</desc>
</field>
<field>
<name>baseTex</name>
<desc>filename baseTex</desc>
</field>
<field>
<name>bumpTex</name>
<desc>The normal map texture.  You can use the DXTnm format only when per-pixel specular highlights are disabled, or a specular map is in use.</desc>
</field>
<field>
<name>castShadows</name>
<desc>If set to false the lighting system will not cast shadows from this material.</desc>
</field>
<field>
<name>colorMultiply</name>
<desc>ColorF colorMultiply</desc>
</field>
<field>
<name>cubemap</name>
<desc>String cubemap</desc>
</field>
<field>
<name>customFootstepSound</name>
<desc>SFXProfile customFootstepSound</desc>
</field>
<field>
<name>customImpactSound</name>
<desc>SFXProfile customImpactSound</desc>
</field>
<field>
<name>detailMap</name>
<desc>filename detailMap</desc>
</field>
<field>
<name>detailScale</name>
<desc>Point2F detailScale</desc>
</field>
<field>
<name>detailTex</name>
<desc>filename detailTex</desc>
</field>
<field>
<name>diffuseColor</name>
<desc>ColorF diffuseColor</desc>
</field>
<field>
<name>diffuseMap</name>
<desc>filename diffuseMap</desc>
</field>
<field>
<name>doubleSided</name>
<desc>bool doubleSided</desc>
</field>
<field>
<name>dynamicCubemap</name>
<desc>bool dynamicCubemap</desc>
</field>
<field>
<name>effectColor</name>
<desc>ColorF effectColor</desc>
</field>
<field>
<name>emissive</name>
<desc>bool emissive</desc>
</field>
<field>
<name>envMap</name>
<desc>filename envMap</desc>
</field>
<field>
<name>envTex</name>
<desc>filename envTex</desc>
</field>
<field>
<name>exposure</name>
<desc>int exposure</desc>
</field>
<field>
<name>footstepSoundId</name>
<desc>int footstepSoundId</desc>
</field>
<field>
<name>friction</name>
<desc>float friction</desc>
</field>
<field>
<name>glow</name>
<desc>bool glow</desc>
</field>
<field>
<name>impactSoundId</name>
<desc>int impactSoundId</desc>
</field>
<field>
<name>lightMap</name>
<desc>filename lightMap</desc>
</field>
<field>
<name>mapTo</name>
<desc>String mapTo</desc>
</field>
<field>
<name>minnaertConstant</name>
<desc>float minnaertConstant</desc>
</field>
<field>
<name>normalMap</name>
<desc>The normal map texture.  You can use the DXTnm format only when per-pixel specular highlights are disabled, or a specular map is in use.</desc>
</field>
<field>
<name>overlayMap</name>
<desc>filename overlayMap</desc>
</field>
<field>
<name>overlayTex</name>
<desc>filename overlayTex</desc>
</field>
<field>
<name>parallaxScale</name>
<desc>float parallaxScale</desc>
</field>
<field>
<name>pixelSpecular</name>
<desc>This enables per-pixel specular highlights controlled by the alpha channel of the normal map texture.  Note that if pixel specular is enabled the DXTnm format will not work with your normal map, unless you are also using a specular map.</desc>
</field>
<field>
<name>planarReflection</name>
<desc>bool planarReflection</desc>
</field>
<field>
<name>rotPivotOffset</name>
<desc>Point2F rotPivotOffset</desc>
</field>
<field>
<name>rotSpeed</name>
<desc>float rotSpeed</desc>
</field>
<field>
<name>scrollDir</name>
<desc>Point2F scrollDir</desc>
</field>
<field>
<name>scrollSpeed</name>
<desc>float scrollSpeed</desc>
</field>
<field>
<name>sequenceFramePerSec</name>
<desc>float sequenceFramePerSec</desc>
</field>
<field>
<name>sequenceSegmentSize</name>
<desc>float sequenceSegmentSize</desc>
</field>
<field>
<name>showDust</name>
<desc>bool showDust</desc>
</field>
<field>
<name>showFootprints</name>
<desc>bool showFootprints</desc>
</field>
<field>
<name>specular</name>
<desc>ColorF specular</desc>
</field>
<field>
<name>specularMap</name>
<desc>The specular map texture. The RGB channels of this texture provide a per-pixel replacement for the 'specular' parameter on the material. If this texture contains alpha information, the alpha channel of the texture will be used as the gloss map. This provides a per-pixel replacement for the 'specularPower' on the material</desc>
</field>
<field>
<name>specularPower</name>
<desc>float specularPower</desc>
</field>
<field>
<name>subSurface</name>
<desc>bool subSurface</desc>
</field>
<field>
<name>subSurfaceColor</name>
<desc>ColorF subSurfaceColor</desc>
</field>
<field>
<name>subSurfaceRolloff</name>
<desc>float subSurfaceRolloff</desc>
</field>
<field>
<name>toneMap</name>
<desc>filename toneMap</desc>
</field>
<field>
<name>translucent</name>
<desc>bool translucent</desc>
</field>
<field>
<name>translucentBlendOp</name>
<desc>enumval translucentBlendOp</desc>
</field>
<field>
<name>translucentZWrite</name>
<desc>bool translucentZWrite</desc>
</field>
<field>
<name>vertLit</name>
<desc>bool vertLit</desc>
</field>
<field>
<name>waveAmp</name>
<desc>float waveAmp</desc>
</field>
<field>
<name>waveFreq</name>
<desc>float waveFreq</desc>
</field>
<field>
<name>waveType</name>
<desc>enumval waveType</desc>
</field>
</class>
<class>
<name>MaterialSet</name>
<base>SimSet</base>
</class>
<class>
<name>MECreateUndoAction</name>
<base>UndoAction</base>
<method>
<name>addObject</name>
<args> SimObject obj </args>
</method>
</class>
<class>
<name>MEDeleteUndoAction</name>
<base>UndoAction</base>
<method>
<name>deleteObject</name>
<args> SimObject obj </args>
</method>
</class>
<class>
<name>MenuBar</name>
<base>SimSet</base>
<method>
<name>attachToCanvas</name>
<args>GuiCanvas, pos</args>
</method>
<method>
<name>insert</name>
<args>object, pos</args>
<desc>insert object at position</desc>
</method>
<method>
<name>removeFromCanvas</name>
</method>
</class>
<class>
<name>MeshRoad</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
</method>
<method>
<name>regenerate</name>
<desc>setRegenFlag()</desc>
</method>
<method>
<name>setMetersPerSegment</name>
<args> F32 meters </args>
</method>
<method>
<name>setNodeDepth</name>
<args> U32 idx, F32 meters </args>
</method>
<field>
<name>bottomMaterial</name>
<desc>MaterialName bottomMaterial</desc>
</field>
<field>
<name>breakAngle</name>
<desc>Angle in degrees - MeshRoad will subdivide the spline if its curve is greater than this threshold.</desc>
</field>
<field>
<name>Node</name>
<desc>Do not modify, for internal use.</desc>
</field>
<field>
<name>sideMaterial</name>
<desc>MaterialName sideMaterial</desc>
</field>
<field>
<name>textureLength</name>
<desc>The length in meters of textures mapped to the MeshRoad.</desc>
</field>
<field>
<name>topMaterial</name>
<desc>MaterialName topMaterial</desc>
</field>
<field>
<name>widthSubdivisions</name>
<desc>Subdivide segments widthwise this many times when generating vertices.</desc>
</field>
</class>
<class>
<name>Message</name>
<base>SimObject</base>
<method>
<name>addReference</name>
<desc>Increment the reference count for this message</desc>
</method>
<method>
<name>freeReference</name>
<desc>Decrement the reference count for this message</desc>
</method>
<method>
<name>getType</name>
<desc>Get message type (script class name or C++ class name if no script defined class)</desc>
</method>
</class>
<class>
<name>MessageForwarder</name>
<base>ScriptMsgListener</base>
<field>
<name>toQueue</name>
<desc>Queue to forward to</desc>
</field>
</class>
<class>
<name>MessageVector</name>
<base>SimObject</base>
<method>
<name>clear</name>
<desc>Clear the message vector.</desc>
</method>
<method>
<name>deleteLine</name>
<args>int deletePos</args>
<desc>Delete the line at the specified position.</desc>
</method>
<method>
<name>dump</name>
<args>string filename, string header=NULL</args>
<desc>Dump the message vector to a file, optionally prefixing a header.</desc>
</method>
<method>
<name>getLineIndexByTag</name>
<args>int tag</args>
<desc>Scan through the vector, returning the line number of the first line that matches the specified tag; else returns -1 if no match was found.</desc>
</method>
<method>
<name>getLineTag</name>
<args>int line</args>
<desc>Get the tag of a specified line.</desc>
</method>
<method>
<name>getLineText</name>
<args>int line</args>
<desc>Get the text at a specified line.</desc>
</method>
<method>
<name>getLineTextByTag</name>
<args>int tag</args>
<desc>Scan through the lines in the vector, returning the first line that has a matching tag.</desc>
</method>
<method>
<name>getNumLines</name>
<desc>Get the number of lines in the vector.</desc>
</method>
<method>
<name>insertLine</name>
<args>int insertPos, string msg, int tag=0</args>
<desc>Insert a new line into the vector at the specified position.</desc>
</method>
<method>
<name>popBackLine</name>
<desc>Pop a line from the back of the list; destroys the line.</desc>
</method>
<method>
<name>popFrontLine</name>
<desc>Pop a line from the front of the vector, destroying the line.</desc>
</method>
<method>
<name>pushBackLine</name>
<args>string msg, int tag=0</args>
<desc>Push a line onto the back of the list.</desc>
</method>
<method>
<name>pushFrontLine</name>
<args>string msg, int tag=0</args>
<desc>Push a line onto the front of the vector.</desc>
</method>
</class>
<class>
<name>MirrorSubObject</name>
<base>SceneObject</base>
</class>
<class>
<name>MissionArea</name>
<base>NetObject</base>
<method>
<name>getArea</name>
<desc>Returns 4 fields: starting x, starting y, extents x, extents y</desc>
</method>
<method>
<name>setArea</name>
<args>int x, int y, int width, int height</args>
</method>
<field>
<name>Area</name>
<desc>RectI Area</desc>
</field>
<field>
<name>flightCeiling</name>
<desc>float flightCeiling</desc>
</field>
<field>
<name>flightCeilingRange</name>
<desc>float flightCeilingRange</desc>
</field>
</class>
<class>
<name>MissionAreaEditor</name>
<base>GuiBitmapCtrl</base>
<method>
<name>centerWorld</name>
<args>including terrain</args>
<desc>in the world so that the center of the world is the center of the mission area.</desc>
</method>
<method>
<name>getArea</name>
<desc>Return a 4-tuple: area_x area_y area_width are_height</desc>
</method>
<method>
<name>setArea</name>
<args>int x, int y, int w, int h</args>
<desc>Set the mission area to the specified co-ordinates/extents.</desc>
</method>
<method>
<name>updateTerrain</name>
<desc>Update the terrain bitmap that is rendered as background in the control.</desc>
</method>
<field>
<name>cameraColor</name>
<desc>ColorI cameraColor</desc>
</field>
<field>
<name>defaultObjectColor</name>
<desc>ColorI defaultObjectColor</desc>
</field>
<field>
<name>enableEditing</name>
<desc>bool enableEditing</desc>
</field>
<field>
<name>enableMirroring</name>
<desc>bool enableMirroring</desc>
</field>
<field>
<name>handleFillColor</name>
<desc>ColorI handleFillColor</desc>
</field>
<field>
<name>handleFrameColor</name>
<desc>ColorI handleFrameColor</desc>
</field>
<field>
<name>mirrorArrowColor</name>
<desc>ColorI mirrorArrowColor</desc>
</field>
<field>
<name>mirrorIndex</name>
<desc>int mirrorIndex</desc>
</field>
<field>
<name>mirrorLineColor</name>
<desc>ColorI mirrorLineColor</desc>
</field>
<field>
<name>missionBoundsColor</name>
<desc>ColorI missionBoundsColor</desc>
</field>
<field>
<name>renderCamera</name>
<desc>bool renderCamera</desc>
</field>
<field>
<name>squareBitmap</name>
<desc>bool squareBitmap</desc>
</field>
<field>
<name>waterObjectColor</name>
<desc>ColorI waterObjectColor</desc>
</field>
</class>
<class>
<name>MissionMarker</name>
<base>ShapeBase</base>
</class>
<class>
<name>MissionMarkerData</name>
<base>ShapeBaseData</base>
</class>
<class>
<name>MoreAdvancedComponent</name>
<base>SimComponent</base>
</class>
<class>
<name>NetConnection</name>
<base>SimGroup</base>
<method>
<name>checkMaxRate</name>
</method>
<method>
<name>clearPaths</name>
</method>
<method>
<name>connect</name>
<args>string remoteAddress</args>
<desc>Connects this NC object to the remote address.</desc>
</method>
<method>
<name>connectLocal</name>
<desc>Connects a connection to the server running in the same process.</desc>
</method>
<method>
<name>getAddress</name>
<desc>Returns the address we're connected to.</desc>
</method>
<method>
<name>getGhostID</name>
<args> S32 realID </args>
<desc>Convert a real id to the ghost id for this connection.</desc>
</method>
<method>
<name>getGhostsActive</name>
<desc>Returns number of ghosts active.</desc>
</method>
<method>
<name>getPacketLoss</name>
</method>
<method>
<name>getPing</name>
</method>
<method>
<name>resolveGhostID</name>
<args> S32 ghostID </args>
<desc>Convert a ghost id from this connection to a real id.</desc>
</method>
<method>
<name>resolveObjectFromGhostIndex</name>
<args> S32 ghostIdx</args>
<desc>Convert a ghost index from this connection to a real id.</desc>
</method>
<method>
<name>setSimulatedNetParams</name>
<args>float packetLoss, int delay</args>
</method>
<method>
<name>transmitPaths</name>
</method>
</class>
<class>
<name>NetObject</name>
<base>SimObject</base>
<method>
<name>clearScopeToClient</name>
<args>%client</args>
<desc>Undo the effects of a scopeToClient() call.</desc>
</method>
<method>
<name>getClientObject</name>
<desc>Short-Circuit-Netorking: this is only valid for a local-client / singleplayer situation.</desc>
</method>
<method>
<name>getGhostID</name>
</method>
<method>
<name>getServerObject</name>
<desc>Short-Circuit-Netorking: this is only valid for a local-client / singleplayer situation.</desc>
</method>
<method>
<name>scopeToClient</name>
<args>NetConnection %client</args>
<desc>Cause the NetObject to be forced as scoped on the specified NetConnection.</desc>
</method>
<method>
<name>setScopeAlways</name>
<desc>Always scope this object on all connections.</desc>
</method>
</class>
<class>
<name>NetStringEvent</name>
</class>
<class>
<name>OpenFileDialog</name>
<base>FileDialog</base>
<field>
<name>MultipleFiles</name>
<desc>True/False whether multiple files may be selected and returned or not</desc>
</field>
<field>
<name>MustExist</name>
<desc>True/False whether the file returned must exist or not</desc>
</field>
</class>
<class>
<name>OpenFolderDialog</name>
<base>OpenFileDialog</base>
<field>
<name>fileMustExist</name>
<desc>File that must in selected folder for it to be valid</desc>
</field>
</class>
<class>
<name>ParticleData</name>
<base>SimDataBlock</base>
<method>
<name>reload</name>
<args>void</args>
<desc>Reloads this particle</desc>
</method>
<field>
<name>animateTexture</name>
<desc>bool animateTexture</desc>
</field>
<field>
<name>animTexFrames</name>
<desc>string animTexFrames</desc>
</field>
<field>
<name>animTexName</name>
<desc>filename animTexName</desc>
</field>
<field>
<name>animTexTiling</name>
<desc>Point2I animTexTiling</desc>
</field>
<field>
<name>colors</name>
<desc>ColorF colors</desc>
</field>
<field>
<name>constantAcceleration</name>
<desc>float constantAcceleration</desc>
</field>
<field>
<name>dragCoefficient</name>
<desc>float dragCoefficient</desc>
</field>
<field>
<name>framesPerSec</name>
<desc>int framesPerSec</desc>
</field>
<field>
<name>gravityCoefficient</name>
<desc>float gravityCoefficient</desc>
</field>
<field>
<name>inheritedVelFactor</name>
<desc>float inheritedVelFactor</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>int lifetimeMS</desc>
</field>
<field>
<name>lifetimeVarianceMS</name>
<desc>int lifetimeVarianceMS</desc>
</field>
<field>
<name>sizes</name>
<desc>float sizes</desc>
</field>
<field>
<name>spinRandomMax</name>
<desc>float spinRandomMax</desc>
</field>
<field>
<name>spinRandomMin</name>
<desc>float spinRandomMin</desc>
</field>
<field>
<name>spinSpeed</name>
<desc>float spinSpeed</desc>
</field>
<field>
<name>textureCoords</name>
<desc>Point2F textureCoords</desc>
</field>
<field>
<name>textureName</name>
<desc>filename textureName</desc>
</field>
<field>
<name>times</name>
<desc>float times</desc>
</field>
<field>
<name>useInvAlpha</name>
<desc>bool useInvAlpha</desc>
</field>
<field>
<name>windCoefficient</name>
<desc>float windCoefficient</desc>
</field>
</class>
<class>
<name>ParticleEmitterData</name>
<base>GameBaseData</base>
<method>
<name>reload</name>
<args>void</args>
<desc>Reloads this emitter</desc>
</method>
<field>
<name>alignDirection</name>
<desc>Point3F alignDirection</desc>
</field>
<field>
<name>alignParticles</name>
<desc>bool alignParticles</desc>
</field>
<field>
<name>ambientFactor</name>
<desc>float ambientFactor</desc>
</field>
<field>
<name>blendStyle</name>
<desc>enumval blendStyle</desc>
</field>
<field>
<name>ejectionOffset</name>
<desc>float ejectionOffset</desc>
</field>
<field>
<name>ejectionPeriodMS</name>
<desc>int ejectionPeriodMS</desc>
</field>
<field>
<name>ejectionVelocity</name>
<desc>float ejectionVelocity</desc>
</field>
<field>
<name>highResOnly</name>
<desc>This particle system should not use the mixed-resolution renderer. If your particle system has large amounts of overdraw, consider disabling this option.</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>int lifetimeMS</desc>
</field>
<field>
<name>lifetimeVarianceMS</name>
<desc>int lifetimeVarianceMS</desc>
</field>
<field>
<name>orientOnVelocity</name>
<desc>bool orientOnVelocity</desc>
</field>
<field>
<name>orientParticles</name>
<desc>bool orientParticles</desc>
</field>
<field>
<name>overrideAdvance</name>
<desc>bool overrideAdvance</desc>
</field>
<field>
<name>particles</name>
<desc>string particles</desc>
</field>
<field>
<name>periodVarianceMS</name>
<desc>int periodVarianceMS</desc>
</field>
<field>
<name>phiReferenceVel</name>
<desc>float phiReferenceVel</desc>
</field>
<field>
<name>phiVariance</name>
<desc>float phiVariance</desc>
</field>
<field>
<name>reverseOrder</name>
<desc>bool reverseOrder</desc>
</field>
<field>
<name>softnessDistance</name>
<desc>float softnessDistance</desc>
</field>
<field>
<name>sortParticles</name>
<desc>bool sortParticles</desc>
</field>
<field>
<name>textureName</name>
<desc>filename textureName</desc>
</field>
<field>
<name>thetaMax</name>
<desc>float thetaMax</desc>
</field>
<field>
<name>thetaMin</name>
<desc>float thetaMin</desc>
</field>
<field>
<name>useEmitterColors</name>
<desc>bool useEmitterColors</desc>
</field>
<field>
<name>useEmitterSizes</name>
<desc>bool useEmitterSizes</desc>
</field>
<field>
<name>velocityVariance</name>
<desc>float velocityVariance</desc>
</field>
</class>
<class>
<name>ParticleEmitterNode</name>
<base>GameBase</base>
<method>
<name>setEmitterDataBlock</name>
<args>data</args>
</method>
<field>
<name>active</name>
<desc>bool active</desc>
</field>
<field>
<name>emitter</name>
<desc>ParticleEmitterData emitter</desc>
</field>
<field>
<name>velocity</name>
<desc>float velocity</desc>
</field>
</class>
<class>
<name>ParticleEmitterNodeData</name>
<base>GameBaseData</base>
<field>
<name>timeMultiple</name>
<desc>float timeMultiple</desc>
</field>
</class>
<class>
<name>Path</name>
<base>SimGroup</base>
<method>
<name>getPathId</name>
</method>
<field>
<name>isLooping</name>
<desc>bool isLooping</desc>
</field>
</class>
<class>
<name>PathCamera</name>
<base>ShapeBase</base>
<method>
<name>popFront</name>
</method>
<method>
<name>pushBack</name>
<args>transform,speed,type,path</args>
</method>
<method>
<name>pushFront</name>
<args>transform,speed,type,path</args>
</method>
<method>
<name>reset</name>
<args>speed=0</args>
</method>
<method>
<name>setPosition</name>
<args>pos</args>
</method>
<method>
<name>setState</name>
<args>{forward,backward,stop}</args>
</method>
<method>
<name>setTarget</name>
<args>pos</args>
</method>
</class>
<class>
<name>PathCameraData</name>
<base>ShapeBaseData</base>
</class>
<class>
<name>PathedInterior</name>
<base>GameBase</base>
<method>
<name>setPathPosition</name>
</method>
<method>
<name>setTargetPosition</name>
</method>
<field>
<name>basePosition</name>
<desc>MatrixPosition basePosition</desc>
</field>
<field>
<name>baseRotation</name>
<desc>MatrixRotation baseRotation</desc>
</field>
<field>
<name>baseScale</name>
<desc>Point3F baseScale</desc>
</field>
<field>
<name>interiorIndex</name>
<desc>int interiorIndex</desc>
</field>
<field>
<name>interiorResource</name>
<desc>filename interiorResource</desc>
</field>
</class>
<class>
<name>PathedInteriorData</name>
<base>GameBaseData</base>
<field>
<name>StartSound</name>
<desc>SFXProfile StartSound</desc>
</field>
<field>
<name>StopSound</name>
<desc>SFXProfile StopSound</desc>
</field>
<field>
<name>SustainSound</name>
<desc>SFXProfile SustainSound</desc>
</field>
</class>
<class>
<name>PathManagerEvent</name>
</class>
<class>
<name>PersistenceManager</name>
<base>SimObject</base>
<method>
<name>clearAll</name>
<desc>Clears all the tracked objects without saving them.</desc>
</method>
<method>
<name>deleteObjectsFromFile</name>
<args> fileName </args>
<desc>Delete all of the objects that are created from the given file.</desc>
</method>
<method>
<name>getDirtyObject</name>
<args> index </args>
<desc>Returns the ith dirty object.</desc>
</method>
<method>
<name>getDirtyObjectCount</name>
<desc>Returns the number of dirty objects.</desc>
</method>
<method>
<name>hasDirty</name>
<desc>Returns true if the manager has dirty objects to save.</desc>
</method>
<method>
<name>isDirty</name>
<args>SimObject object</args>
<desc>Returns true if the SimObject is on the dirty list.</desc>
</method>
<method>
<name>listDirty</name>
<desc>Prints the dirty list to the console.</desc>
</method>
<method>
<name>removeDirty</name>
<args>SimObject object</args>
<desc>Remove a SimObject from the dirty list.</desc>
</method>
<method>
<name>removeField</name>
<args>SimObject object, string fieldName</args>
<desc>Remove a specific field from an object declaration.</desc>
</method>
<method>
<name>removeObjectFromFile</name>
<args>SimObject object, [filename]</args>
<desc>Remove an existing SimObject from a file (can optionally specify a different file than                the one it was created in.</desc>
</method>
<method>
<name>saveDirty</name>
<desc>Saves all of the SimObject's on the dirty list to their respective files.</desc>
</method>
<method>
<name>saveDirtyObject</name>
<args>SimObject object</args>
<desc>Save a dirty SimObject to it's file.</desc>
</method>
<method>
<name>setDirty</name>
<args>SimObject object, [filename]</args>
<desc>Mark an existing SimObject as dirty (will be written out when saveDirty() is called).</desc>
</method>
</class>
<class>
<name>PfxVis</name>
<method>
<name>clear</name>
</method>
<method>
<name>hide</name>
</method>
<method>
<name>onWindowClosed</name>
<args> GuiWindowCtrl </args>
</method>
<method>
<name>open</name>
<args> PostEffect, [bool clear = false] </args>
</method>
<method>
<name>show</name>
</method>
</class>
<class>
<name>PhysicalZone</name>
<base>SceneObject</base>
<method>
<name>activate</name>
<desc>Activate the physical zone's effects.</desc>
</method>
<method>
<name>deactivate</name>
<desc>Deactivate the physical zone's effects.</desc>
</method>
<field>
<name>appliedForce</name>
<desc>Point3F appliedForce</desc>
</field>
<field>
<name>gravityMod</name>
<desc>float gravityMod</desc>
</field>
<field>
<name>polyhedron</name>
<desc>The polyhedron type is really a quadrilateral and consists of a cornerpoint followed by three vectors representing the edges extending from the corner.</desc>
</field>
<field>
<name>velocityMod</name>
<desc>float velocityMod</desc>
</field>
</class>
<class>
<name>Player</name>
<base>ShapeBase</base>
<method>
<name>checkDismountPoint</name>
<args>Point3F oldPos, Point3F pos</args>
</method>
<method>
<name>clearControlObject</name>
</method>
<method>
<name>getControlObject</name>
<desc>Get the current control object.</desc>
</method>
<method>
<name>getDamageLocation</name>
<args>Point3F pos</args>
</method>
<method>
<name>getState</name>
<desc>Return the current state name.</desc>
</method>
<method>
<name>setActionThread</name>
<args>string sequenceName, bool hold, bool fsp</args>
</method>
<method>
<name>setArmThread</name>
<args>string sequenceName</args>
</method>
<method>
<name>setControlObject</name>
<args>ShapeBase obj</args>
</method>
</class>
<class>
<name>PlayerData</name>
<base>ShapeBaseData</base>
<field>
<name>airControl</name>
<desc>float airControl</desc>
</field>
<field>
<name>boundingBox</name>
<desc>Point3F boundingBox</desc>
</field>
<field>
<name>boxHeadBackPercentage</name>
<desc>int boxHeadBackPercentage</desc>
</field>
<field>
<name>boxHeadFrontPercentage</name>
<desc>int boxHeadFrontPercentage</desc>
</field>
<field>
<name>boxHeadLeftPercentage</name>
<desc>int boxHeadLeftPercentage</desc>
</field>
<field>
<name>boxHeadPercentage</name>
<desc>float boxHeadPercentage</desc>
</field>
<field>
<name>boxHeadRightPercentage</name>
<desc>int boxHeadRightPercentage</desc>
</field>
<field>
<name>boxTorsoPercentage</name>
<desc>float boxTorsoPercentage</desc>
</field>
<field>
<name>bubbleEmitTime</name>
<desc>float bubbleEmitTime</desc>
</field>
<field>
<name>crouchBoundingBox</name>
<desc>Point3F crouchBoundingBox</desc>
</field>
<field>
<name>crouchForce</name>
<desc>float crouchForce</desc>
</field>
<field>
<name>DecalData</name>
<desc>DecalData DecalData</desc>
</field>
<field>
<name>decalOffset</name>
<desc>float decalOffset</desc>
</field>
<field>
<name>dustEmitter</name>
<desc>ParticleEmitterData dustEmitter</desc>
</field>
<field>
<name>exitingWater</name>
<desc>SFXProfile exitingWater</desc>
</field>
<field>
<name>exitSplashSoundVelocity</name>
<desc>float exitSplashSoundVelocity</desc>
</field>
<field>
<name>FootBubblesSound</name>
<desc>SFXProfile FootBubblesSound</desc>
</field>
<field>
<name>FootHardSound</name>
<desc>SFXProfile FootHardSound</desc>
</field>
<field>
<name>FootMetalSound</name>
<desc>SFXProfile FootMetalSound</desc>
</field>
<field>
<name>footPuffEmitter</name>
<desc>ParticleEmitterData footPuffEmitter</desc>
</field>
<field>
<name>footPuffNumParts</name>
<desc>int footPuffNumParts</desc>
</field>
<field>
<name>footPuffRadius</name>
<desc>float footPuffRadius</desc>
</field>
<field>
<name>FootShallowSound</name>
<desc>SFXProfile FootShallowSound</desc>
</field>
<field>
<name>FootSnowSound</name>
<desc>SFXProfile FootSnowSound</desc>
</field>
<field>
<name>FootSoftSound</name>
<desc>SFXProfile FootSoftSound</desc>
</field>
<field>
<name>footstepSplashHeight</name>
<desc>float footstepSplashHeight</desc>
</field>
<field>
<name>FootUnderwaterSound</name>
<desc>SFXProfile FootUnderwaterSound</desc>
</field>
<field>
<name>FootWadingSound</name>
<desc>SFXProfile FootWadingSound</desc>
</field>
<field>
<name>groundImpactMinSpeed</name>
<desc>float groundImpactMinSpeed</desc>
</field>
<field>
<name>groundImpactShakeAmp</name>
<desc>Point3F groundImpactShakeAmp</desc>
</field>
<field>
<name>groundImpactShakeDuration</name>
<desc>float groundImpactShakeDuration</desc>
</field>
<field>
<name>groundImpactShakeFalloff</name>
<desc>float groundImpactShakeFalloff</desc>
</field>
<field>
<name>groundImpactShakeFreq</name>
<desc>Point3F groundImpactShakeFreq</desc>
</field>
<field>
<name>hardSplashSoundVelocity</name>
<desc>float hardSplashSoundVelocity</desc>
</field>
<field>
<name>horizMaxSpeed</name>
<desc>float horizMaxSpeed</desc>
</field>
<field>
<name>horizResistFactor</name>
<desc>float horizResistFactor</desc>
</field>
<field>
<name>horizResistSpeed</name>
<desc>float horizResistSpeed</desc>
</field>
<field>
<name>impactHardSound</name>
<desc>SFXProfile impactHardSound</desc>
</field>
<field>
<name>impactMetalSound</name>
<desc>SFXProfile impactMetalSound</desc>
</field>
<field>
<name>impactSnowSound</name>
<desc>SFXProfile impactSnowSound</desc>
</field>
<field>
<name>impactSoftSound</name>
<desc>SFXProfile impactSoftSound</desc>
</field>
<field>
<name>impactWaterEasy</name>
<desc>SFXProfile impactWaterEasy</desc>
</field>
<field>
<name>impactWaterHard</name>
<desc>SFXProfile impactWaterHard</desc>
</field>
<field>
<name>impactWaterMedium</name>
<desc>SFXProfile impactWaterMedium</desc>
</field>
<field>
<name>jetJumpEnergyDrain</name>
<desc>float jetJumpEnergyDrain</desc>
</field>
<field>
<name>jetJumpForce</name>
<desc>float jetJumpForce</desc>
</field>
<field>
<name>jetJumpSurfaceAngle</name>
<desc>float jetJumpSurfaceAngle</desc>
</field>
<field>
<name>jetMaxJumpSpeed</name>
<desc>float jetMaxJumpSpeed</desc>
</field>
<field>
<name>jetMinJumpEnergy</name>
<desc>float jetMinJumpEnergy</desc>
</field>
<field>
<name>jetMinJumpSpeed</name>
<desc>float jetMinJumpSpeed</desc>
</field>
<field>
<name>jumpDelay</name>
<desc>int jumpDelay</desc>
</field>
<field>
<name>jumpEnergyDrain</name>
<desc>float jumpEnergyDrain</desc>
</field>
<field>
<name>jumpForce</name>
<desc>float jumpForce</desc>
</field>
<field>
<name>jumpSurfaceAngle</name>
<desc>float jumpSurfaceAngle</desc>
</field>
<field>
<name>jumpTowardsNormal</name>
<desc>bool jumpTowardsNormal</desc>
</field>
<field>
<name>maxBackwardSpeed</name>
<desc>float maxBackwardSpeed</desc>
</field>
<field>
<name>maxCrouchBackwardSpeed</name>
<desc>float maxCrouchBackwardSpeed</desc>
</field>
<field>
<name>maxCrouchForwardSpeed</name>
<desc>float maxCrouchForwardSpeed</desc>
</field>
<field>
<name>maxCrouchSideSpeed</name>
<desc>float maxCrouchSideSpeed</desc>
</field>
<field>
<name>maxForwardSpeed</name>
<desc>float maxForwardSpeed</desc>
</field>
<field>
<name>maxFreelookAngle</name>
<desc>float maxFreelookAngle</desc>
</field>
<field>
<name>maxJumpSpeed</name>
<desc>float maxJumpSpeed</desc>
</field>
<field>
<name>maxLookAngle</name>
<desc>float maxLookAngle</desc>
</field>
<field>
<name>maxProneBackwardSpeed</name>
<desc>float maxProneBackwardSpeed</desc>
</field>
<field>
<name>maxProneForwardSpeed</name>
<desc>float maxProneForwardSpeed</desc>
</field>
<field>
<name>maxProneSideSpeed</name>
<desc>float maxProneSideSpeed</desc>
</field>
<field>
<name>maxSideSpeed</name>
<desc>float maxSideSpeed</desc>
</field>
<field>
<name>maxStepHeight</name>
<desc>float maxStepHeight</desc>
</field>
<field>
<name>maxTimeScale</name>
<desc>float maxTimeScale</desc>
</field>
<field>
<name>maxUnderwaterBackwardSpeed</name>
<desc>float maxUnderwaterBackwardSpeed</desc>
</field>
<field>
<name>maxUnderwaterForwardSpeed</name>
<desc>float maxUnderwaterForwardSpeed</desc>
</field>
<field>
<name>maxUnderwaterSideSpeed</name>
<desc>float maxUnderwaterSideSpeed</desc>
</field>
<field>
<name>mediumSplashSoundVelocity</name>
<desc>float mediumSplashSoundVelocity</desc>
</field>
<field>
<name>minImpactSpeed</name>
<desc>float minImpactSpeed</desc>
</field>
<field>
<name>minJumpEnergy</name>
<desc>float minJumpEnergy</desc>
</field>
<field>
<name>minJumpSpeed</name>
<desc>float minJumpSpeed</desc>
</field>
<field>
<name>minLookAngle</name>
<desc>float minLookAngle</desc>
</field>
<field>
<name>minRunEnergy</name>
<desc>float minRunEnergy</desc>
</field>
<field>
<name>movingBubblesSound</name>
<desc>SFXProfile movingBubblesSound</desc>
</field>
<field>
<name>physicsPlayerType</name>
<desc>string physicsPlayerType</desc>
</field>
<field>
<name>pickupRadius</name>
<desc>float pickupRadius</desc>
</field>
<field>
<name>proneBoundingBox</name>
<desc>Point3F proneBoundingBox</desc>
</field>
<field>
<name>proneForce</name>
<desc>float proneForce</desc>
</field>
<field>
<name>recoverDelay</name>
<desc>int recoverDelay</desc>
</field>
<field>
<name>recoverRunForceScale</name>
<desc>float recoverRunForceScale</desc>
</field>
<field>
<name>renderFirstPerson</name>
<desc>bool renderFirstPerson</desc>
</field>
<field>
<name>runEnergyDrain</name>
<desc>float runEnergyDrain</desc>
</field>
<field>
<name>runForce</name>
<desc>float runForce</desc>
</field>
<field>
<name>runSurfaceAngle</name>
<desc>float runSurfaceAngle</desc>
</field>
<field>
<name>Splash</name>
<desc>SplashData Splash</desc>
</field>
<field>
<name>splashAngle</name>
<desc>float splashAngle</desc>
</field>
<field>
<name>splashEmitter</name>
<desc>ParticleEmitterData splashEmitter</desc>
</field>
<field>
<name>splashFreqMod</name>
<desc>float splashFreqMod</desc>
</field>
<field>
<name>splashVelEpsilon</name>
<desc>float splashVelEpsilon</desc>
</field>
<field>
<name>splashVelocity</name>
<desc>float splashVelocity</desc>
</field>
<field>
<name>swimBoundingBox</name>
<desc>Point3F swimBoundingBox</desc>
</field>
<field>
<name>swimForce</name>
<desc>float swimForce</desc>
</field>
<field>
<name>upMaxSpeed</name>
<desc>float upMaxSpeed</desc>
</field>
<field>
<name>upResistFactor</name>
<desc>float upResistFactor</desc>
</field>
<field>
<name>upResistSpeed</name>
<desc>float upResistSpeed</desc>
</field>
<field>
<name>waterBreathSound</name>
<desc>SFXProfile waterBreathSound</desc>
</field>
</class>
<class>
<name>PointLight</name>
<base>LightBase</base>
<field>
<name>radius</name>
<desc>float radius</desc>
</field>
</class>
<class>
<name>PopupMenu</name>
<base>SimObject</base>
<method>
<name>attachToMenuBar</name>
<args>GuiCanvas, pos, title</args>
</method>
<method>
<name>checkItem</name>
<args>pos, checked</args>
</method>
<method>
<name>checkRadioItem</name>
<args>firstPos, lastPos, checkPos</args>
</method>
<method>
<name>enableItem</name>
<args>pos, enabled</args>
</method>
<method>
<name>getItemCount</name>
</method>
<method>
<name>insertItem</name>
<args>pos[, title][, accelerator]</args>
</method>
<method>
<name>insertSubMenu</name>
<args>pos, title, subMenu</args>
</method>
<method>
<name>isItemChecked</name>
<args>pos</args>
</method>
<method>
<name>removeFromMenuBar</name>
</method>
<method>
<name>removeItem</name>
<args>pos</args>
</method>
<method>
<name>setItem</name>
<args>pos, title[, accelerator]</args>
</method>
<method>
<name>showPopup</name>
<args>Canvas,[x, y]</args>
</method>
<field>
<name>barTitle</name>
<desc>the title of this menu when attached to a menu bar</desc>
</field>
<field>
<name>isPopup</name>
<desc>true if this is a pop-up/context menu. defaults to false.</desc>
</field>
</class>
<class>
<name>Portal</name>
<base>Zone</base>
</class>
<class>
<name>PostEffect</name>
<base>SimGroup</base>
<method>
<name>clearShaderMacros</name>
</method>
<method>
<name>disable</name>
<desc>Disables the effect.</desc>
</method>
<method>
<name>dumpShaderDisassembly</name>
<desc>Dumps this PostEffect shader's disassembly to a temporary text file. Returns the fullpath of that file if successful.</desc>
</method>
<method>
<name>enable</name>
<desc>Enables the effect.</desc>
</method>
<method>
<name>getAspectRatio</name>
<desc>Returns width over height aspect ratio of the backbuffer.</desc>
</method>
<method>
<name>isEnabled</name>
<desc>Returns true if the effect is enabled.</desc>
</method>
<method>
<name>reload</name>
<desc>Reloads the effect shader and textures.</desc>
</method>
<method>
<name>removeShaderMacro</name>
<args> string key </args>
</method>
<method>
<name>setShaderConst</name>
<args> String name, float value </args>
</method>
<method>
<name>setShaderMacro</name>
<args> string key, [string value] </args>
<desc>- add/set a shader macro.</desc>
</method>
<method>
<name>toggle</name>
<desc>Toggles the effect state returning true if we enable it.</desc>
</method>
<field>
<name>allowReflectPass</name>
<desc>bool allowReflectPass</desc>
</field>
<field>
<name>isEnabled</name>
<desc>Toggles the effect on and off.</desc>
</field>
<field>
<name>oneFrameOnly</name>
<desc>Allows you to turn on a posteffect for only a single frame.</desc>
</field>
<field>
<name>onThisFrame</name>
<desc>Allows you to turn on a posteffect for only a single frame.</desc>
</field>
<field>
<name>renderBin</name>
<desc>String renderBin</desc>
</field>
<field>
<name>renderPriority</name>
<desc>PostEffects are processed in DESCENDING order of renderPriority if more than one has the same renderBin/Time.</desc>
</field>
<field>
<name>renderTime</name>
<desc>enumval renderTime</desc>
</field>
<field>
<name>requirements</name>
<desc>enumval requirements</desc>
</field>
<field>
<name>shader</name>
<desc>String shader</desc>
</field>
<field>
<name>skip</name>
<desc>Skip processing of this PostEffect and its children even if its parent is enabled. Parent and sibling PostEffects in the chain are still processed.</desc>
</field>
<field>
<name>stateBlock</name>
<desc>SimObjectPtr stateBlock</desc>
</field>
<field>
<name>target</name>
<desc>String target</desc>
</field>
<field>
<name>targetClear</name>
<desc>enumval targetClear</desc>
</field>
<field>
<name>targetClearColor</name>
<desc>ColorF targetClearColor</desc>
</field>
<field>
<name>targetFormat</name>
<desc>enumval targetFormat</desc>
</field>
<field>
<name>targetScale</name>
<desc>If targetSize is zero this is used to set a relative size from the current target.</desc>
</field>
<field>
<name>targetSize</name>
<desc>If non-zero this is used as the absolute target size.</desc>
</field>
<field>
<name>texture</name>
<desc>filename texture</desc>
</field>
</class>
<class>
<name>Precipitation</name>
<base>GameBase</base>
<method>
<name>modifyStorm</name>
<args>Percentage &lt;0.0 to 1.0&gt;, Time&lt;sec&gt;</args>
</method>
<method>
<name>setPercentange</name>
<args>percentage &lt;0.0 to 1.0&gt;</args>
</method>
<method>
<name>setTurbulence</name>
<args>max, speed, seconds</args>
</method>
<field>
<name>animateSplashes</name>
<desc>Check to enable splash animation on collision.</desc>
</field>
<field>
<name>boxHeight</name>
<desc>Height of precipitation box.</desc>
</field>
<field>
<name>boxWidth</name>
<desc>Width of precipitation box.</desc>
</field>
<field>
<name>doCollision</name>
<desc>Allow collision with world objects.</desc>
</field>
<field>
<name>dropAnimateMS</name>
<desc>If greater than zero, will animate the drops from the frames in the texture.</desc>
</field>
<field>
<name>dropSize</name>
<desc>Size of each drop of precipitation. This will scale the texture.</desc>
</field>
<field>
<name>fadeDist</name>
<desc>The distance at which fading of the drops begins.</desc>
</field>
<field>
<name>fadeDistEnd</name>
<desc>The distance at which fading of the particles ends.</desc>
</field>
<field>
<name>followCam</name>
<desc>Enables system to follow the camera or stay where it is placed.</desc>
</field>
<field>
<name>glowIntensity</name>
<desc>Set to 0 to disable the glow or or use it to control the intensity of each channel.</desc>
</field>
<field>
<name>hitPlayers</name>
<desc>Allow collision on player objects.</desc>
</field>
<field>
<name>hitVehicles</name>
<desc>Allow collision on vechiles.</desc>
</field>
<field>
<name>maxMass</name>
<desc>Maximum mass of a drop.</desc>
</field>
<field>
<name>maxSpeed</name>
<desc>Maximum speed that a drop will fall.</desc>
</field>
<field>
<name>maxTurbulence</name>
<desc>Radius at which precipitation drops spiral when turbulence is enabled.</desc>
</field>
<field>
<name>minMass</name>
<desc>Minimum mass of a drop.</desc>
</field>
<field>
<name>minSpeed</name>
<desc>Minimum speed that a drop will fall.</desc>
</field>
<field>
<name>numDrops</name>
<desc>Number of drops allowed to exists in the precipitation box at any one time.</desc>
</field>
<field>
<name>Reflect</name>
<desc>This enables the precipitation to be rendered during reflection passes. This is expensive.</desc>
</field>
<field>
<name>rotateWithCamVel</name>
<desc>Enables drops to rotate to face camera.</desc>
</field>
<field>
<name>splashMS</name>
<desc>Life of splashes in millisecons.</desc>
</field>
<field>
<name>splashSize</name>
<desc>Size of each splash animation for when a drop collides.</desc>
</field>
<field>
<name>turbulenceSpeed</name>
<desc>Speed at which precipitation drops spiral when turbulence is enabled.</desc>
</field>
<field>
<name>useLighting</name>
<desc>Check to enable shading of the drops and splashes by the sun color.</desc>
</field>
<field>
<name>useTrueBillboards</name>
<desc>Check to make drops true (non axis-aligned) billboards.</desc>
</field>
<field>
<name>useTurbulence</name>
<desc>Check to enable turubulence. This causes precipitation drops to spiral while falling.</desc>
</field>
<field>
<name>useWind</name>
<desc>Check to have the Sky property windSpeed affect precipitation.</desc>
</field>
</class>
<class>
<name>PrecipitationData</name>
<base>GameBaseData</base>
<field>
<name>dropShader</name>
<desc>string dropShader</desc>
</field>
<field>
<name>dropsPerSide</name>
<desc>int dropsPerSide</desc>
</field>
<field>
<name>dropTexture</name>
<desc>filename dropTexture</desc>
</field>
<field>
<name>soundProfile</name>
<desc>SFXProfile soundProfile</desc>
</field>
<field>
<name>splashesPerSide</name>
<desc>int splashesPerSide</desc>
</field>
<field>
<name>splashShader</name>
<desc>string splashShader</desc>
</field>
<field>
<name>splashTexture</name>
<desc>filename splashTexture</desc>
</field>
</class>
<class>
<name>Projectile</name>
<base>GameBase</base>
<field>
<name>initialPosition</name>
<desc>Point3F initialPosition</desc>
</field>
<field>
<name>initialVelocity</name>
<desc>Point3F initialVelocity</desc>
</field>
<field>
<name>sourceObject</name>
<desc>int sourceObject</desc>
</field>
<field>
<name>sourceSlot</name>
<desc>int sourceSlot</desc>
</field>
</class>
<class>
<name>ProjectileData</name>
<base>GameBaseData</base>
<field>
<name>armingDelay</name>
<desc>Milliseconds, values will be adjusted to fit 32 millisecond tick intervals</desc>
</field>
<field>
<name>bounceElasticity</name>
<desc>float bounceElasticity</desc>
</field>
<field>
<name>bounceFriction</name>
<desc>float bounceFriction</desc>
</field>
<field>
<name>decal</name>
<desc>DecalData decal</desc>
</field>
<field>
<name>Explosion</name>
<desc>ExplosionData Explosion</desc>
</field>
<field>
<name>fadeDelay</name>
<desc>Milliseconds, values will be adjusted to fit 32 millisecond tick intervals</desc>
</field>
<field>
<name>gravityMod</name>
<desc>float gravityMod</desc>
</field>
<field>
<name>impactForce</name>
<desc>float impactForce</desc>
</field>
<field>
<name>isBallistic</name>
<desc>bool isBallistic</desc>
</field>
<field>
<name>lifetime</name>
<desc>Milliseconds, values will be adjusted to fit 32 millisecond tick intervals</desc>
</field>
<field>
<name>lightDesc</name>
<desc>LightDescription lightDesc</desc>
</field>
<field>
<name>muzzleVelocity</name>
<desc>float muzzleVelocity</desc>
</field>
<field>
<name>particleEmitter</name>
<desc>ParticleEmitterData particleEmitter</desc>
</field>
<field>
<name>particleWaterEmitter</name>
<desc>ParticleEmitterData particleWaterEmitter</desc>
</field>
<field>
<name>projectileShapeName</name>
<desc>filename projectileShapeName</desc>
</field>
<field>
<name>scale</name>
<desc>Point3F scale</desc>
</field>
<field>
<name>Sound</name>
<desc>SFXProfile Sound</desc>
</field>
<field>
<name>Splash</name>
<desc>SplashData Splash</desc>
</field>
<field>
<name>velInheritFactor</name>
<desc>float velInheritFactor</desc>
</field>
<field>
<name>waterExplosion</name>
<desc>ExplosionData waterExplosion</desc>
</field>
</class>
<class>
<name>ReflectorDesc</name>
<base>SimDataBlock</base>
<field>
<name>detailAdjust</name>
<desc>float detailAdjust</desc>
</field>
<field>
<name>farDist</name>
<desc>float farDist</desc>
</field>
<field>
<name>maxRateMs</name>
<desc>int maxRateMs</desc>
</field>
<field>
<name>nearDist</name>
<desc>float nearDist</desc>
</field>
<field>
<name>objectTypeMask</name>
<desc>int objectTypeMask</desc>
</field>
<field>
<name>priority</name>
<desc>float priority</desc>
</field>
<field>
<name>texSize</name>
<desc>int texSize</desc>
</field>
<field>
<name>useOcclusionQuery</name>
<desc>bool useOcclusionQuery</desc>
</field>
</class>
<class>
<name>RemoteCommandEvent</name>
</class>
<class>
<name>RenderBinManager</name>
<base>SimObject</base>
<method>
<name>getBinType</name>
<desc>Returns the type of manager.</desc>
</method>
<field>
<name>binType</name>
<desc>String binType</desc>
</field>
<field>
<name>processAddOrder</name>
<desc>float processAddOrder</desc>
</field>
<field>
<name>renderOrder</name>
<desc>float renderOrder</desc>
</field>
</class>
<class>
<name>RenderFormatToken</name>
<base>RenderPassStateToken</base>
<field>
<name>aaLevel</name>
<desc>Anti-ailiasing level for the this token. 0 disables, -1 uses adapter default.</desc>
</field>
<field>
<name>copyEffect</name>
<desc>This PostEffect will be run when the render target is changed to the format specified by this token. It is used to copy/format data into the token rendertarget</desc>
</field>
<field>
<name>depthFormat</name>
<desc>Sets the depth/stencil buffer format for this token.</desc>
</field>
<field>
<name>format</name>
<desc>Sets the color buffer format for this token.</desc>
</field>
<field>
<name>resolveEffect</name>
<desc>This PostEffect will be run when the render target is changed back to the format active prior to this token. It is used to copy/format data from the token rendertarget to the backbuffer.</desc>
</field>
</class>
<class>
<name>RenderGlowMgr</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>RenderImposterMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderMeshExample</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
</method>
<field>
<name>Material</name>
<desc>MaterialName Material</desc>
</field>
</class>
<class>
<name>RenderMeshMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderObjectExample</name>
<base>SceneObject</base>
</class>
<class>
<name>RenderObjectMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderOcclusionMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderParticleMgr</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>RenderPassManager</name>
<base>SimObject</base>
<method>
<name>addManager</name>
<desc>Add a manager.</desc>
</method>
<method>
<name>getManager</name>
<desc>Get the manager at index.</desc>
</method>
<method>
<name>getManagerCount</name>
<desc>Returns the total number of bin managers.</desc>
</method>
<method>
<name>removeManager</name>
<desc>Removes a manager by name.</desc>
</method>
</class>
<class>
<name>RenderPassStateBin</name>
<base>RenderBinManager</base>
<field>
<name>stateToken</name>
<desc>SimObjectPtr stateToken</desc>
</field>
</class>
<class>
<name>RenderPassStateToken</name>
<base>SimObject</base>
<method>
<name>disable</name>
</method>
<method>
<name>enable</name>
</method>
<method>
<name>toggle</name>
</method>
<field>
<name>enabled</name>
<desc>Enables or disables this token.</desc>
</field>
</class>
<class>
<name>RenderPrePassMgr</name>
<base>RenderTexTargetBinManager</base>
</class>
<class>
<name>RenderShapeExample</name>
<base>SceneObject</base>
<field>
<name>shapeFile</name>
<desc>filename shapeFile</desc>
</field>
</class>
<class>
<name>RenderTerrainMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderTexTargetBinManager</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RenderTranslucentMgr</name>
<base>RenderBinManager</base>
</class>
<class>
<name>RigidShape</name>
<base>ShapeBase</base>
<method>
<name>freezeSim</name>
</method>
<method>
<name>reset</name>
</method>
</class>
<class>
<name>RigidShapeData</name>
<base>ShapeBaseData</base>
<field>
<name>bodyFriction</name>
<desc>float bodyFriction</desc>
</field>
<field>
<name>bodyRestitution</name>
<desc>float bodyRestitution</desc>
</field>
<field>
<name>cameraDecay</name>
<desc>float cameraDecay</desc>
</field>
<field>
<name>cameraLag</name>
<desc>float cameraLag</desc>
</field>
<field>
<name>cameraOffset</name>
<desc>float cameraOffset</desc>
</field>
<field>
<name>cameraRoll</name>
<desc>bool cameraRoll</desc>
</field>
<field>
<name>collisionTol</name>
<desc>float collisionTol</desc>
</field>
<field>
<name>contactTol</name>
<desc>float contactTol</desc>
</field>
<field>
<name>dragForce</name>
<desc>float dragForce</desc>
</field>
<field>
<name>dustEmitter</name>
<desc>ParticleEmitterData dustEmitter</desc>
</field>
<field>
<name>dustHeight</name>
<desc>float dustHeight</desc>
</field>
<field>
<name>dustTrailEmitter</name>
<desc>ParticleEmitterData dustTrailEmitter</desc>
</field>
<field>
<name>dustTrailFreqMod</name>
<desc>float dustTrailFreqMod</desc>
</field>
<field>
<name>dustTrailOffset</name>
<desc>Point3F dustTrailOffset</desc>
</field>
<field>
<name>exitingWater</name>
<desc>SFXProfile exitingWater</desc>
</field>
<field>
<name>exitSplashSoundVelocity</name>
<desc>float exitSplashSoundVelocity</desc>
</field>
<field>
<name>hardImpactSound</name>
<desc>SFXProfile hardImpactSound</desc>
</field>
<field>
<name>hardImpactSpeed</name>
<desc>float hardImpactSpeed</desc>
</field>
<field>
<name>hardSplashSoundVelocity</name>
<desc>float hardSplashSoundVelocity</desc>
</field>
<field>
<name>impactWaterEasy</name>
<desc>SFXProfile impactWaterEasy</desc>
</field>
<field>
<name>impactWaterHard</name>
<desc>SFXProfile impactWaterHard</desc>
</field>
<field>
<name>impactWaterMedium</name>
<desc>SFXProfile impactWaterMedium</desc>
</field>
<field>
<name>integration</name>
<desc>int integration</desc>
</field>
<field>
<name>massBox</name>
<desc>Point3F massBox</desc>
</field>
<field>
<name>massCenter</name>
<desc>Point3F massCenter</desc>
</field>
<field>
<name>maxDrag</name>
<desc>float maxDrag</desc>
</field>
<field>
<name>mediumSplashSoundVelocity</name>
<desc>float mediumSplashSoundVelocity</desc>
</field>
<field>
<name>minDrag</name>
<desc>float minDrag</desc>
</field>
<field>
<name>minImpactSpeed</name>
<desc>float minImpactSpeed</desc>
</field>
<field>
<name>minRollSpeed</name>
<desc>float minRollSpeed</desc>
</field>
<field>
<name>normalForce</name>
<desc>float normalForce</desc>
</field>
<field>
<name>pitchForce</name>
<desc>float pitchForce</desc>
</field>
<field>
<name>restorativeForce</name>
<desc>float restorativeForce</desc>
</field>
<field>
<name>rollForce</name>
<desc>float rollForce</desc>
</field>
<field>
<name>softImpactSound</name>
<desc>SFXProfile softImpactSound</desc>
</field>
<field>
<name>softImpactSpeed</name>
<desc>float softImpactSpeed</desc>
</field>
<field>
<name>softSplashSoundVelocity</name>
<desc>float softSplashSoundVelocity</desc>
</field>
<field>
<name>splashEmitter</name>
<desc>ParticleEmitterData splashEmitter</desc>
</field>
<field>
<name>splashFreqMod</name>
<desc>float splashFreqMod</desc>
</field>
<field>
<name>splashVelEpsilon</name>
<desc>float splashVelEpsilon</desc>
</field>
<field>
<name>triggerDustHeight</name>
<desc>float triggerDustHeight</desc>
</field>
<field>
<name>triggerTrailHeight</name>
<desc>float triggerTrailHeight</desc>
</field>
<field>
<name>vertFactor</name>
<desc>float vertFactor</desc>
</field>
<field>
<name>waterWakeSound</name>
<desc>SFXProfile waterWakeSound</desc>
</field>
</class>
<class>
<name>River</name>
<base>SceneObject</base>
<method>
<name>regenerate</name>
<desc>setRegenFlag()</desc>
</method>
<method>
<name>setBatchSize</name>
<args> U32 size </args>
</method>
<method>
<name>setMaxDivisionSize</name>
<args> F32 meters </args>
</method>
<method>
<name>setMetersPerSegment</name>
<args> F32 meters </args>
</method>
<method>
<name>setNodeDepth</name>
<args> U32 idx, F32 meters </args>
</method>
<field>
<name>BaseColor</name>
<desc>Changes color of water fog.</desc>
</field>
<field>
<name>clarity</name>
<desc>Relative opacity or transparency of the water surface.</desc>
</field>
<field>
<name>cubemap</name>
<desc>Cubemap used instead of reflection texture if fullReflect is off.</desc>
</field>
<field>
<name>density</name>
<desc>Affects buoyancy of an object, thus affecting the Z velocity of a player (jumping, falling, etc.</desc>
</field>
<field>
<name>distortEndDist</name>
<desc>Max distance that distortion algorithm is performed. The lower, the more distorted the effect.</desc>
</field>
<field>
<name>distortFullDepth</name>
<desc>Determines the scaling down of distortion in shallow water.</desc>
</field>
<field>
<name>distortStartDist</name>
<desc>Determines start of distortion effect where water surface intersects the camera near plane.</desc>
</field>
<field>
<name>FlowMagnitude</name>
<desc>float FlowMagnitude</desc>
</field>
<field>
<name>foamColorModulate</name>
<desc>An RGB value taht linearly interpolates between the base foam color and ambient color so there are not bright white white colors during inappropriate situations, such as night.</desc>
</field>
<field>
<name>foamMaxDepth</name>
<desc>Controls how deep foam will be visible from underwater.</desc>
</field>
<field>
<name>foamScale</name>
<desc>Size of the foam generated by WaterBlock hitting shore.</desc>
</field>
<field>
<name>foamTex</name>
<desc>Diffuse texture for foam in shallow water (advanced lighting only)</desc>
</field>
<field>
<name>fresnelBias</name>
<desc>Extent of fresnel affecting reflection fogging.</desc>
</field>
<field>
<name>fresnelPower</name>
<desc>Measures intensity of affect on reflection based on fogging.</desc>
</field>
<field>
<name>fullReflect</name>
<desc>Enables dynamic reflection rendering.</desc>
</field>
<field>
<name>liquidType</name>
<desc>Liquid type of WaterBlock, such as water, ocean, lava Currently only Water is defined and used.</desc>
</field>
<field>
<name>LowLODDistance</name>
<desc>float LowLODDistance</desc>
</field>
<field>
<name>Node</name>
<desc>For internal use, do not modify.</desc>
</field>
<field>
<name>overallRippleMagnitude</name>
<desc>Master variable affecting entire surface</desc>
</field>
<field>
<name>overallWaveMagnitude</name>
<desc>Master variable affecting entire body of water's undulation</desc>
</field>
<field>
<name>reflectDetailAdjust</name>
<desc>scale up or down the detail level for objects rendered in a reflection</desc>
</field>
<field>
<name>reflectMaxRateMs</name>
<desc>Affects the sort time of reflected objects.</desc>
</field>
<field>
<name>reflectNormalUp</name>
<desc>always use z up as the reflection normal</desc>
</field>
<field>
<name>reflectPriority</name>
<desc>Affects the sort order of reflected objects.</desc>
</field>
<field>
<name>reflectTexSize</name>
<desc>The texture size used for reflections (square)</desc>
</field>
<field>
<name>rippleDir</name>
<desc>Modifies the direction of ripples on the surface.</desc>
</field>
<field>
<name>rippleMagnitude</name>
<desc>Intensifies the vertext modification of the surface.</desc>
</field>
<field>
<name>rippleSpeed</name>
<desc>Modifies speed of surface ripples.</desc>
</field>
<field>
<name>rippleTex</name>
<desc>Normal map used to simulate small surface ripples</desc>
</field>
<field>
<name>rippleTexScale</name>
<desc>Intensifies the affect of the normal map applied to the surface.</desc>
</field>
<field>
<name>SegmentLength</name>
<desc>float SegmentLength</desc>
</field>
<field>
<name>SubdivideLength</name>
<desc>float SubdivideLength</desc>
</field>
<field>
<name>underwaterColor</name>
<desc>Changes the color shading of objects beneath the water surface.</desc>
</field>
<field>
<name>useOcclusionQuery</name>
<desc>turn off reflection rendering when occluded (delayed).</desc>
</field>
<field>
<name>viscosity</name>
<desc>Affects drag force applied to an object submerged in this container.</desc>
</field>
<field>
<name>waterFogDensity</name>
<desc>Intensity of underwater fogging.</desc>
</field>
<field>
<name>waterFogDensityOffset</name>
<desc>Delta, or limit, applied to waterFogDensity.</desc>
</field>
<field>
<name>waveDir</name>
<desc>Direction waves flow toward shores.</desc>
</field>
<field>
<name>waveMagnitude</name>
<desc>Height of water undulation.</desc>
</field>
<field>
<name>waveSpeed</name>
<desc>Speed of water undulation.</desc>
</field>
<field>
<name>wetDarkening</name>
<desc>The refract color intensity scaled at wetDepth.</desc>
</field>
<field>
<name>wetDepth</name>
<desc>The depth in world units at which full darkening will be received, giving a wet look to objects underwater.</desc>
</field>
</class>
<class>
<name>RootGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>SaveFileDialog</name>
<base>FileDialog</base>
<field>
<name>OverwritePrompt</name>
<desc>True/False whether the dialog should prompt before accepting an existing file name</desc>
</field>
</class>
<class>
<name>ScatterSky</name>
<base>SceneObject</base>
<method>
<name>applyChanges</name>
<desc>Apply a full network update of all fields to all clients.</desc>
</method>
<field>
<name>ambientScale</name>
<desc>ColorF ambientScale</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>azimuth</name>
<desc>The horizontal angle of the sun measured clockwise from the positive Y world axis. This field is networked.</desc>
</field>
<field>
<name>brightness</name>
<desc>The brightness of the ScatterSky's light object.</desc>
</field>
<field>
<name>castShadows</name>
<desc>bool castShadows</desc>
</field>
<field>
<name>elevation</name>
<desc>The elevation angle of the sun above or below the horizon. This field is networked.</desc>
</field>
<field>
<name>exposure</name>
<desc>float exposure</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>float flareScale</desc>
</field>
<field>
<name>flareType</name>
<desc>LightFlareData flareType</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>mieScattering</name>
<desc>float mieScattering</desc>
</field>
<field>
<name>moonEnabled</name>
<desc>bool moonEnabled</desc>
</field>
<field>
<name>moonScale</name>
<desc>float moonScale</desc>
</field>
<field>
<name>moonTexture</name>
<desc>filename moonTexture</desc>
</field>
<field>
<name>moonTint</name>
<desc>ColorF moonTint</desc>
</field>
<field>
<name>nightColor</name>
<desc>ColorF nightColor</desc>
</field>
<field>
<name>nightCubemap</name>
<desc>CubemapName nightCubemap</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>rayleighScattering</name>
<desc>float rayleighScattering</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>skyBrightness</name>
<desc>float skyBrightness</desc>
</field>
<field>
<name>splitFadeDistances</name>
<desc>Distances (in world space units) that the shadows will fade between PSSM splits</desc>
</field>
<field>
<name>sunScale</name>
<desc>ColorF sunScale</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
<field>
<name>useNightCubemap</name>
<desc>bool useNightCubemap</desc>
</field>
</class>
<class>
<name>SceneObject</name>
<base>NetObject</base>
<method>
<name>getEulerRotation</name>
<desc>Get Euler rotation of object.</desc>
</method>
<method>
<name>getForwardVector</name>
<desc>Returns a vector indicating the direction this object is facing.</desc>
</method>
<method>
<name>getMountedObject</name>
<args>int slot</args>
</method>
<method>
<name>getMountedObjectCount</name>
</method>
<method>
<name>getMountedObjectNode</name>
<args>int node</args>
</method>
<method>
<name>getMountNodeObject</name>
<args>int node</args>
</method>
<method>
<name>getObjectBox</name>
<desc>Returns the bounding box relative to the object's origin.</desc>
</method>
<method>
<name>getObjectMount</name>
<desc>Returns the SceneObject we're mounted on.</desc>
</method>
<method>
<name>getPosition</name>
<desc>Get position of object.</desc>
</method>
<method>
<name>getScale</name>
<desc>Get scaling as a Point3F.</desc>
</method>
<method>
<name>getTransform</name>
<desc>Get transform of object.</desc>
</method>
<method>
<name>getWorldBox</name>
<desc>Returns six fields, two Point3Fs, containing the min and max points of the worldbox.</desc>
</method>
<method>
<name>getWorldBoxCenter</name>
<desc>Returns the center of the world bounding box.</desc>
</method>
<method>
<name>isGlobalBounds</name>
<desc>Returns true if the object has a global bounds.</desc>
</method>
<method>
<name>isMounted</name>
<desc>Are we mounted?</desc>
</method>
<method>
<name>mountObject</name>
<args> SceneObject object, int slot </args>
<desc>Mount ourselves on an object in the specified slot.</desc>
</method>
<method>
<name>setScale</name>
<args>Point3F scale</args>
</method>
<method>
<name>setTransform</name>
<args>Transform T</args>
</method>
<method>
<name>unmount</name>
<desc>Unmount from the currently mounted object if any.</desc>
</method>
<method>
<name>unmountObject</name>
<args>SceneObject obj</args>
<desc>Unmount an object from ourselves.</desc>
</method>
<field>
<name>position</name>
<desc>Object world position.</desc>
</field>
<field>
<name>rotation</name>
<desc>Object world orientation.</desc>
</field>
<field>
<name>scale</name>
<desc>Object world scale.</desc>
</field>
</class>
<class>
<name>ScopeAlwaysShape</name>
<base>StaticShape</base>
</class>
<class>
<name>ScriptGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>ScriptMsgListener</name>
<base>SimObject</base>
</class>
<class>
<name>ScriptObject</name>
<base>SimObject</base>
</class>
<class>
<name>SetMissionCRCEvent</name>
</class>
<class>
<name>Settings</name>
<base>SimObject</base>
<method>
<name>beginGroup</name>
<args>groupName, fromStart = false</args>
</method>
<method>
<name>clearGroups</name>
</method>
<method>
<name>endGroup</name>
</method>
<method>
<name>getCurrentGroups</name>
</method>
<method>
<name>read</name>
</method>
<method>
<name>remove</name>
<args>settingName</args>
</method>
<method>
<name>setDefaultValue</name>
<args>settingName, value</args>
</method>
<method>
<name>setValue</name>
<args>settingName, value</args>
</method>
<method>
<name>value</name>
<args>settingName, defaultValue</args>
</method>
<method>
<name>write</name>
</method>
<field>
<name>file</name>
<desc>The file path and name to be saved to and loaded from.</desc>
</field>
</class>
<class>
<name>SFXDescription</name>
<base>SimDataBlock</base>
<field>
<name>channel</name>
<desc>int channel</desc>
</field>
<field>
<name>coneInsideAngle</name>
<desc>int coneInsideAngle</desc>
</field>
<field>
<name>coneOutsideAngle</name>
<desc>int coneOutsideAngle</desc>
</field>
<field>
<name>coneOutsideVolume</name>
<desc>float coneOutsideVolume</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>float fadeInTime</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>float fadeOutTime</desc>
</field>
<field>
<name>is3D</name>
<desc>bool is3D</desc>
</field>
<field>
<name>isLooping</name>
<desc>bool isLooping</desc>
</field>
<field>
<name>isStreaming</name>
<desc>bool isStreaming</desc>
</field>
<field>
<name>maxDistance</name>
<desc>float maxDistance</desc>
</field>
<field>
<name>pitch</name>
<desc>float pitch</desc>
</field>
<field>
<name>referenceDistance</name>
<desc>float referenceDistance</desc>
</field>
<field>
<name>streamPacketSize</name>
<desc>int streamPacketSize</desc>
</field>
<field>
<name>streamReadAhead</name>
<desc>int streamReadAhead</desc>
</field>
<field>
<name>volume</name>
<desc>float volume</desc>
</field>
</class>
<class>
<name>SFXEmitter</name>
<base>SceneObject</base>
<method>
<name>getPlaybackStatus</name>
<desc>- Return the playback status of the emitter's sound.</desc>
</method>
<method>
<name>isInRange</name>
<args> vector pos </args>
<desc>- Return true if the emitter is currently in range of the listener.</desc>
</method>
<method>
<name>play</name>
<desc>Sends network event to start playback if the emitter source is not already playing.</desc>
</method>
<method>
<name>stop</name>
<desc>Sends network event to stop emitter playback on all ghosted clients.</desc>
</method>
<field>
<name>channel</name>
<desc>int channel</desc>
</field>
<field>
<name>coneInsideAngle</name>
<desc>int coneInsideAngle</desc>
</field>
<field>
<name>coneOutsideAngle</name>
<desc>int coneOutsideAngle</desc>
</field>
<field>
<name>coneOutsideVolume</name>
<desc>float coneOutsideVolume</desc>
</field>
<field>
<name>fadeInTime</name>
<desc>float fadeInTime</desc>
</field>
<field>
<name>fadeOutTime</name>
<desc>float fadeOutTime</desc>
</field>
<field>
<name>fileName</name>
<desc>filename fileName</desc>
</field>
<field>
<name>is3D</name>
<desc>bool is3D</desc>
</field>
<field>
<name>isLooping</name>
<desc>bool isLooping</desc>
</field>
<field>
<name>isStreaming</name>
<desc>bool isStreaming</desc>
</field>
<field>
<name>maxDistance</name>
<desc>float maxDistance</desc>
</field>
<field>
<name>pitch</name>
<desc>float pitch</desc>
</field>
<field>
<name>playOnAdd</name>
<desc>bool playOnAdd</desc>
</field>
<field>
<name>Profile</name>
<desc>SFXProfile Profile</desc>
</field>
<field>
<name>referenceDistance</name>
<desc>float referenceDistance</desc>
</field>
<field>
<name>volume</name>
<desc>float volume</desc>
</field>
</class>
<class>
<name>SFXEnvironment</name>
<base>SimDataBlock</base>
</class>
<class>
<name>SFXProfile</name>
<base>SimDataBlock</base>
<method>
<name>getSoundDuration</name>
<desc>@return Returns the length of the sound in seconds.</desc>
</method>
<field>
<name>description</name>
<desc>SFXDescription description</desc>
</field>
<field>
<name>fileName</name>
<desc>filename fileName</desc>
</field>
<field>
<name>preload</name>
<desc>bool preload</desc>
</field>
</class>
<class>
<name>SFXSource</name>
<base>SimObject</base>
<method>
<name>addMarker</name>
<args> string name, float pos </args>
<desc>- Add a notification marker called 'name' at 'pos' seconds of playback.</desc>
</method>
<method>
<name>getChannel</name>
<desc>- Returns the volume channel.</desc>
</method>
<method>
<name>getDuration</name>
<desc>- Get the total playback time in seconds.</desc>
</method>
<method>
<name>getPosition</name>
<desc>- Returns the current playback position in seconds.</desc>
</method>
<method>
<name>getStatus</name>
<desc>- Returns the playback status of the source.</desc>
</method>
<method>
<name>isPaused</name>
<desc>- Returns true if the source is paused or false if not.</desc>
</method>
<method>
<name>isPlaying</name>
<desc>- Returns true if the source is playing or false if not.</desc>
</method>
<method>
<name>isReady</name>
<desc>- Returns true if the sound data associated with the source has been loaded.</desc>
</method>
<method>
<name>isStopped</name>
<desc>- Returns true if the source is stopped or false if not.</desc>
</method>
<method>
<name>pause</name>
<args> [float fadeOut] </args>
<desc>- Pauses playback of the source.</desc>
</method>
<method>
<name>play</name>
<args> [float fadeIn] </args>
<desc>- Starts playback of the source.</desc>
</method>
<method>
<name>setCone</name>
<args> float innerAngle, float outerAngle, float outsideVolume </args>
<desc>- Set the 3D volume cone for the sound.</desc>
</method>
<method>
<name>setPitch</name>
<args> float pitch </args>
<desc>- Scales the pitch of the source.</desc>
</method>
<method>
<name>setPosition</name>
<args> float </args>
<desc>- Set the current playback position in seconds.</desc>
</method>
<method>
<name>setTransform</name>
<args> vector pos [, vector direction ] </args>
<desc>- Set the position and orientation of a 3D SFXSource.</desc>
</method>
<method>
<name>setVolume</name>
<args> float volume </args>
<desc>- Sets the playback volume of the source.</desc>
</method>
<method>
<name>stop</name>
<args> [float fadeOut] </args>
<desc>- Ends playback of the source.</desc>
</method>
<field>
<name>statusCallback</name>
<desc>string statusCallback</desc>
</field>
</class>
<class>
<name>SFXSourceSet</name>
<base>SimSet</base>
</class>
<class>
<name>sgMissionLightingFilterSet</name>
<base>SimSet</base>
</class>
<class>
<name>ShaderData</name>
<base>SimObject</base>
<method>
<name>reload</name>
<desc>Rebuilds all the vertex and pixel shaders instances created from this ShaderData.</desc>
</method>
<field>
<name>defines</name>
<desc>String defines</desc>
</field>
<field>
<name>DXPixelShaderFile</name>
<desc>filename DXPixelShaderFile</desc>
</field>
<field>
<name>DXVertexShaderFile</name>
<desc>filename DXVertexShaderFile</desc>
</field>
<field>
<name>OGLPixelShaderFile</name>
<desc>filename OGLPixelShaderFile</desc>
</field>
<field>
<name>OGLVertexShaderFile</name>
<desc>filename OGLVertexShaderFile</desc>
</field>
<field>
<name>pixVersion</name>
<desc>float pixVersion</desc>
</field>
<field>
<name>samplerNames</name>
<desc>String samplerNames</desc>
</field>
<field>
<name>useDevicePixVersion</name>
<desc>bool useDevicePixVersion</desc>
</field>
</class>
<class>
<name>ShapeBase</name>
<base>GameBase</base>
<method>
<name>applyDamage</name>
<args>float amt</args>
</method>
<method>
<name>applyImpulse</name>
<args>Point3F Pos, VectorF vel</args>
</method>
<method>
<name>applyRepair</name>
<args>float amt</args>
</method>
<method>
<name>canCloak</name>
</method>
<method>
<name>changeMaterial</name>
<args>mapTo, fromMaterial, ToMaterial</args>
</method>
<method>
<name>dumpMeshVisibility</name>
<desc>Prints list of visible and hidden meshes to the console for debugging purposes.</desc>
</method>
<method>
<name>getAIRepairPoint</name>
<desc>Get the position at which the AI should stand to repair things.</desc>
</method>
<method>
<name>getCameraFov</name>
</method>
<method>
<name>getControllingClient</name>
<desc>Returns a GameConnection.</desc>
</method>
<method>
<name>getControllingObject</name>
</method>
<method>
<name>getDamageFlash</name>
</method>
<method>
<name>getDamageLevel</name>
</method>
<method>
<name>getDamagePercent</name>
</method>
<method>
<name>getDamageState</name>
</method>
<method>
<name>getEnergyLevel</name>
</method>
<method>
<name>getEnergyPercent</name>
</method>
<method>
<name>getEyePoint</name>
</method>
<method>
<name>getEyeTransform</name>
</method>
<method>
<name>getEyeVector</name>
</method>
<method>
<name>getImageAltTrigger</name>
<args>int slot</args>
</method>
<method>
<name>getImageAmmo</name>
<args>int slot</args>
</method>
<method>
<name>getImageLoaded</name>
<args>int slot</args>
</method>
<method>
<name>getImageSkinTag</name>
<args>int slot</args>
</method>
<method>
<name>getImageState</name>
<args>int slot</args>
</method>
<method>
<name>getImageTrigger</name>
<args>int slot</args>
</method>
<method>
<name>getLookAtPoint</name>
<args> [float distance, bitset mask] </args>
<desc>- Return look-at information as "Object HitX HitY HitZ [Material]" or empty string for no hit</desc>
</method>
<method>
<name>getModelFile</name>
<args> String </args>
</method>
<method>
<name>getMountedImage</name>
<args>int slot</args>
</method>
<method>
<name>getMountSlot</name>
<args>ShapeBaseImageData db</args>
</method>
<method>
<name>getMuzzlePoint</name>
<args>int slot</args>
</method>
<method>
<name>getMuzzleVector</name>
<args>int slot</args>
</method>
<method>
<name>getPendingImage</name>
<args>int slot</args>
</method>
<method>
<name>getRechargeRate</name>
</method>
<method>
<name>getRepairRate</name>
</method>
<method>
<name>getShapeName</name>
</method>
<method>
<name>getSkinName</name>
</method>
<method>
<name>getSlotTransform</name>
<args>int slot</args>
</method>
<method>
<name>getTargetCount</name>
</method>
<method>
<name>getTargetName</name>
</method>
<method>
<name>getVelocity</name>
</method>
<method>
<name>getWhiteOut</name>
</method>
<method>
<name>isCloaked</name>
</method>
<method>
<name>isDestroyed</name>
</method>
<method>
<name>isDisabled</name>
<desc>True if the state is not Enabled.</desc>
</method>
<method>
<name>isEnabled</name>
</method>
<method>
<name>isHidden</name>
</method>
<method>
<name>isImageFiring</name>
<args>int slot</args>
</method>
<method>
<name>isImageMounted</name>
<args>ShapeBaseImageData db</args>
</method>
<method>
<name>mountImage</name>
<args>ShapeBaseImageData image, int slot, bool loaded=true, string skinTag=NULL</args>
</method>
<method>
<name>pauseThread</name>
<args>int slot</args>
</method>
<method>
<name>playAudio</name>
<args>int slot, SFXProfile profile</args>
</method>
<method>
<name>playThread</name>
<args>int slot, string sequenceName</args>
</method>
<method>
<name>setAllMeshesHidden</name>
<args> bool forceHidden </args>
<desc>Set the hidden state on all the shape meshes.</desc>
</method>
<method>
<name>setCameraFov</name>
<args>float fov</args>
</method>
<method>
<name>setCloaked</name>
<args>bool isCloaked</args>
</method>
<method>
<name>setDamageFlash</name>
<args>float lvl</args>
</method>
<method>
<name>setDamageLevel</name>
<args>float level</args>
</method>
<method>
<name>setDamageState</name>
<args>string state</args>
</method>
<method>
<name>setDamageVector</name>
<args>Vector3F origin</args>
</method>
<method>
<name>setEnergyLevel</name>
<args>float level</args>
</method>
<method>
<name>setHidden</name>
<args>bool show</args>
</method>
<method>
<name>setImageAltTrigger</name>
<args>int slot, bool isTriggered</args>
</method>
<method>
<name>setImageAmmo</name>
<args>int slot, bool hasAmmo</args>
</method>
<method>
<name>setImageLoaded</name>
<args>int slot, bool loaded</args>
</method>
<method>
<name>setImageTrigger</name>
<args>int slot, bool isTriggered</args>
</method>
<method>
<name>setInvincibleMode</name>
<args>float time, float speed</args>
</method>
<method>
<name>setMeshHidden</name>
<args> string meshName, bool forceHidden </args>
<desc>Set the force hidden state on the named mesh.</desc>
</method>
<method>
<name>setRechargeRate</name>
<args>float rate</args>
</method>
<method>
<name>setRepairRate</name>
<args>float amt</args>
</method>
<method>
<name>setShapeName</name>
<args>string tag</args>
</method>
<method>
<name>setSkinName</name>
<args>string tag</args>
</method>
<method>
<name>setThreadDir</name>
<args>int slot, bool isForward</args>
</method>
<method>
<name>setThreadTimeScale</name>
<args> int pSlot, float pTimeScale </args>
</method>
<method>
<name>setVelocity</name>
<args>Vector3F vel</args>
</method>
<method>
<name>setWhiteOut</name>
<args>float flashLevel</args>
</method>
<method>
<name>startFade</name>
<args> int fadeTimeMS, int fadeDelayMS, bool fadeOut </args>
</method>
<method>
<name>stopAudio</name>
<args>int slot</args>
</method>
<method>
<name>stopThread</name>
<args>int slot</args>
</method>
<method>
<name>unmountImage</name>
<args>int slot</args>
</method>
</class>
<class>
<name>ShapeBaseData</name>
<base>GameBaseData</base>
<method>
<name>checkDeployPos</name>
<args>Transform xform</args>
</method>
<method>
<name>getDeployTransform</name>
<args>Point3F pos, Point3F normal</args>
</method>
<field>
<name>aiAvoidThis</name>
<desc>bool aiAvoidThis</desc>
</field>
<field>
<name>cameraDefaultFov</name>
<desc>float cameraDefaultFov</desc>
</field>
<field>
<name>cameraMaxDist</name>
<desc>float cameraMaxDist</desc>
</field>
<field>
<name>cameraMaxFov</name>
<desc>float cameraMaxFov</desc>
</field>
<field>
<name>cameraMinDist</name>
<desc>float cameraMinDist</desc>
</field>
<field>
<name>cameraMinFov</name>
<desc>float cameraMinFov</desc>
</field>
<field>
<name>computeCRC</name>
<desc>bool computeCRC</desc>
</field>
<field>
<name>cubeReflectorDesc</name>
<desc>String cubeReflectorDesc</desc>
</field>
<field>
<name>Debris</name>
<desc>DebrisData Debris</desc>
</field>
<field>
<name>debrisShapeName</name>
<desc>filename debrisShapeName</desc>
</field>
<field>
<name>density</name>
<desc>float density</desc>
</field>
<field>
<name>destroyedLevel</name>
<desc>float destroyedLevel</desc>
</field>
<field>
<name>disabledLevel</name>
<desc>float disabledLevel</desc>
</field>
<field>
<name>drag</name>
<desc>float drag</desc>
</field>
<field>
<name>Explosion</name>
<desc>ExplosionData Explosion</desc>
</field>
<field>
<name>firstPersonOnly</name>
<desc>bool firstPersonOnly</desc>
</field>
<field>
<name>hudImageName</name>
<desc>filename hudImageName</desc>
</field>
<field>
<name>hudImageNameEnemy</name>
<desc>filename hudImageNameEnemy</desc>
</field>
<field>
<name>hudImageNameFriendly</name>
<desc>filename hudImageNameFriendly</desc>
</field>
<field>
<name>hudRenderAlways</name>
<desc>bool hudRenderAlways</desc>
</field>
<field>
<name>hudRenderCenter</name>
<desc>bool hudRenderCenter</desc>
</field>
<field>
<name>hudRenderDistance</name>
<desc>bool hudRenderDistance</desc>
</field>
<field>
<name>hudRenderModulated</name>
<desc>bool hudRenderModulated</desc>
</field>
<field>
<name>hudRenderName</name>
<desc>bool hudRenderName</desc>
</field>
<field>
<name>inheritEnergyFromMount</name>
<desc>bool inheritEnergyFromMount</desc>
</field>
<field>
<name>isInvincible</name>
<desc>bool isInvincible</desc>
</field>
<field>
<name>mass</name>
<desc>float mass</desc>
</field>
<field>
<name>maxDamage</name>
<desc>float maxDamage</desc>
</field>
<field>
<name>maxEnergy</name>
<desc>float maxEnergy</desc>
</field>
<field>
<name>observeThroughObject</name>
<desc>bool observeThroughObject</desc>
</field>
<field>
<name>renderWhenDestroyed</name>
<desc>bool renderWhenDestroyed</desc>
</field>
<field>
<name>repairRate</name>
<desc>float repairRate</desc>
</field>
<field>
<name>shadowEnable</name>
<desc>bool shadowEnable</desc>
</field>
<field>
<name>shadowMaxVisibleDistance</name>
<desc>float shadowMaxVisibleDistance</desc>
</field>
<field>
<name>shadowProjectionDistance</name>
<desc>float shadowProjectionDistance</desc>
</field>
<field>
<name>shadowSize</name>
<desc>int shadowSize</desc>
</field>
<field>
<name>shadowSphereAdjust</name>
<desc>float shadowSphereAdjust</desc>
</field>
<field>
<name>shapeFile</name>
<desc>filename shapeFile</desc>
</field>
<field>
<name>underwaterExplosion</name>
<desc>ExplosionData underwaterExplosion</desc>
</field>
<field>
<name>useEyePoint</name>
<desc>bool useEyePoint</desc>
</field>
</class>
<class>
<name>ShapeBaseImageData</name>
<base>GameBaseData</base>
<field>
<name>accuFire</name>
<desc>bool accuFire</desc>
</field>
<field>
<name>casing</name>
<desc>DebrisData casing</desc>
</field>
<field>
<name>cloakable</name>
<desc>bool cloakable</desc>
</field>
<field>
<name>computeCRC</name>
<desc>bool computeCRC</desc>
</field>
<field>
<name>correctMuzzleVector</name>
<desc>bool correctMuzzleVector</desc>
</field>
<field>
<name>emap</name>
<desc>bool emap</desc>
</field>
<field>
<name>eyeOffset</name>
<desc>MatrixPosition eyeOffset</desc>
</field>
<field>
<name>eyeRotation</name>
<desc>MatrixRotation eyeRotation</desc>
</field>
<field>
<name>firstPerson</name>
<desc>bool firstPerson</desc>
</field>
<field>
<name>lightColor</name>
<desc>ColorF lightColor</desc>
</field>
<field>
<name>lightDuration</name>
<desc>Duration in SimTime of Pulsing and WeaponFire type lights.</desc>
</field>
<field>
<name>lightRadius</name>
<desc>float lightRadius</desc>
</field>
<field>
<name>lightType</name>
<desc>enumval lightType</desc>
</field>
<field>
<name>mass</name>
<desc>float mass</desc>
</field>
<field>
<name>maxConcurrentSounds</name>
<desc>int maxConcurrentSounds</desc>
</field>
<field>
<name>minEnergy</name>
<desc>float minEnergy</desc>
</field>
<field>
<name>mountPoint</name>
<desc>int mountPoint</desc>
</field>
<field>
<name>offset</name>
<desc>MatrixPosition offset</desc>
</field>
<field>
<name>Projectile</name>
<desc>ProjectileData Projectile</desc>
</field>
<field>
<name>rotation</name>
<desc>MatrixRotation rotation</desc>
</field>
<field>
<name>shapeFile</name>
<desc>filename shapeFile</desc>
</field>
<field>
<name>shellExitDir</name>
<desc>Point3F shellExitDir</desc>
</field>
<field>
<name>shellExitVariance</name>
<desc>float shellExitVariance</desc>
</field>
<field>
<name>shellVelocity</name>
<desc>float shellVelocity</desc>
</field>
<field>
<name>stateAllowImageChange</name>
<desc>bool stateAllowImageChange</desc>
</field>
<field>
<name>stateDirection</name>
<desc>bool stateDirection</desc>
</field>
<field>
<name>stateEjectShell</name>
<desc>bool stateEjectShell</desc>
</field>
<field>
<name>stateEmitter</name>
<desc>ParticleEmitterData stateEmitter</desc>
</field>
<field>
<name>stateEmitterNode</name>
<desc>string stateEmitterNode</desc>
</field>
<field>
<name>stateEmitterTime</name>
<desc>float stateEmitterTime</desc>
</field>
<field>
<name>stateEnergyDrain</name>
<desc>float stateEnergyDrain</desc>
</field>
<field>
<name>stateFire</name>
<desc>bool stateFire</desc>
</field>
<field>
<name>stateIgnoreLoadedForReady</name>
<desc>bool stateIgnoreLoadedForReady</desc>
</field>
<field>
<name>stateLoadedFlag</name>
<desc>enumval stateLoadedFlag</desc>
</field>
<field>
<name>stateName</name>
<desc>caseString stateName</desc>
</field>
<field>
<name>stateRecoil</name>
<desc>enumval stateRecoil</desc>
</field>
<field>
<name>stateScaleAnimation</name>
<desc>bool stateScaleAnimation</desc>
</field>
<field>
<name>stateScript</name>
<desc>caseString stateScript</desc>
</field>
<field>
<name>stateSequence</name>
<desc>string stateSequence</desc>
</field>
<field>
<name>stateSequenceRandomFlash</name>
<desc>bool stateSequenceRandomFlash</desc>
</field>
<field>
<name>stateSound</name>
<desc>SFXProfile stateSound</desc>
</field>
<field>
<name>stateSpinThread</name>
<desc>enumval stateSpinThread</desc>
</field>
<field>
<name>stateTimeoutValue</name>
<desc>float stateTimeoutValue</desc>
</field>
<field>
<name>stateTransitionOnAltTriggerDown</name>
<desc>string stateTransitionOnAltTriggerDown</desc>
</field>
<field>
<name>stateTransitionOnAltTriggerUp</name>
<desc>string stateTransitionOnAltTriggerUp</desc>
</field>
<field>
<name>stateTransitionOnAmmo</name>
<desc>string stateTransitionOnAmmo</desc>
</field>
<field>
<name>stateTransitionOnLoaded</name>
<desc>string stateTransitionOnLoaded</desc>
</field>
<field>
<name>stateTransitionOnNoAmmo</name>
<desc>string stateTransitionOnNoAmmo</desc>
</field>
<field>
<name>stateTransitionOnNoTarget</name>
<desc>string stateTransitionOnNoTarget</desc>
</field>
<field>
<name>stateTransitionOnNotLoaded</name>
<desc>string stateTransitionOnNotLoaded</desc>
</field>
<field>
<name>stateTransitionOnNotWet</name>
<desc>string stateTransitionOnNotWet</desc>
</field>
<field>
<name>stateTransitionOnTarget</name>
<desc>string stateTransitionOnTarget</desc>
</field>
<field>
<name>stateTransitionOnTimeout</name>
<desc>string stateTransitionOnTimeout</desc>
</field>
<field>
<name>stateTransitionOnTriggerDown</name>
<desc>string stateTransitionOnTriggerDown</desc>
</field>
<field>
<name>stateTransitionOnTriggerUp</name>
<desc>string stateTransitionOnTriggerUp</desc>
</field>
<field>
<name>stateTransitionOnWet</name>
<desc>string stateTransitionOnWet</desc>
</field>
<field>
<name>stateWaitForTimeout</name>
<desc>bool stateWaitForTimeout</desc>
</field>
<field>
<name>usesEnergy</name>
<desc>bool usesEnergy</desc>
</field>
</class>
<class>
<name>Sim2DAudioEvent</name>
</class>
<class>
<name>Sim3DAudioEvent</name>
</class>
<class>
<name>SimComponent</name>
<base>NetObject</base>
<method>
<name>addComponents</name>
<args> %compObjName, %compObjName2, ... </args>
</method>
<method>
<name>getComponent</name>
<args>idx</args>
<desc>Get the component corresponding to the given index.
@param idx An integer index value corresponding to the desired component.
@return The id of the component at the given index as an integer</desc>
</method>
<method>
<name>getComponentCount</name>
<desc>Get the current component count
@return The number of components in the list as an integer</desc>
</method>
<method>
<name>getIsTemplate</name>
<desc>Check whether SimComponent is currently a template
@return true if is a template and false if not</desc>
</method>
<method>
<name>isEnabled</name>
<desc>Check whether SimComponent is currently enabled
@return true if enabled and false if not</desc>
</method>
<method>
<name>removeComponents</name>
<args> %compObjName, %compObjName2, ... </args>
</method>
<method>
<name>setEnabled</name>
<args>enabled</args>
<desc>Sets or unsets the enabled flag
@param enabled Boolean value
@return No return value</desc>
</method>
<method>
<name>setIsTemplate</name>
<args>template</args>
<desc>Sets or unsets the template flag
@param template Boolean value
@return No return value</desc>
</method>
<field>
<name>Template</name>
<desc>Places the object in a component set for later use in new levels.</desc>
</field>
</class>
<class>
<name>SimDataBlock</name>
<base>SimObject</base>
</class>
<class>
<name>SimDataBlockEvent</name>
</class>
<class>
<name>SimGroup</name>
<base>SimSet</base>
</class>
<class>
<name>SimObject</name>
<method>
<name>addFieldFilter</name>
<args>fieldName</args>
</method>
<method>
<name>call</name>
<args> %args </args>
<desc>- Dynamically call a method on an object.</desc>
</method>
<method>
<name>delete</name>
</method>
<method>
<name>dump</name>
</method>
<method>
<name>dumpClassHierarchy</name>
</method>
<method>
<name>getClassName</name>
</method>
<method>
<name>getClassNamespace</name>
</method>
<method>
<name>getDynamicField</name>
<args>index</args>
</method>
<method>
<name>getDynamicFieldCount</name>
</method>
<method>
<name>getField</name>
<args>int index</args>
<desc>- Gets the name of the field at the given index.</desc>
</method>
<method>
<name>getFieldCount</name>
<desc>- Gets the number of persistent fields on the object.</desc>
</method>
<method>
<name>getFieldType</name>
<args>fieldName</args>
</method>
<method>
<name>getFieldValue</name>
<args>fieldName</args>
</method>
<method>
<name>getFilename</name>
<desc>Returns the filename the object is attached to</desc>
</method>
<method>
<name>getGroup</name>
</method>
<method>
<name>getId</name>
</method>
<method>
<name>getInternalName</name>
<desc>getInternalName returns the objects internal name</desc>
</method>
<method>
<name>getName</name>
</method>
<method>
<name>getSuperClassNamespace</name>
</method>
<method>
<name>getType</name>
</method>
<method>
<name>isChildOfGroup</name>
<desc>returns true, if we are in the specified simgroup - or a subgroup thereof</desc>
</method>
<method>
<name>isEnabled</name>
</method>
<method>
<name>isExpanded</name>
<args>in editor</args>
</method>
<method>
<name>isMemberOfClass</name>
<args>string classname</args>
<desc>-- returns true if this object is a member of the specified class</desc>
</method>
<method>
<name>isMethod</name>
<args>string method name</args>
</method>
<method>
<name>isSelected</name>
<args>in editor</args>
</method>
<method>
<name>removeFieldFilter</name>
<args>fieldName</args>
</method>
<method>
<name>save</name>
<args>fileName, &lt;selectedOnly&gt;</args>
</method>
<method>
<name>schedule</name>
<args>time, command, &lt;arg1...argN&gt;</args>
</method>
<method>
<name>setClassNamespace</name>
</method>
<method>
<name>setEnabled</name>
<args>enabled</args>
</method>
<method>
<name>setFieldType</name>
<args>fieldName, typeString</args>
</method>
<method>
<name>setFieldValue</name>
<args>fieldName,value</args>
</method>
<method>
<name>setFilename</name>
<args>fileName</args>
<desc>Sets the object's file name and path</desc>
</method>
<method>
<name>setInternalName</name>
<desc>string InternalName</desc>
</method>
<method>
<name>setIsExpanded</name>
<args>in editor</args>
</method>
<method>
<name>setIsSelected</name>
<args>in editor</args>
</method>
<method>
<name>setName</name>
<args>newName</args>
</method>
<method>
<name>setSuperClassNamespace</name>
</method>
<field>
<name>canSaveDynamicFields</name>
<desc>True if dynamic fields (added at runtime) should be saved. Defaults to true.</desc>
</field>
<field>
<name>class</name>
<desc>Script class of object.</desc>
</field>
<field>
<name>className</name>
<desc>Script class of object.</desc>
</field>
<field>
<name>internalName</name>
<desc>Optional name that may be used to lookup this object within a SimSet.</desc>
</field>
<field>
<name>name</name>
<desc>Optional global name of this object.</desc>
</field>
<field>
<name>parentGroup</name>
<desc>Group hierarchy parent of the object.</desc>
</field>
<field>
<name>superClass</name>
<desc>Script super-class of object.</desc>
</field>
</class>
<class>
<name>SimpleComponent</name>
<base>SimComponent</base>
</class>
<class>
<name>SimpleMessageEvent</name>
</class>
<class>
<name>SimpleNetObject</name>
<base>NetObject</base>
<method>
<name>setMessage</name>
<args>string msg</args>
</method>
</class>
<class>
<name>SimResponseCurve</name>
<base>SimObject</base>
<method>
<name>addPoint</name>
<args> F32 value, F32 time </args>
</method>
<method>
<name>clear</name>
</method>
<method>
<name>getValue</name>
<args> F32 time </args>
</method>
</class>
<class>
<name>SimSet</name>
<base>SimObject</base>
<method>
<name>add</name>
<args>obj1,...</args>
</method>
<method>
<name>bringToFront</name>
<args>object</args>
</method>
<method>
<name>callOnChildren</name>
<args>funcName [,args ...]</args>
</method>
<method>
<name>clear</name>
</method>
<method>
<name>deleteAllObjects</name>
<desc>Deletes all the objects in the set.</desc>
</method>
<method>
<name>findObjectByInternalName</name>
<desc>string InternalName [, bool searchChildren]</desc>
</method>
<method>
<name>getCount</name>
<desc>returns the number of children that directly belong to this set (doesn't include the childrens' child objects</desc>
</method>
<method>
<name>getFullCount</name>
<desc>returns the full recursive count of the children of this group</desc>
</method>
<method>
<name>getObject</name>
<args>objIndex</args>
</method>
<method>
<name>getObjectIndex</name>
<args>object</args>
</method>
<method>
<name>getRandom</name>
<desc>Deletes all the objects in the set.</desc>
</method>
<method>
<name>isMember</name>
<args>object</args>
</method>
<method>
<name>listObjects</name>
</method>
<method>
<name>pushToBack</name>
<args>object</args>
</method>
<method>
<name>remove</name>
<args>obj1,...</args>
</method>
<method>
<name>reorderChild</name>
<args>child1, child2</args>
<desc>uses simset reorder to push child 1 before child 2 - both must already be child controls of this control</desc>
</method>
<method>
<name>sort</name>
<args> callbackFunction </args>
<desc>Performs a sort of the objects in the set using a script callback function to do the comparision.</desc>
</method>
</class>
<class>
<name>SimXMLDocument</name>
<base>SimObject</base>
<method>
<name>addComment</name>
<desc>Add the given comment as a child of current stack element.</desc>
</method>
<method>
<name>addData</name>
<desc>Add the given text as a child of current stack element.</desc>
</method>
<method>
<name>addHeader</name>
<desc>Add XML header to document.</desc>
</method>
<method>
<name>addNewElement</name>
<desc>Create new element as child of current stack element and push new element on to stack.</desc>
</method>
<method>
<name>addText</name>
<desc>Add the given text as a child of current stack element.</desc>
</method>
<method>
<name>attribute</name>
<args>string</args>
<desc>.</desc>
</method>
<method>
<name>attributeExists</name>
<desc>Get true if named attribute exists.</desc>
</method>
<method>
<name>attributeF32</name>
<desc>Get attribute value if it exists (float).</desc>
</method>
<method>
<name>attributeS32</name>
<desc>Get attribute value if it exists (int).</desc>
</method>
<method>
<name>clear</name>
<desc>Clear contents of XML document.</desc>
</method>
<method>
<name>clearError</name>
<desc>Clear error description.</desc>
</method>
<method>
<name>elementValue</name>
<desc>Get element value if it exists (string).</desc>
</method>
<method>
<name>firstAttribute</name>
<desc>Obtain the name of the current element's first attribute.</desc>
</method>
<method>
<name>getData</name>
<desc>Gets the text from the current stack element.</desc>
</method>
<method>
<name>getErrorDesc</name>
<desc>Get current error description.</desc>
</method>
<method>
<name>getText</name>
<desc>Gets the text from the current stack element.</desc>
</method>
<method>
<name>lastAttribute</name>
<desc>Obtain the name of the current element's last attribute.</desc>
</method>
<method>
<name>loadFile</name>
<desc>Load file from given filename.</desc>
</method>
<method>
<name>nextAttribute</name>
<desc>Get the name of the next attribute for the current element after a call to firstAttribute().</desc>
</method>
<method>
<name>nextSiblingElement</name>
<desc>Set top element on stack to next element with given name.</desc>
</method>
<method>
<name>parse</name>
<desc>Create document from XML string.</desc>
</method>
<method>
<name>popElement</name>
<desc>Pop last element off of stack.</desc>
</method>
<method>
<name>prevAttribute</name>
<desc>Get the name of the previous attribute for the current element after a call to lastAttribute().</desc>
</method>
<method>
<name>pushChildElement</name>
<desc>Push the child element at the given index onto stack.</desc>
</method>
<method>
<name>pushFirstChildElement</name>
<desc>Push first child element with given name onto stack.</desc>
</method>
<method>
<name>pushNewElement</name>
<desc>Create new element as child of current stack element and push new element on to stack.</desc>
</method>
<method>
<name>readComment</name>
<desc>Returns the comment at the specified index.</desc>
</method>
<method>
<name>removeText</name>
<desc>Remove any text on the current stack element.</desc>
</method>
<method>
<name>reset</name>
<desc>Set this to default state at construction.</desc>
</method>
<method>
<name>saveFile</name>
<desc>Save file to given filename.</desc>
</method>
<method>
<name>setAttribute</name>
<desc>Set attribute of top stack element to given value.</desc>
</method>
<method>
<name>setObjectAttributes</name>
<desc>Set attribute of top stack element to given value.</desc>
</method>
</class>
<class>
<name>Sky</name>
<base>SceneObject</base>
<method>
<name>applySkyChanges</name>
<desc>- Apply any changes.</desc>
</method>
<method>
<name>getWindVelocity</name>
</method>
<method>
<name>setWindVelocity</name>
<args>float x, float y, float z</args>
</method>
<method>
<name>stormClouds</name>
<args>bool show, float duration</args>
</method>
<method>
<name>stormCloudsShow</name>
<args>bool showClouds</args>
</method>
<field>
<name>cloudHeightPer</name>
<desc>float cloudHeightPer</desc>
</field>
<field>
<name>cloudSpeed1</name>
<desc>float cloudSpeed1</desc>
</field>
<field>
<name>cloudSpeed2</name>
<desc>float cloudSpeed2</desc>
</field>
<field>
<name>cloudSpeed3</name>
<desc>float cloudSpeed3</desc>
</field>
<field>
<name>materialList</name>
<desc>filename materialList</desc>
</field>
<field>
<name>noRenderBans</name>
<desc>bool noRenderBans</desc>
</field>
<field>
<name>renderBanOffsetHeight</name>
<desc>float renderBanOffsetHeight</desc>
</field>
<field>
<name>renderBottomTexture</name>
<desc>bool renderBottomTexture</desc>
</field>
<field>
<name>skyGlow</name>
<desc>bool skyGlow</desc>
</field>
<field>
<name>skyGlowColor</name>
<desc>ColorF skyGlowColor</desc>
</field>
<field>
<name>SkySolidColor</name>
<desc>ColorF SkySolidColor</desc>
</field>
<field>
<name>useSkyTextures</name>
<desc>bool useSkyTextures</desc>
</field>
<field>
<name>windVelocity</name>
<desc>Point3F windVelocity</desc>
</field>
</class>
<class>
<name>SkyBox</name>
<base>SceneObject</base>
<method>
<name>postApply</name>
</method>
<field>
<name>drawBottom</name>
<desc>If false the bottom of the skybox is not rendered.</desc>
</field>
<field>
<name>fogBandHeight</name>
<desc>The height (0-1) of the fog band from the horizon to the top of the SkyBox.</desc>
</field>
<field>
<name>Material</name>
<desc>The name of a cubemap material for the sky box.</desc>
</field>
</class>
<class>
<name>SpawnSphere</name>
<base>MissionMarker</base>
<method>
<name>spawnObject</name>
<args>[string additionalProps]</args>
<desc>Spawns the object based                                                        on the SpawnSphere's class, datablock, properties,                                                        and script settings. Allows you to pass in extra properties.</desc>
</method>
<field>
<name>autoSpawn</name>
<desc>bool autoSpawn</desc>
</field>
<field>
<name>indoorWeight</name>
<desc>float indoorWeight</desc>
</field>
<field>
<name>outdoorWeight</name>
<desc>float outdoorWeight</desc>
</field>
<field>
<name>radius</name>
<desc>float radius</desc>
</field>
<field>
<name>spawnClass</name>
<desc>String spawnClass</desc>
</field>
<field>
<name>spawnDatablock</name>
<desc>String spawnDatablock</desc>
</field>
<field>
<name>spawnProperties</name>
<desc>String spawnProperties</desc>
</field>
<field>
<name>spawnScript</name>
<desc>Command to execute when spawning an object. New object id is stored in $SpawnObject.  Max 255 characters.</desc>
</field>
<field>
<name>sphereWeight</name>
<desc>float sphereWeight</desc>
</field>
</class>
<class>
<name>Splash</name>
<base>GameBase</base>
</class>
<class>
<name>SplashData</name>
<base>GameBaseData</base>
<field>
<name>acceleration</name>
<desc>float acceleration</desc>
</field>
<field>
<name>colors</name>
<desc>ColorF colors</desc>
</field>
<field>
<name>delayMS</name>
<desc>int delayMS</desc>
</field>
<field>
<name>delayVariance</name>
<desc>int delayVariance</desc>
</field>
<field>
<name>ejectionAngle</name>
<desc>float ejectionAngle</desc>
</field>
<field>
<name>ejectionFreq</name>
<desc>float ejectionFreq</desc>
</field>
<field>
<name>emitter</name>
<desc>ParticleEmitterData emitter</desc>
</field>
<field>
<name>Explosion</name>
<desc>ExplosionData Explosion</desc>
</field>
<field>
<name>height</name>
<desc>float height</desc>
</field>
<field>
<name>lifetimeMS</name>
<desc>int lifetimeMS</desc>
</field>
<field>
<name>lifetimeVariance</name>
<desc>int lifetimeVariance</desc>
</field>
<field>
<name>numSegments</name>
<desc>int numSegments</desc>
</field>
<field>
<name>ringLifetime</name>
<desc>float ringLifetime</desc>
</field>
<field>
<name>scale</name>
<desc>Point3F scale</desc>
</field>
<field>
<name>soundProfile</name>
<desc>SFXProfile soundProfile</desc>
</field>
<field>
<name>startRadius</name>
<desc>float startRadius</desc>
</field>
<field>
<name>texFactor</name>
<desc>float texFactor</desc>
</field>
<field>
<name>texture</name>
<desc>filename texture</desc>
</field>
<field>
<name>texWrap</name>
<desc>float texWrap</desc>
</field>
<field>
<name>times</name>
<desc>float times</desc>
</field>
<field>
<name>velocity</name>
<desc>float velocity</desc>
</field>
<field>
<name>width</name>
<desc>float width</desc>
</field>
</class>
<class>
<name>SpotLight</name>
<base>LightBase</base>
<field>
<name>innerAngle</name>
<desc>float innerAngle</desc>
</field>
<field>
<name>outerAngle</name>
<desc>float outerAngle</desc>
</field>
<field>
<name>range</name>
<desc>float range</desc>
</field>
</class>
<class>
<name>StaticShape</name>
<base>ShapeBase</base>
<method>
<name>getPoweredState</name>
</method>
<method>
<name>setPoweredState</name>
<args>bool isPowered</args>
</method>
<field>
<name>customAmbientLighting</name>
<desc>ColorF customAmbientLighting</desc>
</field>
<field>
<name>lightGroupName</name>
<desc>String lightGroupName</desc>
</field>
<field>
<name>receiveLMLighting</name>
<desc>bool receiveLMLighting</desc>
</field>
<field>
<name>receiveSunLight</name>
<desc>bool receiveSunLight</desc>
</field>
<field>
<name>useCustomAmbientLighting</name>
<desc>bool useCustomAmbientLighting</desc>
</field>
</class>
<class>
<name>StaticShapeData</name>
<base>ShapeBaseData</base>
<field>
<name>dynamicType</name>
<desc>int dynamicType</desc>
</field>
<field>
<name>noIndividualDamage</name>
<desc>bool noIndividualDamage</desc>
</field>
</class>
<class>
<name>StreamObject</name>
<base>SimObject</base>
<method>
<name>copyFrom</name>
<args>StreamObject other</args>
</method>
<method>
<name>getPosition</name>
</method>
<method>
<name>getStatus</name>
</method>
<method>
<name>getStreamSize</name>
</method>
<method>
<name>isEOF</name>
<desc>Test for end of stream</desc>
</method>
<method>
<name>isEOS</name>
<desc>Test for end of stream</desc>
</method>
<method>
<name>readLine</name>
</method>
<method>
<name>readLongString</name>
<args>maxLength</args>
</method>
<method>
<name>readString</name>
</method>
<method>
<name>readSTString</name>
<args>[caseSensitive = false]</args>
</method>
<method>
<name>setPosition</name>
<args>newPosition</args>
</method>
<method>
<name>writeLine</name>
<args>line</args>
</method>
<method>
<name>writeLongString</name>
<args>maxLength, string</args>
</method>
<method>
<name>writeString</name>
<args>string, [maxLength = 255]</args>
</method>
</class>
<class>
<name>Sun</name>
<base>SceneObject</base>
<method>
<name>animate</name>
<args> F32 duration, F32 startAzimuth, F32 endAzimuth, F32 startElevation, F32 endElevation </args>
</method>
<method>
<name>apply</name>
</method>
<field>
<name>ambient</name>
<desc>Color shading applied to surfaces not in direct contact with light source, such as in the shadows or interiors.</desc>
</field>
<field>
<name>attenuationRatio</name>
<desc>The proportions of constant, linear, and quadratic attenuation to use for the falloff for point and spot lights.</desc>
</field>
<field>
<name>azimuth</name>
<desc>The horizontal angle of the sun measured clockwise from the positive Y world axis.</desc>
</field>
<field>
<name>brightness</name>
<desc>Adjust the Sun's global contrast/intensity</desc>
</field>
<field>
<name>castShadows</name>
<desc>Enables/disables shadows cast by objects due to Sun light</desc>
</field>
<field>
<name>color</name>
<desc>Color shading applied to surfaces in direct contact with light source.</desc>
</field>
<field>
<name>coronaEnabled</name>
<desc>bool coronaEnabled</desc>
</field>
<field>
<name>coronaScale</name>
<desc>float coronaScale</desc>
</field>
<field>
<name>coronaTexture</name>
<desc>filename coronaTexture</desc>
</field>
<field>
<name>coronaTint</name>
<desc>ColorF coronaTint</desc>
</field>
<field>
<name>coronaUseLightColor</name>
<desc>bool coronaUseLightColor</desc>
</field>
<field>
<name>elevation</name>
<desc>The elevation angle of the sun above or below the horizon.</desc>
</field>
<field>
<name>fadeStartDistance</name>
<desc>Start fading shadows out at this distance.  0 = auto calculate this distance.</desc>
</field>
<field>
<name>flareScale</name>
<desc>Changes the size and intensity of the flare</desc>
</field>
<field>
<name>flareType</name>
<desc>Datablock for the flare and corona produced by the Sun</desc>
</field>
<field>
<name>includeLightmappedGeometryInShadow</name>
<desc>This light should render lightmapped geometry during its shadow-map update (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>lastSplitTerrainOnly</name>
<desc>This toggles only terrain being rendered to the last split of a PSSM shadow map.</desc>
</field>
<field>
<name>logWeight</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>numSplits</name>
<desc>The logrithmic PSSM split distance factor.</desc>
</field>
<field>
<name>overDarkFactor</name>
<desc>The ESM shadow darkening factor</desc>
</field>
<field>
<name>representedInLightmap</name>
<desc>This light is represented in lightmaps (static light, default: false)</desc>
</field>
<field>
<name>shadowDarkenColor</name>
<desc>The color that should be used to multiply-blend dynamic shadows onto lightmapped geometry (ignored if 'representedInLightmap' is false)</desc>
</field>
<field>
<name>shadowDistance</name>
<desc>The distance from the camera to extend the PSSM shadow.</desc>
</field>
<field>
<name>shadowSoftness</name>
<desc>float shadowSoftness</desc>
</field>
<field>
<name>shadowType</name>
<desc>The type of shadow to use on this light.</desc>
</field>
<field>
<name>splitFadeDistances</name>
<desc>Distances (in world space units) that the shadows will fade between PSSM splits</desc>
</field>
<field>
<name>texSize</name>
<desc>The texture size of the shadow map.</desc>
</field>
</class>
<class>
<name>TCPGroup</name>
<base>SimGroup</base>
</class>
<class>
<name>TCPObject</name>
<base>SimObject</base>
<method>
<name>connect</name>
<args>string addr</args>
<desc>Connect to the given address.</desc>
</method>
<method>
<name>disconnect</name>
<desc>Disconnect from whatever we're connected to, if anything.</desc>
</method>
<method>
<name>listen</name>
<args>int port</args>
<desc>Start listening on the specified ports for connections.</desc>
</method>
<method>
<name>send</name>
<args>...</args>
<desc>Parameters are transmitted as strings, one at a time.</desc>
</method>
</class>
<class>
<name>TerrainBlock</name>
<base>SceneObject</base>
<method>
<name>createNew</name>
<args> String terrainName, U32 resolution, String materialName, bool genNoise </args>
</method>
<method>
<name>exportHeightMap</name>
<args>string filename, [string format]</args>
<desc>- export the terrain block's heightmap to a bitmap file (default: png)</desc>
</method>
<method>
<name>exportLayerMaps</name>
<args>string filePrefix, [string format]</args>
<desc>- export the terrain block's layer maps to bitmap files (default: png)</desc>
</method>
<method>
<name>import</name>
<args> String terrainName, String heightMap, F32 metersPerPixel, F32 heightScale, String materials, String opacityLayers </args>
</method>
<method>
<name>save</name>
<args>string fileName</args>
<desc>- saves the terrain block's terrain file to the specified file name.</desc>
</method>
<field>
<name>baseTexSize</name>
<desc>Size of base texture size per meter.</desc>
</field>
<field>
<name>screenError</name>
<desc>Not yet implemented.</desc>
</field>
<field>
<name>squareSize</name>
<desc>Indicates the spacing between points on the XY plane on the terrain.</desc>
</field>
<field>
<name>terrainFile</name>
<desc>The source terrain data file.</desc>
</field>
<field>
<name>tile</name>
<desc>Toggles infinite tiling of terrain.</desc>
</field>
</class>
<class>
<name>TerrainEditor</name>
<base>EditTSCtrl</base>
<method>
<name>addMaterial</name>
<args> string matName </args>
<desc>Adds a new material.</desc>
</method>
<method>
<name>attachTerrain</name>
<args>TerrainBlock terrain</args>
</method>
<method>
<name>clearSelection</name>
</method>
<method>
<name>getActionName</name>
<args>int num</args>
</method>
<method>
<name>getActiveTerrain</name>
</method>
<method>
<name>getBrushPos</name>
<desc>Returns a Point2I.</desc>
</method>
<method>
<name>getBrushPressure</name>
</method>
<method>
<name>getBrushSize</name>
</method>
<method>
<name>getBrushSoftness</name>
</method>
<method>
<name>getBrushType</name>
</method>
<method>
<name>getCurrentAction</name>
</method>
<method>
<name>getMaterialCount</name>
<desc>Returns the current material count.</desc>
</method>
<method>
<name>getMaterials</name>
<desc>gets the list of current terrain materials.</desc>
</method>
<method>
<name>getNumActions</name>
</method>
<method>
<name>getNumTextures</name>
</method>
<method>
<name>getSlopeLimitMaxAngle</name>
</method>
<method>
<name>getSlopeLimitMinAngle</name>
</method>
<method>
<name>getTerrainUnderWorldPoint</name>
<args>x/y/z</args>
<desc>Gets the terrain block that is located under the given world point.
@param x/y/z The world coordinates (floating point values) you wish to query at. These can be formatted as either a string ("x y z") or separately as (x, y, z)
@return Returns the ID of the requested terrain block (0 if not found).</desc>
</method>
<method>
<name>markEmptySquares</name>
</method>
<method>
<name>mirrorTerrain</name>
</method>
<method>
<name>processAction</name>
<args>string action=NULL</args>
</method>
<method>
<name>resetSelWeights</name>
<args>bool clear</args>
</method>
<method>
<name>setAction</name>
<args>string action_name</args>
</method>
<method>
<name>setBrushPos</name>
<args>int x, int y</args>
</method>
<method>
<name>setBrushPressure</name>
<args>float pressure</args>
</method>
<method>
<name>setBrushSize</name>
<args>int w [, int h]</args>
</method>
<method>
<name>setBrushSoftness</name>
<args>float softness</args>
</method>
<method>
<name>setBrushType</name>
<args>string type</args>
<desc>One of box, ellipse, selection.</desc>
</method>
<method>
<name>setSlopeLimitMaxAngle</name>
</method>
<method>
<name>setSlopeLimitMinAngle</name>
</method>
<method>
<name>setTerraformOverlay</name>
<args>bool overlayEnable</args>
<desc>- sets the terraformer current heightmap to draw as an overlay over the current terrain.</desc>
</method>
<method>
<name>updateMaterial</name>
<args> int index, string matName </args>
<desc>Changes the material name at the index.</desc>
</method>
<field>
<name>adjustHeightMouseScale</name>
<desc>float adjustHeightMouseScale</desc>
</field>
<field>
<name>adjustHeightVal</name>
<desc>float adjustHeightVal</desc>
</field>
<field>
<name>borderFillColor</name>
<desc>ColorI borderFillColor</desc>
</field>
<field>
<name>borderFrameColor</name>
<desc>ColorI borderFrameColor</desc>
</field>
<field>
<name>borderHeight</name>
<desc>float borderHeight</desc>
</field>
<field>
<name>borderLineMode</name>
<desc>bool borderLineMode</desc>
</field>
<field>
<name>isDirty</name>
<desc>bool isDirty</desc>
</field>
<field>
<name>isMissionDirty</name>
<desc>bool isMissionDirty</desc>
</field>
<field>
<name>materialGroup</name>
<desc>int materialGroup</desc>
</field>
<field>
<name>maxBrushSize</name>
<desc>Point2I maxBrushSize</desc>
</field>
<field>
<name>noiseFactor</name>
<desc>float noiseFactor</desc>
</field>
<field>
<name>paintIndex</name>
<desc>int paintIndex</desc>
</field>
<field>
<name>processUsesBrush</name>
<desc>bool processUsesBrush</desc>
</field>
<field>
<name>renderBorder</name>
<desc>bool renderBorder</desc>
</field>
<field>
<name>renderSolidBrush</name>
<desc>bool renderSolidBrush</desc>
</field>
<field>
<name>renderVertexSelection</name>
<desc>bool renderVertexSelection</desc>
</field>
<field>
<name>scaleVal</name>
<desc>float scaleVal</desc>
</field>
<field>
<name>selectionHidden</name>
<desc>bool selectionHidden</desc>
</field>
<field>
<name>setHeightVal</name>
<desc>float setHeightVal</desc>
</field>
<field>
<name>smoothFactor</name>
<desc>float smoothFactor</desc>
</field>
<field>
<name>softSelectDefaultFilter</name>
<desc>string softSelectDefaultFilter</desc>
</field>
<field>
<name>softSelectFilter</name>
<desc>string softSelectFilter</desc>
</field>
<field>
<name>softSelectRadius</name>
<desc>float softSelectRadius</desc>
</field>
</class>
<class>
<name>TerrainMaterial</name>
<base>SimObject</base>
<field>
<name>detailDistance</name>
<desc>float detailDistance</desc>
</field>
<field>
<name>detailMap</name>
<desc>filename detailMap</desc>
</field>
<field>
<name>detailSize</name>
<desc>float detailSize</desc>
</field>
<field>
<name>detailStrength</name>
<desc>float detailStrength</desc>
</field>
<field>
<name>diffuseMap</name>
<desc>filename diffuseMap</desc>
</field>
<field>
<name>diffuseSize</name>
<desc>float diffuseSize</desc>
</field>
<field>
<name>normalMap</name>
<desc>filename normalMap</desc>
</field>
<field>
<name>parallaxScale</name>
<desc>float parallaxScale</desc>
</field>
<field>
<name>useSideProjection</name>
<desc>bool useSideProjection</desc>
</field>
</class>
<class>
<name>TerrainMaterialSet</name>
<base>SimSet</base>
</class>
<class>
<name>TerrainSmoothAction</name>
<base>UndoAction</base>
<method>
<name>smooth</name>
<args> TerrainBlock obj, F32 factor, U32 steps </args>
</method>
</class>
<class>
<name>TimeOfDay</name>
<base>SceneObject</base>
<method>
<name>addTimeOfDayEvent</name>
<args> triggerElevation, identifierString </args>
</method>
<method>
<name>setDayLength</name>
<args> time </args>
</method>
<method>
<name>setPlay</name>
<args> bool </args>
</method>
<method>
<name>setTimeOfDay</name>
<args> time </args>
</method>
<field>
<name>axisTilt</name>
<desc>The angle in degrees between global equator and tropic.</desc>
</field>
<field>
<name>azimuthOverride</name>
<desc>float azimuthOverride</desc>
</field>
<field>
<name>dayLength</name>
<desc>The length of a virtual day in real world seconds.</desc>
</field>
<field>
<name>dayScale</name>
<desc>Scalar applied to time that elapses while the sun is up.</desc>
</field>
<field>
<name>nightScale</name>
<desc>Scalar applied to time that elapses while the sun is down.</desc>
</field>
<field>
<name>play</name>
<desc>True when the TimeOfDay object is operating.</desc>
</field>
<field>
<name>startTime</name>
<desc>float startTime</desc>
</field>
<field>
<name>time</name>
<desc>Current time of day.</desc>
</field>
</class>
<class>
<name>Trigger</name>
<base>GameBase</base>
<method>
<name>getNumObjects</name>
</method>
<method>
<name>getObject</name>
<args>int idx</args>
</method>
<field>
<name>enterCommand</name>
<desc>The command to execute when an object enters this trigger. Object id stored in %obj. Maximum 1023 characters.</desc>
</field>
<field>
<name>leaveCommand</name>
<desc>The command to execute when an object leaves this trigger. Object id stored in %obj. Maximum 1023 characters.</desc>
</field>
<field>
<name>polyhedron</name>
<desc>The polyhedron type is really a quadrilateral and consists of a cornerpoint followed by three vectors representing the edges extending from the corner.</desc>
</field>
<field>
<name>tickCommand</name>
<desc>The command to execute while an object is inside this trigger. Maximum 1023 characters.</desc>
</field>
</class>
<class>
<name>TriggerData</name>
<base>GameBaseData</base>
<method>
<name>onEnterTrigger</name>
<args> Trigger t, SimObject intruder</args>
</method>
<method>
<name>onLeaveTrigger</name>
<args> Trigger t, SimObject intruder</args>
</method>
<method>
<name>onTickTrigger</name>
<args> Trigger t </args>
</method>
<field>
<name>clientSide</name>
<desc>Only trigger on clients.</desc>
</field>
<field>
<name>tickPeriodMS</name>
<desc>Time between calls to TriggerData::onTickTrigger().</desc>
</field>
</class>
<class>
<name>TSShapeConstructor</name>
<base>SimObject</base>
<method>
<name>addAutoBillboard</name>
<args>int size, int equator_steps, int polar_steps, int dl, int dim, bool include_poles, float polar_angle</args>
</method>
<method>
<name>addMesh</name>
<args>(string shape_filename, string src_mesh</args>
<desc>|(prim_type, prim_size), string mesh_name)</desc>
</method>
<method>
<name>addNode</name>
<args>string node_name, string parent_name, [string px py pz [rx ry rz ra]], [isworld]</args>
</method>
<method>
<name>addSequence</name>
<args>string sequence_or_shape_file, string new_name, [int start_frame, [int end_frame]]</args>
</method>
<method>
<name>addTrigger</name>
<args>string sequence_name, int keyframe, int state</args>
</method>
<method>
<name>dumpShape</name>
<args>[string dump_filename]</args>
</method>
<method>
<name>getMeshCount</name>
<args>string object_name</args>
</method>
<method>
<name>getMeshMaterial</name>
<args>string mesh_name</args>
</method>
<method>
<name>getMeshName</name>
<args>string object_name, int index</args>
</method>
<method>
<name>getMeshType</name>
<args>string mesh_name</args>
</method>
<method>
<name>getNodeChildCount</name>
<args>string node_name</args>
</method>
<method>
<name>getNodeChildName</name>
<args>string node_name, int index</args>
</method>
<method>
<name>getNodeCount</name>
</method>
<method>
<name>getNodeIndex</name>
<args>string node_name</args>
</method>
<method>
<name>getNodeName</name>
<args>int index</args>
</method>
<method>
<name>getNodeObjectCount</name>
<args>string node_name</args>
</method>
<method>
<name>getNodeObjectName</name>
<args>string node_name, int object_index</args>
</method>
<method>
<name>getNodeParentName</name>
<args>string node_name</args>
</method>
<method>
<name>getNodeTransform</name>
<args>string node_name, [boolean isworld]</args>
</method>
<method>
<name>getObjectCount</name>
</method>
<method>
<name>getObjectName</name>
<args>int index</args>
</method>
<method>
<name>getObjectNode</name>
<args>string object_name</args>
</method>
<method>
<name>getSequenceBlend</name>
<args>string sequence_name</args>
</method>
<method>
<name>getSequenceCount</name>
</method>
<method>
<name>getSequenceCyclic</name>
<args>string sequence_name</args>
</method>
<method>
<name>getSequenceFrameCount</name>
<args>string sequence_name</args>
</method>
<method>
<name>getSequenceGroundSpeed</name>
<args>string sequence_name</args>
</method>
<method>
<name>getSequenceIndex</name>
<args>string sequence_name</args>
</method>
<method>
<name>getSequenceName</name>
<args>int index</args>
</method>
<method>
<name>getSequencePriority</name>
<args>string sequence_name</args>
</method>
<method>
<name>getSequenceSource</name>
<args>string sequence_name</args>
</method>
<method>
<name>getTrigger</name>
<args>string sequence_name, int trigger_index</args>
</method>
<method>
<name>getTriggerCount</name>
<args>string sequence_name</args>
</method>
<method>
<name>popChangeCommands</name>
<args>int count</args>
<desc>- only used by ShapeEditor for managing the undo stack</desc>
</method>
<method>
<name>removeAutoBillboard</name>
<args>int size</args>
</method>
<method>
<name>removeMesh</name>
<args>string mesh_name</args>
</method>
<method>
<name>removeNode</name>
<args>string node_name</args>
</method>
<method>
<name>removeObject</name>
<args>string object_name</args>
</method>
<method>
<name>removeSequence</name>
<args>string sequence_name</args>
</method>
<method>
<name>removeTrigger</name>
<args>string sequence_name, int keyframe, int state</args>
</method>
<method>
<name>renameNode</name>
<args>string old_name, string new_name</args>
</method>
<method>
<name>renameObject</name>
<args>string old_name, string new_name</args>
</method>
<method>
<name>renameSequence</name>
<args>string old_name, string new_name</args>
</method>
<method>
<name>saveShape</name>
<args>string filename</args>
</method>
<method>
<name>setMeshMaterial</name>
<args>string mesh_name, string material_name</args>
</method>
<method>
<name>setMeshSize</name>
<args>string old_name, int new_size</args>
</method>
<method>
<name>setMeshType</name>
<args>string mesh_name, string mesh_type</args>
</method>
<method>
<name>setNodeParent</name>
<args>string node_name, string parent_name</args>
</method>
<method>
<name>setNodeTransform</name>
<args>string node_name, string px py pz [rx ry rz ra], [boolean isworld]</args>
</method>
<method>
<name>setObjectNode</name>
<args>string object_name, string node_name</args>
</method>
<method>
<name>setSequenceBlend</name>
<args>string sequence_name, string blend_seq_name, int blend_ref_frame</args>
</method>
<method>
<name>setSequenceCyclic</name>
<args>string sequence_name, bool cyclic</args>
</method>
<method>
<name>setSequenceGroundSpeed</name>
<args>string sequence_name, string trans.x trans.y trans.z, [string rot.x rot.y rot.z</args>
</method>
<method>
<name>setSequencePriority</name>
<args>string sequence_name, float priority</args>
</method>
<field>
<name>adjustCenter</name>
<desc>Translate model so origin is at the center</desc>
</field>
<field>
<name>adjustFloor</name>
<desc>Translate model so origin is at the bottom</desc>
</field>
<field>
<name>alwaysImport</name>
<desc>TAB separated patterns of nodes to import even if in neverImport list</desc>
</field>
<field>
<name>baseShape</name>
<desc>filename baseShape</desc>
</field>
<field>
<name>forceUpdateMaterials</name>
<desc>Force update of materials.cs, even if Materials already exist</desc>
</field>
<field>
<name>ignoreNodeScale</name>
<desc>Ignore &lt;scale&gt; elements inside &lt;node&gt;s</desc>
</field>
<field>
<name>lodType</name>
<desc>Controls how LOD sizes are determined</desc>
</field>
<field>
<name>matNamePrefix</name>
<desc>Prefix to apply to COLLADA material names</desc>
</field>
<field>
<name>neverImport</name>
<desc>TAB separated patterns of nodes to ignore on loading</desc>
</field>
<field>
<name>sequence</name>
<desc>filename sequence</desc>
</field>
<field>
<name>singleDetailSize</name>
<desc>Detail size for all meshes in the model</desc>
</field>
<field>
<name>unit</name>
<desc>Override for the COLLADA &lt;unit&gt; element</desc>
</field>
<field>
<name>upAxis</name>
<desc>Override for the COLLADA &lt;up_axis&gt; element</desc>
</field>
</class>
<class>
<name>TSStatic</name>
<base>SceneObject</base>
<method>
<name>changeMaterial</name>
<args>mapTo, fromMaterial, ToMaterial</args>
</method>
<method>
<name>getModelFile</name>
<args> String </args>
</method>
<method>
<name>getTargetCount</name>
</method>
<method>
<name>getTargetName</name>
</method>
<field>
<name>allowPlayerStep</name>
<desc>Allow a player to collide with this object.</desc>
</field>
<field>
<name>collisionType</name>
<desc>enumval collisionType</desc>
</field>
<field>
<name>customAmbientLighting</name>
<desc>ColorF customAmbientLighting</desc>
</field>
<field>
<name>lightGroupName</name>
<desc>Groups shape in a set with other objects affected by a designatedlight source.</desc>
</field>
<field>
<name>playAmbient</name>
<desc>Play the "ambient" animation.</desc>
</field>
<field>
<name>receiveLMLighting</name>
<desc>Shape lighting affected by nearby lightmaps</desc>
</field>
<field>
<name>receiveSunLight</name>
<desc>Shape lighting affected by global Sun</desc>
</field>
<field>
<name>renderNormals</name>
<desc>Debug rendering mode which highlights shape normals.</desc>
</field>
<field>
<name>shapeName</name>
<desc>Name and path to model file.</desc>
</field>
<field>
<name>useCustomAmbientLighting</name>
<desc>Ambient light color (in low/no lighting condition))which overrides other sources, such as Sun.</desc>
</field>
</class>
<class>
<name>UndoAction</name>
<base>SimObject</base>
<method>
<name>addToManager</name>
<args>[undoManager]</args>
</method>
<field>
<name>actionName</name>
<desc>A brief description of the action, for UI representation of this undo/redo action.</desc>
</field>
</class>
<class>
<name>UndoManager</name>
<base>SimObject</base>
<method>
<name>clearAll</name>
<desc>Clears the undo manager.</desc>
</method>
<method>
<name>getNextRedoName</name>
</method>
<method>
<name>getNextUndoName</name>
</method>
<method>
<name>getRedoAction</name>
<args>index</args>
</method>
<method>
<name>getRedoCount</name>
</method>
<method>
<name>getRedoName</name>
<args>index</args>
</method>
<method>
<name>getUndoAction</name>
<args>index</args>
</method>
<method>
<name>getUndoCount</name>
</method>
<method>
<name>getUndoName</name>
<args>index</args>
</method>
<method>
<name>redo</name>
</method>
<method>
<name>undo</name>
</method>
<field>
<name>numLevels</name>
<desc>Number of undo &amp; redo levels.</desc>
</field>
</class>
<class>
<name>UndoScriptAction</name>
<base>UndoAction</base>
</class>
<class>
<name>Vehicle</name>
<base>ShapeBase</base>
<field>
<name>disableMove</name>
<desc>bool disableMove</desc>
</field>
</class>
<class>
<name>VehicleBlocker</name>
<base>SceneObject</base>
<field>
<name>dimensions</name>
<desc>Point3F dimensions</desc>
</field>
</class>
<class>
<name>VehicleData</name>
<base>ShapeBaseData</base>
<field>
<name>bodyFriction</name>
<desc>float bodyFriction</desc>
</field>
<field>
<name>bodyRestitution</name>
<desc>float bodyRestitution</desc>
</field>
<field>
<name>cameraDecay</name>
<desc>float cameraDecay</desc>
</field>
<field>
<name>cameraLag</name>
<desc>float cameraLag</desc>
</field>
<field>
<name>cameraOffset</name>
<desc>float cameraOffset</desc>
</field>
<field>
<name>cameraRoll</name>
<desc>bool cameraRoll</desc>
</field>
<field>
<name>collDamageMultiplier</name>
<desc>float collDamageMultiplier</desc>
</field>
<field>
<name>collDamageThresholdVel</name>
<desc>float collDamageThresholdVel</desc>
</field>
<field>
<name>collisionTol</name>
<desc>float collisionTol</desc>
</field>
<field>
<name>contactTol</name>
<desc>float contactTol</desc>
</field>
<field>
<name>damageEmitter</name>
<desc>ParticleEmitterData damageEmitter</desc>
</field>
<field>
<name>damageEmitterOffset</name>
<desc>Point3F damageEmitterOffset</desc>
</field>
<field>
<name>damageLevelTolerance</name>
<desc>float damageLevelTolerance</desc>
</field>
<field>
<name>dustEmitter</name>
<desc>ParticleEmitterData dustEmitter</desc>
</field>
<field>
<name>dustHeight</name>
<desc>float dustHeight</desc>
</field>
<field>
<name>exitingWater</name>
<desc>SFXProfile exitingWater</desc>
</field>
<field>
<name>exitSplashSoundVelocity</name>
<desc>float exitSplashSoundVelocity</desc>
</field>
<field>
<name>hardImpactSound</name>
<desc>SFXProfile hardImpactSound</desc>
</field>
<field>
<name>hardImpactSpeed</name>
<desc>float hardImpactSpeed</desc>
</field>
<field>
<name>hardSplashSoundVelocity</name>
<desc>float hardSplashSoundVelocity</desc>
</field>
<field>
<name>impactWaterEasy</name>
<desc>SFXProfile impactWaterEasy</desc>
</field>
<field>
<name>impactWaterHard</name>
<desc>SFXProfile impactWaterHard</desc>
</field>
<field>
<name>impactWaterMedium</name>
<desc>SFXProfile impactWaterMedium</desc>
</field>
<field>
<name>integration</name>
<desc>int integration</desc>
</field>
<field>
<name>jetEnergyDrain</name>
<desc>float jetEnergyDrain</desc>
</field>
<field>
<name>jetForce</name>
<desc>float jetForce</desc>
</field>
<field>
<name>massBox</name>
<desc>Point3F massBox</desc>
</field>
<field>
<name>massCenter</name>
<desc>Point3F massCenter</desc>
</field>
<field>
<name>maxDrag</name>
<desc>float maxDrag</desc>
</field>
<field>
<name>maxSteeringAngle</name>
<desc>float maxSteeringAngle</desc>
</field>
<field>
<name>mediumSplashSoundVelocity</name>
<desc>float mediumSplashSoundVelocity</desc>
</field>
<field>
<name>minDrag</name>
<desc>float minDrag</desc>
</field>
<field>
<name>minImpactSpeed</name>
<desc>float minImpactSpeed</desc>
</field>
<field>
<name>minJetEnergy</name>
<desc>float minJetEnergy</desc>
</field>
<field>
<name>minRollSpeed</name>
<desc>float minRollSpeed</desc>
</field>
<field>
<name>numDmgEmitterAreas</name>
<desc>float numDmgEmitterAreas</desc>
</field>
<field>
<name>softImpactSound</name>
<desc>SFXProfile softImpactSound</desc>
</field>
<field>
<name>softImpactSpeed</name>
<desc>float softImpactSpeed</desc>
</field>
<field>
<name>softSplashSoundVelocity</name>
<desc>float softSplashSoundVelocity</desc>
</field>
<field>
<name>splashEmitter</name>
<desc>ParticleEmitterData splashEmitter</desc>
</field>
<field>
<name>splashFreqMod</name>
<desc>float splashFreqMod</desc>
</field>
<field>
<name>splashVelEpsilon</name>
<desc>float splashVelEpsilon</desc>
</field>
<field>
<name>triggerDustHeight</name>
<desc>float triggerDustHeight</desc>
</field>
<field>
<name>waterWakeSound</name>
<desc>SFXProfile waterWakeSound</desc>
</field>
</class>
<class>
<name>WaterBlock</name>
<base>SceneObject</base>
<field>
<name>BaseColor</name>
<desc>Changes color of water fog.</desc>
</field>
<field>
<name>clarity</name>
<desc>Relative opacity or transparency of the water surface.</desc>
</field>
<field>
<name>cubemap</name>
<desc>Cubemap used instead of reflection texture if fullReflect is off.</desc>
</field>
<field>
<name>density</name>
<desc>Affects buoyancy of an object, thus affecting the Z velocity of a player (jumping, falling, etc.</desc>
</field>
<field>
<name>distortEndDist</name>
<desc>Max distance that distortion algorithm is performed. The lower, the more distorted the effect.</desc>
</field>
<field>
<name>distortFullDepth</name>
<desc>Determines the scaling down of distortion in shallow water.</desc>
</field>
<field>
<name>distortStartDist</name>
<desc>Determines start of distortion effect where water surface intersects the camera near plane.</desc>
</field>
<field>
<name>foamColorModulate</name>
<desc>An RGB value taht linearly interpolates between the base foam color and ambient color so there are not bright white white colors during inappropriate situations, such as night.</desc>
</field>
<field>
<name>foamMaxDepth</name>
<desc>Controls how deep foam will be visible from underwater.</desc>
</field>
<field>
<name>foamScale</name>
<desc>Size of the foam generated by WaterBlock hitting shore.</desc>
</field>
<field>
<name>foamTex</name>
<desc>Diffuse texture for foam in shallow water (advanced lighting only)</desc>
</field>
<field>
<name>fresnelBias</name>
<desc>Extent of fresnel affecting reflection fogging.</desc>
</field>
<field>
<name>fresnelPower</name>
<desc>Measures intensity of affect on reflection based on fogging.</desc>
</field>
<field>
<name>fullReflect</name>
<desc>Enables dynamic reflection rendering.</desc>
</field>
<field>
<name>gridElementSize</name>
<desc>Spacing between vertices in the WaterBlock mesh</desc>
</field>
<field>
<name>gridSize</name>
<desc>Duplicate of gridElementSize for backwards compatility</desc>
</field>
<field>
<name>liquidType</name>
<desc>Liquid type of WaterBlock, such as water, ocean, lava Currently only Water is defined and used.</desc>
</field>
<field>
<name>overallRippleMagnitude</name>
<desc>Master variable affecting entire surface</desc>
</field>
<field>
<name>overallWaveMagnitude</name>
<desc>Master variable affecting entire body of water's undulation</desc>
</field>
<field>
<name>reflectDetailAdjust</name>
<desc>scale up or down the detail level for objects rendered in a reflection</desc>
</field>
<field>
<name>reflectMaxRateMs</name>
<desc>Affects the sort time of reflected objects.</desc>
</field>
<field>
<name>reflectNormalUp</name>
<desc>always use z up as the reflection normal</desc>
</field>
<field>
<name>reflectPriority</name>
<desc>Affects the sort order of reflected objects.</desc>
</field>
<field>
<name>reflectTexSize</name>
<desc>The texture size used for reflections (square)</desc>
</field>
<field>
<name>rippleDir</name>
<desc>Modifies the direction of ripples on the surface.</desc>
</field>
<field>
<name>rippleMagnitude</name>
<desc>Intensifies the vertext modification of the surface.</desc>
</field>
<field>
<name>rippleSpeed</name>
<desc>Modifies speed of surface ripples.</desc>
</field>
<field>
<name>rippleTex</name>
<desc>Normal map used to simulate small surface ripples</desc>
</field>
<field>
<name>rippleTexScale</name>
<desc>Intensifies the affect of the normal map applied to the surface.</desc>
</field>
<field>
<name>underwaterColor</name>
<desc>Changes the color shading of objects beneath the water surface.</desc>
</field>
<field>
<name>useOcclusionQuery</name>
<desc>turn off reflection rendering when occluded (delayed).</desc>
</field>
<field>
<name>viscosity</name>
<desc>Affects drag force applied to an object submerged in this container.</desc>
</field>
<field>
<name>waterFogDensity</name>
<desc>Intensity of underwater fogging.</desc>
</field>
<field>
<name>waterFogDensityOffset</name>
<desc>Delta, or limit, applied to waterFogDensity.</desc>
</field>
<field>
<name>waveDir</name>
<desc>Direction waves flow toward shores.</desc>
</field>
<field>
<name>waveMagnitude</name>
<desc>Height of water undulation.</desc>
</field>
<field>
<name>waveSpeed</name>
<desc>Speed of water undulation.</desc>
</field>
<field>
<name>wetDarkening</name>
<desc>The refract color intensity scaled at wetDepth.</desc>
</field>
<field>
<name>wetDepth</name>
<desc>The depth in world units at which full darkening will be received, giving a wet look to objects underwater.</desc>
</field>
</class>
<class>
<name>WaterPlane</name>
<base>SceneObject</base>
<field>
<name>BaseColor</name>
<desc>Changes color of water fog.</desc>
</field>
<field>
<name>clarity</name>
<desc>Relative opacity or transparency of the water surface.</desc>
</field>
<field>
<name>cubemap</name>
<desc>Cubemap used instead of reflection texture if fullReflect is off.</desc>
</field>
<field>
<name>density</name>
<desc>Affects buoyancy of an object, thus affecting the Z velocity of a player (jumping, falling, etc.</desc>
</field>
<field>
<name>distortEndDist</name>
<desc>Max distance that distortion algorithm is performed. The lower, the more distorted the effect.</desc>
</field>
<field>
<name>distortFullDepth</name>
<desc>Determines the scaling down of distortion in shallow water.</desc>
</field>
<field>
<name>distortStartDist</name>
<desc>Determines start of distortion effect where water surface intersects the camera near plane.</desc>
</field>
<field>
<name>foamColorModulate</name>
<desc>An RGB value taht linearly interpolates between the base foam color and ambient color so there are not bright white white colors during inappropriate situations, such as night.</desc>
</field>
<field>
<name>foamMaxDepth</name>
<desc>Controls how deep foam will be visible from underwater.</desc>
</field>
<field>
<name>foamScale</name>
<desc>Size of the foam generated by WaterBlock hitting shore.</desc>
</field>
<field>
<name>foamTex</name>
<desc>Diffuse texture for foam in shallow water (advanced lighting only)</desc>
</field>
<field>
<name>fresnelBias</name>
<desc>Extent of fresnel affecting reflection fogging.</desc>
</field>
<field>
<name>fresnelPower</name>
<desc>Measures intensity of affect on reflection based on fogging.</desc>
</field>
<field>
<name>fullReflect</name>
<desc>Enables dynamic reflection rendering.</desc>
</field>
<field>
<name>gridElementSize</name>
<desc>Duplicate of gridElementSize for backwards compatility</desc>
</field>
<field>
<name>gridSize</name>
<desc>Spacing between vertices in the WaterBlock mesh</desc>
</field>
<field>
<name>liquidType</name>
<desc>Liquid type of WaterBlock, such as water, ocean, lava Currently only Water is defined and used.</desc>
</field>
<field>
<name>overallRippleMagnitude</name>
<desc>Master variable affecting entire surface</desc>
</field>
<field>
<name>overallWaveMagnitude</name>
<desc>Master variable affecting entire body of water's undulation</desc>
</field>
<field>
<name>reflectDetailAdjust</name>
<desc>scale up or down the detail level for objects rendered in a reflection</desc>
</field>
<field>
<name>reflectMaxRateMs</name>
<desc>Affects the sort time of reflected objects.</desc>
</field>
<field>
<name>reflectNormalUp</name>
<desc>always use z up as the reflection normal</desc>
</field>
<field>
<name>reflectPriority</name>
<desc>Affects the sort order of reflected objects.</desc>
</field>
<field>
<name>reflectTexSize</name>
<desc>The texture size used for reflections (square)</desc>
</field>
<field>
<name>rippleDir</name>
<desc>Modifies the direction of ripples on the surface.</desc>
</field>
<field>
<name>rippleMagnitude</name>
<desc>Intensifies the vertext modification of the surface.</desc>
</field>
<field>
<name>rippleSpeed</name>
<desc>Modifies speed of surface ripples.</desc>
</field>
<field>
<name>rippleTex</name>
<desc>Normal map used to simulate small surface ripples</desc>
</field>
<field>
<name>rippleTexScale</name>
<desc>Intensifies the affect of the normal map applied to the surface.</desc>
</field>
<field>
<name>underwaterColor</name>
<desc>Changes the color shading of objects beneath the water surface.</desc>
</field>
<field>
<name>useOcclusionQuery</name>
<desc>turn off reflection rendering when occluded (delayed).</desc>
</field>
<field>
<name>viscosity</name>
<desc>Affects drag force applied to an object submerged in this container.</desc>
</field>
<field>
<name>waterFogDensity</name>
<desc>Intensity of underwater fogging.</desc>
</field>
<field>
<name>waterFogDensityOffset</name>
<desc>Delta, or limit, applied to waterFogDensity.</desc>
</field>
<field>
<name>waveDir</name>
<desc>Direction waves flow toward shores.</desc>
</field>
<field>
<name>waveMagnitude</name>
<desc>Height of water undulation.</desc>
</field>
<field>
<name>waveSpeed</name>
<desc>Speed of water undulation.</desc>
</field>
<field>
<name>wetDarkening</name>
<desc>The refract color intensity scaled at wetDepth.</desc>
</field>
<field>
<name>wetDepth</name>
<desc>The depth in world units at which full darkening will be received, giving a wet look to objects underwater.</desc>
</field>
</class>
<class>
<name>WayPoint</name>
<base>MissionMarker</base>
<field>
<name>team</name>
<desc>WayPointTeam team</desc>
</field>
</class>
<class>
<name>WayPointSet</name>
<base>SimSet</base>
</class>
<class>
<name>WheeledVehicle</name>
<base>Vehicle</base>
<method>
<name>getWheelCount</name>
</method>
<method>
<name>setWheelPowered</name>
<args>wheel#,bool</args>
</method>
<method>
<name>setWheelSpring</name>
<args>wheel#,spring</args>
</method>
<method>
<name>setWheelSteering</name>
<args>wheel#,float</args>
</method>
<method>
<name>setWheelTire</name>
<args>wheel#,tire</args>
</method>
</class>
<class>
<name>WheeledVehicleData</name>
<base>VehicleData</base>
<field>
<name>brakeTorque</name>
<desc>float brakeTorque</desc>
</field>
<field>
<name>engineBrake</name>
<desc>float engineBrake</desc>
</field>
<field>
<name>engineSound</name>
<desc>SFXProfile engineSound</desc>
</field>
<field>
<name>engineTorque</name>
<desc>float engineTorque</desc>
</field>
<field>
<name>jetSound</name>
<desc>SFXProfile jetSound</desc>
</field>
<field>
<name>maxWheelSpeed</name>
<desc>float maxWheelSpeed</desc>
</field>
<field>
<name>squealSound</name>
<desc>SFXProfile squealSound</desc>
</field>
<field>
<name>tireEmitter</name>
<desc>ParticleEmitterData tireEmitter</desc>
</field>
<field>
<name>WheelImpactSound</name>
<desc>SFXProfile WheelImpactSound</desc>
</field>
</class>
<class>
<name>WheeledVehicleSpring</name>
<base>SimDataBlock</base>
<field>
<name>antiSwayForce</name>
<desc>float antiSwayForce</desc>
</field>
<field>
<name>damping</name>
<desc>float damping</desc>
</field>
<field>
<name>force</name>
<desc>float force</desc>
</field>
<field>
<name>length</name>
<desc>float length</desc>
</field>
</class>
<class>
<name>WheeledVehicleTire</name>
<base>SimDataBlock</base>
<field>
<name>kineticFriction</name>
<desc>float kineticFriction</desc>
</field>
<field>
<name>lateralDamping</name>
<desc>float lateralDamping</desc>
</field>
<field>
<name>lateralForce</name>
<desc>float lateralForce</desc>
</field>
<field>
<name>lateralRelaxation</name>
<desc>float lateralRelaxation</desc>
</field>
<field>
<name>logitudinalRelaxation</name>
<desc>float logitudinalRelaxation</desc>
</field>
<field>
<name>longitudinalDamping</name>
<desc>float longitudinalDamping</desc>
</field>
<field>
<name>longitudinalForce</name>
<desc>float longitudinalForce</desc>
</field>
<field>
<name>mass</name>
<desc>float mass</desc>
</field>
<field>
<name>radius</name>
<desc>float radius</desc>
</field>
<field>
<name>restitution</name>
<desc>float restitution</desc>
</field>
<field>
<name>shapeFile</name>
<desc>filename shapeFile</desc>
</field>
<field>
<name>staticFriction</name>
<desc>float staticFriction</desc>
</field>
</class>
<class>
<name>ZipObject</name>
<base>SimObject</base>
<method>
<name>addFile</name>
<args>filename, pathInZip[, replace = true]</args>
<desc>Add a file to the zip</desc>
</method>
<method>
<name>closeArchive</name>
<desc>Close a zip file</desc>
</method>
<method>
<name>closeFile</name>
<args>stream</args>
<desc>Close a file within the zip</desc>
</method>
<method>
<name>deleteFile</name>
<args>pathInZip</args>
<desc>Delete a file from the zip</desc>
</method>
<method>
<name>extractFile</name>
<args>pathInZip, filename</args>
<desc>Extract a file from the zip</desc>
</method>
<method>
<name>getFileEntry</name>
<args>index</args>
<desc>Get file entry. Returns tab separated string containing filename, uncompressed size, compressed size, compression method and CRC32</desc>
</method>
<method>
<name>getFileEntryCount</name>
<desc>Get number of files in the zip</desc>
</method>
<method>
<name>openArchive</name>
<args>filename, [accessMode = Read]</args>
<desc>Open a zip file</desc>
</method>
<method>
<name>openFileForRead</name>
<args>filename</args>
<desc>Open a file within the zip for reading</desc>
</method>
<method>
<name>openFileForWrite</name>
<args>filename</args>
<desc>Open a file within the zip for reading</desc>
</method>
</class>
<class>
<name>Zone</name>
<base>SceneObject</base>
</class>
</exports>
